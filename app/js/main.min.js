/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/src/js/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	// Canvas
	__webpack_require__(2);
	
	// User interaction elements
	__webpack_require__(3);


/***/ },
/* 2 */
/***/ function(module, exports) {

	// background contains the static canvas elements
	var background = document.getElementById("static");
	var backgroundContext = background.getContext("2d");
	
	// Settings for the background - move out to a separate file
	var settings = {
	    backgroundColor: "#8CD1E6",
	    pathColor: "gray"
	}
	
	// Drawing the background
	backgroundContext.fillStyle = settings.backgroundColor;
	backgroundContext.fillRect(0, 0, background.width, background.height);
	
	/* Main path will go from [0, 500], [75, 500], [75, 100], [225, 100], [225, 500], [375, 500], [375, 100], [525, 100], [525, 500], [675, 500], [675, 100], [825, 100], [825, 500], [900, 500] */
	
	// Drawing the path - width of the path is 50px
	backgroundContext.fillStyle = settings.pathColor;
	
	backgroundContext.beginPath();
	
	// For the bottom part of the path
	backgroundContext.moveTo(0, 525);
	
	backgroundContext.lineTo(100, 525);
	backgroundContext.lineTo(100, 125); // Top
	backgroundContext.lineTo(200, 125);
	backgroundContext.lineTo(200, 525); // Bottom
	backgroundContext.lineTo(400, 525);
	backgroundContext.lineTo(400, 125); // Top
	backgroundContext.lineTo(500, 125);
	backgroundContext.lineTo(500, 525); // Bottom
	backgroundContext.lineTo(700, 525);
	backgroundContext.lineTo(700, 125); // Top
	backgroundContext.lineTo(800, 125);
	backgroundContext.lineTo(800, 525); // Bottom
	
	//Middle section to the side
	backgroundContext.lineTo(900, 525);
	backgroundContext.lineTo(900, 475);
	backgroundContext.lineTo(850, 475);
	
	// For the top part of the path
	backgroundContext.lineTo(850, 75);
	backgroundContext.lineTo(650, 75);
	backgroundContext.lineTo(650, 475);
	backgroundContext.lineTo(550, 475);
	backgroundContext.lineTo(550, 75);
	backgroundContext.lineTo(350, 75);
	backgroundContext.lineTo(350, 475);
	backgroundContext.lineTo(250, 475);
	backgroundContext.lineTo(250, 75);
	backgroundContext.lineTo(50, 75);
	backgroundContext.lineTo(50, 475);
	
	// End section
	backgroundContext.lineTo(0, 475);
	
	backgroundContext.fill();
	// backgroundContext.lineTo();


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	// NOTE At some point I think we can move some functions into a different file
	
	// Initiate all the components
	var Tower = __webpack_require__(4),
	    GameEngine = __webpack_require__(6),
	    monsterData = __webpack_require__(8),
	    towerData = __webpack_require__(5);
	
	// Cache reused DOM elements
	var infoName = document.getElementById("info-name"),
	    infoIcon = document.getElementById("info-icon"),
	    infoBox1 = document.getElementById("info-box-1"),
	    infoBox2 = document.getElementById("info-box-2"),
	    infoBox3 = document.getElementById("info-box-3"),
	    infoBox4 = document.getElementById("info-box-4"),
	    levelInfo = document.getElementById("level"),
	    goldInfo = document.getElementById("gold"),
	    livesInfo = document.getElementById("lives");
	
	var towerCards = document.getElementsByClassName("tower-card"),
	    towerCardList = [];
	// Convert from nodelist to array
	towerCards = Array.prototype.slice.call(towerCards);
	
	// create state variables
	var activeCanvasElement = {type: null}, // initiate default as null - update this variable when monster/tower changes
	    activeTowerSelected = null,
	    activeErrorMessage = {message: null};
	
	//  creates global variables
	game = new GameEngine;
	dynamicCanvas = document.getElementById('dynamic');
	dynamicContext = dynamicCanvas.getContext('2d');
	
	runCycle = function() {
	    game.runCycle();
	    setTimeout(runCycle, 1000);
	}
	
	renderCycle = function() {
	    game.render();
	    // Renders the information and error messages based on the state variables
	    renderErrorMessage();
	    renderInformationContainer();
	    renderHUD();
	    renderTowerPlacement();
	    requestAnimationFrame(renderCycle);
	}
	
	/* ================== Helper functions =================*/
	/* =====================================================*/
	function addClass(element, cssClass) {
	    if (element.className === "") {
	        element.className = cssClass;
	    } else {
	        element.className += " " + cssClass;
	    }
	}
	
	function removeClass(element, cssClass) {
	    var arrayOfClasses = element.className.split(" ");
	    for (var i = 0, j = arrayOfClasses.length; i < j; i++) {
	        if (arrayOfClasses[i] === cssClass) {
	            arrayOfClasses.splice(i, 1);
	            i--; j--;
	        }
	    }
	    element.className = arrayOfClasses.join(" ");
	}
	
	// Gets the index of the tower cards based on a tower's name
	function getTowerCardIndex(towerName) {
	    return towerCardList.indexOf(towerName);
	}
	
	/* ================== Render functions =================*/
	/* =====================================================*/
	// Render functions run every game cycle (on the renderCycle function call)
	// Renders based on the state variables
	
	function renderInformationContainer() {
	    if (activeCanvasElement.type === "monster") {
	        renderMonsterInformation(activeCanvasElement.id, activeCanvasElement.index);
	    } else if (activeCanvasElement.type === "tower") {
	        renderTowerInformation(activeCanvasElement.id, activeCanvasElement.index);
	    } else {
	        renderDefaultInformation();
	    }
	}
	
	// ID refers to the type of monster and index is the index of the active monster in the active monster's array
	function renderMonsterInformation(id, index) {
	    var currentHp = game.activeMonsters[index].currentHp,
	        maxHp = game.activeMonsters[index].maxHp,
	        type = game.activeMonsters[index].type;
	    infoName.innerHTML = id;
	    // Change icon to active monster - use a sprite
	    infoBox1.innerHTML = "HP: " + currentHp + " / " + maxHp;
	    infoBox2.innerHTML = "Type: " + type;
	    infoBox3.innerHTML = "Strengths: All sorts mate" ;
	    infoBox4.innerHTML = "Weaknesses: Ducks" ;
	}
	
	// ID refers to the type of tower and index is the index of the active tower in the active tower's array
	function renderTowerInformation(id, index) {
	    infoName.innerHTML = id;
	    // Change icon to active monster - use a sprite
	    infoBox1.innerHTML = "Damage: <br> Range: <br> Effect: ";
	    infoBox2.innerHTML = "Attack Speed: <br> Type: " ;
	    infoBox3.innerHTML = "<a class='waves-effect waves-light btn red'>Upgrade</a>" ;
	    infoBox4.innerHTML = "<a class='waves-effect waves-light btn red'>Sell</a>" ;
	    // Change icon to tower monster - use a sprite
	
	}
	
	function renderDefaultInformation() {
	    infoName.innerHTML = "Awesome TD";
	    // Change icon to default image - use a sprite
	    infoBox1.innerHTML = "This is some text";
	    infoBox2.innerHTML = "This is different text";
	    infoBox3.innerHTML = "This is ??? text" ;
	    infoBox4.innerHTML = "This 1231241235" ;
	}
	
	// Maybe change this to "renderMessage"
	function renderErrorMessage() {
	    if (activeErrorMessage.message === null) {
	        return;
	    } else {
	        dynamicContext.globalAlpha = activeErrorMessage.timer / 50;
	        dynamicContext.font = '40pt Droid Sans';
	        dynamicContext.textAlign = "center";
	        dynamicContext.fillStyle = "red";
	        dynamicContext.fillText(activeErrorMessage.message, 450, 50);
	        dynamicContext.globalAlpha = 1;
	
	        if (activeErrorMessage.timer === 0) {
	            activeErrorMessage = {message: null}; // Reset error message
	        } else {
	            activeErrorMessage.timer--;
	        }
	    }
	}
	
	function renderTowerPlacement() {
	    if (activeTowerSelected === null) {
	        return
	    };
	    // ELSE render the tower on the canvas
	    // do some sort of logic to highlight the tiles that the tower would be placed on and show the tower on those positions
	}
	
	
	function renderHUD() {
	    livesInfo.innerHTML = game.userLives;
	    goldInfo.innerHTML = game.userGold;
	    levelInfo.innerHTML = game.level;
	}
	/* ================ UI Event Listeners =================*/
	/* =====================================================*/
	document.getElementById("start-btn").addEventListener("click", function() {
	    // Hides the modal lightbox
	    document.getElementsByClassName("modal-content")[0].style.display = "none";
	    document.getElementsByClassName("modal-background")[0].style.display = "none";
	
	    // run repeating function that runs game engine run cycle and rendering
	    setTimeout(runCycle, 1000);
	    requestAnimationFrame(renderCycle);
	});
	
	// On clicking the information button, show the information panel
	document.getElementById("information-btn").addEventListener("click", function() {
	    // TODO - add information modal information thingy
	    console.log("show information container here");
	});
	
	/*
	These event listeners control the application by interacting with the game
	object and by changing the state variables (which the render functions use
	to read)
	*/
	towerCards.map(function(towerCard, i) {
	    towerCardList.push(towerCard.getAttribute("data-tower"));
	    towerCard.addEventListener("click", towerCardClick);
	});
	
	document.getElementById("dynamic").onmousemove = onCanvasMouseMovement;
	document.getElementById("dynamic").addEventListener("click", canvasClick);
	
	document.onkeydown = function(e) {
	    if (e.keyCode === 27) {
	        cancelTowerPlacement();
	    }
	}
	
	/* =================== UI Functions ====================*/
	/* =====================================================*/
	/*
	Takes in three arguments - location of the click, location of an element
	(i.e. monster or tower) and the type (whether it is a monster or a tower -
	different dimensions)
	Returns a boolean - true if the click overlaps with an element and false
	if it does not
	*/
	function comparePositions(clickPosition, elementPosition, type) {
	    var sideLength = type === "monster" ? 30 : 50; // width and height of the element
	    if (clickPosition.x >= elementPosition.x
	    && clickPosition.x <= elementPosition.x + sideLength
	    && clickPosition.y >= elementPosition.y
	    && clickPosition.y <= elementPosition.y + sideLength) {
	        return true;
	    } else {
	        return false;
	    }
	}
	
	/*
	Takes in a position object (location of the click)
	Returns an object with information about what is at that position
	{type: null} if nothing found
	*/
	function checkClickLocation(position) {
	    var element = {};
	    // Loops through activeMonsters
	    for (var i = 0; i < game.activeMonsters.length; i++) {
	        if (comparePositions(position, game.activeMonsters[i].position, "monster")) {
	            element.type = "monster";
	            element.id = game.activeMonsters[i].id;
	            element.index = i;
	            break;
	        }
	    }
	
	    // If nothing was found, loop through towers
	    if (element.type === undefined) {
	        for (var i = 0; i < game.towers.length; i++) {
	            if (comparePositions(position, game.towers[i].position, "tower")) {
	                element.type = "tower";
	                element.id = game.towers[i].id;
	                element.index = i;
	                break;
	            }
	        }
	    }
	
	    // If no towers or monsters found return a type of null
	    if (element.type === undefined) {
	        element.type = null;
	    }
	
	    return element;
	}
	
	/* Click event listener on the tower cards
	Used to control what tower is being actively placed on the canvas
	4 possible flows based on the state of the interface
	1) The tower that was clicked is currently disabled:
	    -> function returns
	2) No towers are actively being placed
	    -> the clicked tower card now becomes the active tower being placed
	3) The clicked tower is the same as the tower actively being placed
	    -> the state is reset so that no towers are actively being placed
	4) The clicked tower is different from the tower actively being placed
	    -> the state is changed to the clicked tower becoming the active tower
	*/
	function towerCardClick() {
	
	    var towerName = this.getAttribute("data-tower"),
	        oldTowerIndex = getTowerCardIndex(activeTowerSelected),
	        newTowerIndex = getTowerCardIndex(towerName);
	
	    if (/disabled/i.test(this.className)) {
	        return;
	
	    } else if (activeTowerSelected === null) {
	        activeTowerSelected = towerName;
	        addClass(towerCards[newTowerIndex], "active");
	
	    } else if (activeTowerSelected === towerName) {
	        cancelTowerPlacement();
	
	    } else {
	        removeClass(towerCards[oldTowerIndex], "active");
	        activeTowerSelected = towerName;
	        addClass(towerCards[newTowerIndex], "active");
	    }
	}
	
	/*
	Called from towerCardClick (when clicking the active tower card) and on an escape key press
	Resets the active tower placement state to null
	*/
	function cancelTowerPlacement() {
	    removeClass(towerCards[getTowerCardIndex(activeTowerSelected)], "active");
	    activeTowerSelected = null;
	}
	
	/* Mouse move event listener on the canvas
	STILL TODO TODO
	If the active tower selected state (a tower is being placed by the user):
	    -> the tower is rendered at the mouse position (slightly opacitied)
	otherwise:
	    -> do nothing
	*/
	function onCanvasMouseMovement(e) {
	    if (activeTowerSelected === null) {
	        return
	    };
	
	    var canvasContainer = this.getBoundingClientRect(),
	        offsetX = e.clientX - canvasContainer.left,
	        offsetY = e.clientY - canvasContainer.top;
	    // send to display to get rendered
	};
	
	
	/* Click event listener on the canvas
	Handles two possible canvas click scenarios
	1) A tower is selected and is actively being placed
	    -> Clicking will validate the tower placement and check the user's gold
	    if both are valid, will tower will be placed (by game object)
	    otherwise, an error message will show up
	2) A tower is not selected and is not being placed
	    -> Will check whether the click position overlaps with the bounding
	    rectangle of monster or tower - if so, it will return the information
	    in the information container
	*/
	function canvasClick(e) {
	    // Get click location relative to the canvas element
	    var canvasContainer = this.getBoundingClientRect(),
	    position = {};
	
	    position.x = e.clientX - canvasContainer.left;
	    position.y = e.clientY - canvasContainer.top;
	
	    // Runs if the user is placing a tower
	    if (activeTowerSelected !== null) { //
	        var towerName = activeTowerSelected;
	
	        // Validate tower placement
	        if (game.validateTowerPlacement(position)
	        && game.checkGold(towerData[towerName].goldCost)) {
	
	            game.addTower(position, towerName);
	
	        } else {
	
	            if (!game.validateTowerPlacement(position)) {
	                activeErrorMessage = {
	                    message: "Invalid Tower Placement",
	                    timer: 50 // frames
	                }
	            } else {
	                activeErrorMessage = {
	                    message: "Not Enough Gold",
	                    timer: 50 // frames
	                }
	            }
	        }
	
	        removeClass(towerCards[getTowerCardIndex(activeTowerSelected)], "active");
	        activeTowerSelected = null;
	
	    } else {
	        // User is not running a tower placement
	        activeCanvasElement = checkClickLocation(position);
	    }
	
	}


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var towerData = __webpack_require__(5);
	// Position refers to the upper left corner of the elements
	// Tower width - 50 x 50
	var Tower = function(position, id) {
	    if (towerData[id] === undefined) {
	        throw Error("Invalid tower name, check html dataattribute or towerdata")
	    }
	    this.id = id;
	    this.damage = towerData[id].damage;
	    this.speed = towerData[id].speed; // Attack speed
	    this.range = towerData[id].range; // Range of the tower
	    this.type = towerData[id].type; // Type of damage
	    this.effect = towerData[id].effect; // Special effect (e.g. slow, splash, etc)
	    this.goldCost = towerData[id].goldCost;
	    this.position = position; // object with x and y coordinates - should not change
	}
	// Method the game object uses to run towers
	Tower.prototype.runCycle = function() {
	
	}
	// change this to reference a list or something where a name can be used to determine the properties
	// Takes in a monster's position and checks whether that is in range based on the range - returns true or false if in range which can be used to
	Tower.prototype.checkInRange = function(monsterPosition) {
	    // using sqrt((x2-x1)^2 - (y2-y1)^2)
	    var monsterDistance =
	    Math.sqrt(
	        Math.Pow(monsterPosition.x-this.position.x)
	    -   Math.Pow(monsterPosition.y-this.position.y)
	   );
	
	   if (monsterDistance <= this.range) {
	       return true;
	   } else {
	       return false;
	   }
	}
	
	Tower.prototype.draw = function() {
	    dynamicContext.fillStyle = "green";
	    dynamicContext.fillRect(this.position.x,
	                            this.position.y,
	                            50,
	                            50);
	}
	
	module.exports = Tower;


/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = {
	    basic: {
	        damage: 10,
	        speed: 10,
	        range: 100,
	        goldCost: 10,
	        type: "basic",
	        effect: "none"
	    }
	};


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	//  require Monster to gain access
	var Monster = __webpack_require__(7),
	    Tower = __webpack_require__(4);
	
	var GameEngine = function() {
	    this.userGold = 10;
	    this.level = 1;
	    this.userLives = 30;
	    this.activeMonsters = []; // List of active monsters in the
	    this.towers = []; // object of tower objects
	    this.timer = 1;
	    // Goes through and disables towers that can't be used yet
	}
	
	GameEngine.prototype.addMonster = function(name) {
	    // add monster (specified by name) to game
	    var monster = new Monster("monster1");
	    this.activeMonsters.push(monster);
	}
	
	GameEngine.prototype.addTower = function(position, id) {
	    // Check gold cost and then reduce gold
	    var tower = new Tower(position, id);
	    this.towers.push(tower);
	
	}
	
	// method to check gold before place tower or upgrade
	GameEngine.prototype.checkGold = function(goldCost) {
	    if (goldCost > this.userGold) {
	        return true;
	    } else {
	        return false;
	    }
	};
	
	GameEngine.prototype.gameOver = function() {
	
	}
	
	GameEngine.prototype.gameWon = function() {
	
	}
	
	// New level method
	GameEngine.prototype.nextLevel = function() {
	
	}
	
	GameEngine.prototype.render = function() {
	    // send state to the display object to render
	    dynamicContext.beginPath();
	    dynamicContext.clearRect(0, 0, dynamicCanvas.width, dynamicCanvas.height);
	
	    // Render towers first so that if monsters are larger they show above towers
	    for (var i = 0, j = this.towers.length; i < j; i ++) {
	        this.towers[i].draw();
	    }
	
	    //  loop through list of active monsters and render them
	    //  TODO probably need to find a better way to rend them apart from random rectangle
	    for (var i = 0, j = this.activeMonsters.length; i < j; i ++) {
	        this.activeMonsters[i].draw();
	    }
	
	
	
	    // dynamicContext.
	};
	
	GameEngine.prototype.runCycle = function() {
	    //  beginning of cycle check if any monsters have died if so remove from active monsters
	    this.checkMonsterDeath();
	    // loop through active monsters and towers and run the cycle
	    // Each runCycle method returns information for the gameEngine to
	    // process (e.g. the monster died, tower changed)
	
	    //  timer to add monsters
	    this.timer--;
	    if (this.timer < 1) {
	        this.addMonster('blah');
	        this.timer = 10;
	    }
	    for (var i = 0, j = this.activeMonsters.length; i < j; i ++) {
	        this.activeMonsters[i].move();
	    }
	    // Send information to render
	}
	
	// method to upgrade tower
	
	// 50 x 50 tower
	GameEngine.prototype.validateTowerPlacement = function(position) {
	    var positionValid = false;
	    // returns true or false whether tower placement is valid
	    return positionValid;
	}
	
	GameEngine.prototype.checkMonsterDeath = function() {
	    for (var i = 0, j = this.activeMonsters.length; i < j; i ++) {
	        if (this.activeMonsters[i].checkDeath()) {
	            this.activeMonsters.splice(i, 1);
	            i--;
	            j--;
	        }
	    }
	}
	
	// redraw canvas
	
	module.exports = GameEngine;


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var monsterData = __webpack_require__(8);
	
	var Monster = function(id) {
	    this.id = id;
	    this.currentHp = monsterData[id].maxHp;
	    this.maxHp = monsterData[id].maxHp;
	    this.baseMs = monsterData[id].baseMs; // Movement speed - "units" per second
	    this.type = monsterData[id].type;
	    this.position = { // All monsters are created in the same position
	        x: 0,
	        y: 485
	    }
	};
	// Method the game object uses to move monsters
	Monster.prototype.runCycle = function() {
	
	}
	
	Monster.prototype.draw = function() {
	    dynamicContext.beginPath();
	    dynamicContext.rect(this.position.x, this.position.y, 30, 30);
	    dynamicContext.stroke();
	    dynamicContext.fillStyle = "red";
	    dynamicContext.fillRect(this.position.x,
	                            this.position.y + 30/3,
	                            30 * this.currentHp/this.maxHp,
	                            30/3);
	}
	
	Monster.prototype.destroy = function() {
	
	};
	
	Monster.prototype.checkDeath = function() {
	    return this.currentHp <= 0;
	};
	
	// Expects up, down, left or right
	Monster.prototype.move = function(direction) {
	    var speed = this.baseMs;
	
	    // some basic monster Movement
	    //  NOTE such a hassle to figure this out
	    //  TODO not finished, not even going to try and finish will figure out how this should work later
	    if (this.position.x <= 50 && this.position.y < 500) {
	        this.position.x += speed;
	    } else if (this.position.x >= 50 && this.position.y >= 90) {
	        this.position.y -= speed;
	    } else if (this.position.x <= 180 && this.position.y >= 80) {
	        this.position.x += speed;
	    }
	
	    //  may not be the best way to do this but ill keep it because not even sure how to do this movement part
	    // if (typeof direction !== "string") {
	    //     throw new TypeError("direction is not a string");
	    // }
	    // direction = direction.toLowerCase();
	    // switch (direction) {
	    //     case "up":
	    //     case "down":
	    //     case "left":
	    //     case "right":
	    //     default:
	    //         throw new Error("Invalid direction");
	    // }
	};
	
	// Can take in a positive or negative number
	Monster.prototype.updateHp = function(hpChange) {
	    this.currentHp += hpChange;
	
	    if (this.currentHp > this.maxHp) {
	        this.currentHp = this.maxHp;
	    }
	};
	
	module.exports = Monster;


/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = {
	    monster1: {
	        maxHp: 30,
	        baseMs: 10,
	        type: 1 // Change this type later
	    }
	};


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNDEwNmM3ZjExNTE1NDhlNmYyYWQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2VudHJ5LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9iYWNrZ3JvdW5kLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NsYXNzZXMvVG93ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2dhbWVEYXRhL3Rvd2VyZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY2xhc3Nlcy9HYW1lLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9jbGFzc2VzL01vbnN0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2dhbWVEYXRhL21vbnN0ZXJkYXRhLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0Esb0NBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDM0RBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBMkIsV0FBVztBQUN0QztBQUNBLDJCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0EsaUJBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFrQyxlQUFlO0FBQ2pELFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQyxXQUFXO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQSxNQUFLO0FBQ0w7O0FBRUEsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxVQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2hYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUM7QUFDckMsc0NBQXFDO0FBQ3JDLG9DQUFtQztBQUNuQyx3Q0FBdUM7QUFDdkM7QUFDQSw4QkFBNkI7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDVEE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFtRCxPQUFPO0FBQzFEO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQzlHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUF5QztBQUN6QztBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoibWFpbi5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvc3JjL2pzL1wiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgNDEwNmM3ZjExNTE1NDhlNmYyYWRcbiAqKi8iLCIvLyBDYW52YXNcbnJlcXVpcmUoXCIuL2JhY2tncm91bmQuanNcIik7XG5cbi8vIFVzZXIgaW50ZXJhY3Rpb24gZWxlbWVudHNcbnJlcXVpcmUoXCIuL2ludGVyZmFjZS5qc1wiKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvZW50cnkuanNcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBiYWNrZ3JvdW5kIGNvbnRhaW5zIHRoZSBzdGF0aWMgY2FudmFzIGVsZW1lbnRzXG52YXIgYmFja2dyb3VuZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RhdGljXCIpO1xudmFyIGJhY2tncm91bmRDb250ZXh0ID0gYmFja2dyb3VuZC5nZXRDb250ZXh0KFwiMmRcIik7XG5cbi8vIFNldHRpbmdzIGZvciB0aGUgYmFja2dyb3VuZCAtIG1vdmUgb3V0IHRvIGEgc2VwYXJhdGUgZmlsZVxudmFyIHNldHRpbmdzID0ge1xuICAgIGJhY2tncm91bmRDb2xvcjogXCIjOENEMUU2XCIsXG4gICAgcGF0aENvbG9yOiBcImdyYXlcIlxufVxuXG4vLyBEcmF3aW5nIHRoZSBiYWNrZ3JvdW5kXG5iYWNrZ3JvdW5kQ29udGV4dC5maWxsU3R5bGUgPSBzZXR0aW5ncy5iYWNrZ3JvdW5kQ29sb3I7XG5iYWNrZ3JvdW5kQ29udGV4dC5maWxsUmVjdCgwLCAwLCBiYWNrZ3JvdW5kLndpZHRoLCBiYWNrZ3JvdW5kLmhlaWdodCk7XG5cbi8qIE1haW4gcGF0aCB3aWxsIGdvIGZyb20gWzAsIDUwMF0sIFs3NSwgNTAwXSwgWzc1LCAxMDBdLCBbMjI1LCAxMDBdLCBbMjI1LCA1MDBdLCBbMzc1LCA1MDBdLCBbMzc1LCAxMDBdLCBbNTI1LCAxMDBdLCBbNTI1LCA1MDBdLCBbNjc1LCA1MDBdLCBbNjc1LCAxMDBdLCBbODI1LCAxMDBdLCBbODI1LCA1MDBdLCBbOTAwLCA1MDBdICovXG5cbi8vIERyYXdpbmcgdGhlIHBhdGggLSB3aWR0aCBvZiB0aGUgcGF0aCBpcyA1MHB4XG5iYWNrZ3JvdW5kQ29udGV4dC5maWxsU3R5bGUgPSBzZXR0aW5ncy5wYXRoQ29sb3I7XG5cbmJhY2tncm91bmRDb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4vLyBGb3IgdGhlIGJvdHRvbSBwYXJ0IG9mIHRoZSBwYXRoXG5iYWNrZ3JvdW5kQ29udGV4dC5tb3ZlVG8oMCwgNTI1KTtcblxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDEwMCwgNTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygxMDAsIDEyNSk7IC8vIFRvcFxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDIwMCwgMTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygyMDAsIDUyNSk7IC8vIEJvdHRvbVxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDQwMCwgNTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg0MDAsIDEyNSk7IC8vIFRvcFxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDUwMCwgMTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg1MDAsIDUyNSk7IC8vIEJvdHRvbVxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDcwMCwgNTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg3MDAsIDEyNSk7IC8vIFRvcFxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDgwMCwgMTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg4MDAsIDUyNSk7IC8vIEJvdHRvbVxuXG4vL01pZGRsZSBzZWN0aW9uIHRvIHRoZSBzaWRlXG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oOTAwLCA1MjUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDkwMCwgNDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg4NTAsIDQ3NSk7XG5cbi8vIEZvciB0aGUgdG9wIHBhcnQgb2YgdGhlIHBhdGhcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg4NTAsIDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg2NTAsIDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg2NTAsIDQ3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNTUwLCA0NzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDU1MCwgNzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDM1MCwgNzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDM1MCwgNDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygyNTAsIDQ3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oMjUwLCA3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNTAsIDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg1MCwgNDc1KTtcblxuLy8gRW5kIHNlY3Rpb25cbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygwLCA0NzUpO1xuXG5iYWNrZ3JvdW5kQ29udGV4dC5maWxsKCk7XG4vLyBiYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvYmFja2dyb3VuZC5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIE5PVEUgQXQgc29tZSBwb2ludCBJIHRoaW5rIHdlIGNhbiBtb3ZlIHNvbWUgZnVuY3Rpb25zIGludG8gYSBkaWZmZXJlbnQgZmlsZVxuXG4vLyBJbml0aWF0ZSBhbGwgdGhlIGNvbXBvbmVudHNcbnZhciBUb3dlciA9IHJlcXVpcmUoXCIuL2NsYXNzZXMvVG93ZXIuanNcIiksXG4gICAgR2FtZUVuZ2luZSA9IHJlcXVpcmUoXCIuL2NsYXNzZXMvR2FtZS5qc1wiKSxcbiAgICBtb25zdGVyRGF0YSA9IHJlcXVpcmUoXCIuL2dhbWVEYXRhL21vbnN0ZXJkYXRhLmpzXCIpLFxuICAgIHRvd2VyRGF0YSA9IHJlcXVpcmUoXCIuL2dhbWVEYXRhL3Rvd2VyZGF0YS5qc1wiKTtcblxuLy8gQ2FjaGUgcmV1c2VkIERPTSBlbGVtZW50c1xudmFyIGluZm9OYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbmZvLW5hbWVcIiksXG4gICAgaW5mb0ljb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImluZm8taWNvblwiKSxcbiAgICBpbmZvQm94MSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5mby1ib3gtMVwiKSxcbiAgICBpbmZvQm94MiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5mby1ib3gtMlwiKSxcbiAgICBpbmZvQm94MyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5mby1ib3gtM1wiKSxcbiAgICBpbmZvQm94NCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5mby1ib3gtNFwiKSxcbiAgICBsZXZlbEluZm8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxldmVsXCIpLFxuICAgIGdvbGRJbmZvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJnb2xkXCIpLFxuICAgIGxpdmVzSW5mbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibGl2ZXNcIik7XG5cbnZhciB0b3dlckNhcmRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcInRvd2VyLWNhcmRcIiksXG4gICAgdG93ZXJDYXJkTGlzdCA9IFtdO1xuLy8gQ29udmVydCBmcm9tIG5vZGVsaXN0IHRvIGFycmF5XG50b3dlckNhcmRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodG93ZXJDYXJkcyk7XG5cbi8vIGNyZWF0ZSBzdGF0ZSB2YXJpYWJsZXNcbnZhciBhY3RpdmVDYW52YXNFbGVtZW50ID0ge3R5cGU6IG51bGx9LCAvLyBpbml0aWF0ZSBkZWZhdWx0IGFzIG51bGwgLSB1cGRhdGUgdGhpcyB2YXJpYWJsZSB3aGVuIG1vbnN0ZXIvdG93ZXIgY2hhbmdlc1xuICAgIGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPSBudWxsLFxuICAgIGFjdGl2ZUVycm9yTWVzc2FnZSA9IHttZXNzYWdlOiBudWxsfTtcblxuLy8gIGNyZWF0ZXMgZ2xvYmFsIHZhcmlhYmxlc1xuZ2FtZSA9IG5ldyBHYW1lRW5naW5lO1xuZHluYW1pY0NhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkeW5hbWljJyk7XG5keW5hbWljQ29udGV4dCA9IGR5bmFtaWNDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxucnVuQ3ljbGUgPSBmdW5jdGlvbigpIHtcbiAgICBnYW1lLnJ1bkN5Y2xlKCk7XG4gICAgc2V0VGltZW91dChydW5DeWNsZSwgMTAwMCk7XG59XG5cbnJlbmRlckN5Y2xlID0gZnVuY3Rpb24oKSB7XG4gICAgZ2FtZS5yZW5kZXIoKTtcbiAgICAvLyBSZW5kZXJzIHRoZSBpbmZvcm1hdGlvbiBhbmQgZXJyb3IgbWVzc2FnZXMgYmFzZWQgb24gdGhlIHN0YXRlIHZhcmlhYmxlc1xuICAgIHJlbmRlckVycm9yTWVzc2FnZSgpO1xuICAgIHJlbmRlckluZm9ybWF0aW9uQ29udGFpbmVyKCk7XG4gICAgcmVuZGVySFVEKCk7XG4gICAgcmVuZGVyVG93ZXJQbGFjZW1lbnQoKTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyQ3ljbGUpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT0gSGVscGVyIGZ1bmN0aW9ucyA9PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5mdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCBjc3NDbGFzcykge1xuICAgIGlmIChlbGVtZW50LmNsYXNzTmFtZSA9PT0gXCJcIikge1xuICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNzc0NsYXNzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lICs9IFwiIFwiICsgY3NzQ2xhc3M7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCBjc3NDbGFzcykge1xuICAgIHZhciBhcnJheU9mQ2xhc3NlcyA9IGVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KFwiIFwiKTtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IGFycmF5T2ZDbGFzc2VzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgICBpZiAoYXJyYXlPZkNsYXNzZXNbaV0gPT09IGNzc0NsYXNzKSB7XG4gICAgICAgICAgICBhcnJheU9mQ2xhc3Nlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBpLS07IGotLTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGFycmF5T2ZDbGFzc2VzLmpvaW4oXCIgXCIpO1xufVxuXG4vLyBHZXRzIHRoZSBpbmRleCBvZiB0aGUgdG93ZXIgY2FyZHMgYmFzZWQgb24gYSB0b3dlcidzIG5hbWVcbmZ1bmN0aW9uIGdldFRvd2VyQ2FyZEluZGV4KHRvd2VyTmFtZSkge1xuICAgIHJldHVybiB0b3dlckNhcmRMaXN0LmluZGV4T2YodG93ZXJOYW1lKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09IFJlbmRlciBmdW5jdGlvbnMgPT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLy8gUmVuZGVyIGZ1bmN0aW9ucyBydW4gZXZlcnkgZ2FtZSBjeWNsZSAob24gdGhlIHJlbmRlckN5Y2xlIGZ1bmN0aW9uIGNhbGwpXG4vLyBSZW5kZXJzIGJhc2VkIG9uIHRoZSBzdGF0ZSB2YXJpYWJsZXNcblxuZnVuY3Rpb24gcmVuZGVySW5mb3JtYXRpb25Db250YWluZXIoKSB7XG4gICAgaWYgKGFjdGl2ZUNhbnZhc0VsZW1lbnQudHlwZSA9PT0gXCJtb25zdGVyXCIpIHtcbiAgICAgICAgcmVuZGVyTW9uc3RlckluZm9ybWF0aW9uKGFjdGl2ZUNhbnZhc0VsZW1lbnQuaWQsIGFjdGl2ZUNhbnZhc0VsZW1lbnQuaW5kZXgpO1xuICAgIH0gZWxzZSBpZiAoYWN0aXZlQ2FudmFzRWxlbWVudC50eXBlID09PSBcInRvd2VyXCIpIHtcbiAgICAgICAgcmVuZGVyVG93ZXJJbmZvcm1hdGlvbihhY3RpdmVDYW52YXNFbGVtZW50LmlkLCBhY3RpdmVDYW52YXNFbGVtZW50LmluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZW5kZXJEZWZhdWx0SW5mb3JtYXRpb24oKTtcbiAgICB9XG59XG5cbi8vIElEIHJlZmVycyB0byB0aGUgdHlwZSBvZiBtb25zdGVyIGFuZCBpbmRleCBpcyB0aGUgaW5kZXggb2YgdGhlIGFjdGl2ZSBtb25zdGVyIGluIHRoZSBhY3RpdmUgbW9uc3RlcidzIGFycmF5XG5mdW5jdGlvbiByZW5kZXJNb25zdGVySW5mb3JtYXRpb24oaWQsIGluZGV4KSB7XG4gICAgdmFyIGN1cnJlbnRIcCA9IGdhbWUuYWN0aXZlTW9uc3RlcnNbaW5kZXhdLmN1cnJlbnRIcCxcbiAgICAgICAgbWF4SHAgPSBnYW1lLmFjdGl2ZU1vbnN0ZXJzW2luZGV4XS5tYXhIcCxcbiAgICAgICAgdHlwZSA9IGdhbWUuYWN0aXZlTW9uc3RlcnNbaW5kZXhdLnR5cGU7XG4gICAgaW5mb05hbWUuaW5uZXJIVE1MID0gaWQ7XG4gICAgLy8gQ2hhbmdlIGljb24gdG8gYWN0aXZlIG1vbnN0ZXIgLSB1c2UgYSBzcHJpdGVcbiAgICBpbmZvQm94MS5pbm5lckhUTUwgPSBcIkhQOiBcIiArIGN1cnJlbnRIcCArIFwiIC8gXCIgKyBtYXhIcDtcbiAgICBpbmZvQm94Mi5pbm5lckhUTUwgPSBcIlR5cGU6IFwiICsgdHlwZTtcbiAgICBpbmZvQm94My5pbm5lckhUTUwgPSBcIlN0cmVuZ3RoczogQWxsIHNvcnRzIG1hdGVcIiA7XG4gICAgaW5mb0JveDQuaW5uZXJIVE1MID0gXCJXZWFrbmVzc2VzOiBEdWNrc1wiIDtcbn1cblxuLy8gSUQgcmVmZXJzIHRvIHRoZSB0eXBlIG9mIHRvd2VyIGFuZCBpbmRleCBpcyB0aGUgaW5kZXggb2YgdGhlIGFjdGl2ZSB0b3dlciBpbiB0aGUgYWN0aXZlIHRvd2VyJ3MgYXJyYXlcbmZ1bmN0aW9uIHJlbmRlclRvd2VySW5mb3JtYXRpb24oaWQsIGluZGV4KSB7XG4gICAgaW5mb05hbWUuaW5uZXJIVE1MID0gaWQ7XG4gICAgLy8gQ2hhbmdlIGljb24gdG8gYWN0aXZlIG1vbnN0ZXIgLSB1c2UgYSBzcHJpdGVcbiAgICBpbmZvQm94MS5pbm5lckhUTUwgPSBcIkRhbWFnZTogPGJyPiBSYW5nZTogPGJyPiBFZmZlY3Q6IFwiO1xuICAgIGluZm9Cb3gyLmlubmVySFRNTCA9IFwiQXR0YWNrIFNwZWVkOiA8YnI+IFR5cGU6IFwiIDtcbiAgICBpbmZvQm94My5pbm5lckhUTUwgPSBcIjxhIGNsYXNzPSd3YXZlcy1lZmZlY3Qgd2F2ZXMtbGlnaHQgYnRuIHJlZCc+VXBncmFkZTwvYT5cIiA7XG4gICAgaW5mb0JveDQuaW5uZXJIVE1MID0gXCI8YSBjbGFzcz0nd2F2ZXMtZWZmZWN0IHdhdmVzLWxpZ2h0IGJ0biByZWQnPlNlbGw8L2E+XCIgO1xuICAgIC8vIENoYW5nZSBpY29uIHRvIHRvd2VyIG1vbnN0ZXIgLSB1c2UgYSBzcHJpdGVcblxufVxuXG5mdW5jdGlvbiByZW5kZXJEZWZhdWx0SW5mb3JtYXRpb24oKSB7XG4gICAgaW5mb05hbWUuaW5uZXJIVE1MID0gXCJBd2Vzb21lIFREXCI7XG4gICAgLy8gQ2hhbmdlIGljb24gdG8gZGVmYXVsdCBpbWFnZSAtIHVzZSBhIHNwcml0ZVxuICAgIGluZm9Cb3gxLmlubmVySFRNTCA9IFwiVGhpcyBpcyBzb21lIHRleHRcIjtcbiAgICBpbmZvQm94Mi5pbm5lckhUTUwgPSBcIlRoaXMgaXMgZGlmZmVyZW50IHRleHRcIjtcbiAgICBpbmZvQm94My5pbm5lckhUTUwgPSBcIlRoaXMgaXMgPz8/IHRleHRcIiA7XG4gICAgaW5mb0JveDQuaW5uZXJIVE1MID0gXCJUaGlzIDEyMzEyNDEyMzVcIiA7XG59XG5cbi8vIE1heWJlIGNoYW5nZSB0aGlzIHRvIFwicmVuZGVyTWVzc2FnZVwiXG5mdW5jdGlvbiByZW5kZXJFcnJvck1lc3NhZ2UoKSB7XG4gICAgaWYgKGFjdGl2ZUVycm9yTWVzc2FnZS5tZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkeW5hbWljQ29udGV4dC5nbG9iYWxBbHBoYSA9IGFjdGl2ZUVycm9yTWVzc2FnZS50aW1lciAvIDUwO1xuICAgICAgICBkeW5hbWljQ29udGV4dC5mb250ID0gJzQwcHQgRHJvaWQgU2Fucyc7XG4gICAgICAgIGR5bmFtaWNDb250ZXh0LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIGR5bmFtaWNDb250ZXh0LmZpbGxTdHlsZSA9IFwicmVkXCI7XG4gICAgICAgIGR5bmFtaWNDb250ZXh0LmZpbGxUZXh0KGFjdGl2ZUVycm9yTWVzc2FnZS5tZXNzYWdlLCA0NTAsIDUwKTtcbiAgICAgICAgZHluYW1pY0NvbnRleHQuZ2xvYmFsQWxwaGEgPSAxO1xuXG4gICAgICAgIGlmIChhY3RpdmVFcnJvck1lc3NhZ2UudGltZXIgPT09IDApIHtcbiAgICAgICAgICAgIGFjdGl2ZUVycm9yTWVzc2FnZSA9IHttZXNzYWdlOiBudWxsfTsgLy8gUmVzZXQgZXJyb3IgbWVzc2FnZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWN0aXZlRXJyb3JNZXNzYWdlLnRpbWVyLS07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlclRvd2VyUGxhY2VtZW50KCkge1xuICAgIGlmIChhY3RpdmVUb3dlclNlbGVjdGVkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVyblxuICAgIH07XG4gICAgLy8gRUxTRSByZW5kZXIgdGhlIHRvd2VyIG9uIHRoZSBjYW52YXNcbiAgICAvLyBkbyBzb21lIHNvcnQgb2YgbG9naWMgdG8gaGlnaGxpZ2h0IHRoZSB0aWxlcyB0aGF0IHRoZSB0b3dlciB3b3VsZCBiZSBwbGFjZWQgb24gYW5kIHNob3cgdGhlIHRvd2VyIG9uIHRob3NlIHBvc2l0aW9uc1xufVxuXG5cbmZ1bmN0aW9uIHJlbmRlckhVRCgpIHtcbiAgICBsaXZlc0luZm8uaW5uZXJIVE1MID0gZ2FtZS51c2VyTGl2ZXM7XG4gICAgZ29sZEluZm8uaW5uZXJIVE1MID0gZ2FtZS51c2VyR29sZDtcbiAgICBsZXZlbEluZm8uaW5uZXJIVE1MID0gZ2FtZS5sZXZlbDtcbn1cbi8qID09PT09PT09PT09PT09PT0gVUkgRXZlbnQgTGlzdGVuZXJzID09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RhcnQtYnRuXCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAvLyBIaWRlcyB0aGUgbW9kYWwgbGlnaHRib3hcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwibW9kYWwtY29udGVudFwiKVswXS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIm1vZGFsLWJhY2tncm91bmRcIilbMF0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXG4gICAgLy8gcnVuIHJlcGVhdGluZyBmdW5jdGlvbiB0aGF0IHJ1bnMgZ2FtZSBlbmdpbmUgcnVuIGN5Y2xlIGFuZCByZW5kZXJpbmdcbiAgICBzZXRUaW1lb3V0KHJ1bkN5Y2xlLCAxMDAwKTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyQ3ljbGUpO1xufSk7XG5cbi8vIE9uIGNsaWNraW5nIHRoZSBpbmZvcm1hdGlvbiBidXR0b24sIHNob3cgdGhlIGluZm9ybWF0aW9uIHBhbmVsXG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImluZm9ybWF0aW9uLWJ0blwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgLy8gVE9ETyAtIGFkZCBpbmZvcm1hdGlvbiBtb2RhbCBpbmZvcm1hdGlvbiB0aGluZ3lcbiAgICBjb25zb2xlLmxvZyhcInNob3cgaW5mb3JtYXRpb24gY29udGFpbmVyIGhlcmVcIik7XG59KTtcblxuLypcblRoZXNlIGV2ZW50IGxpc3RlbmVycyBjb250cm9sIHRoZSBhcHBsaWNhdGlvbiBieSBpbnRlcmFjdGluZyB3aXRoIHRoZSBnYW1lXG5vYmplY3QgYW5kIGJ5IGNoYW5naW5nIHRoZSBzdGF0ZSB2YXJpYWJsZXMgKHdoaWNoIHRoZSByZW5kZXIgZnVuY3Rpb25zIHVzZVxudG8gcmVhZClcbiovXG50b3dlckNhcmRzLm1hcChmdW5jdGlvbih0b3dlckNhcmQsIGkpIHtcbiAgICB0b3dlckNhcmRMaXN0LnB1c2godG93ZXJDYXJkLmdldEF0dHJpYnV0ZShcImRhdGEtdG93ZXJcIikpO1xuICAgIHRvd2VyQ2FyZC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdG93ZXJDYXJkQ2xpY2spO1xufSk7XG5cbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZHluYW1pY1wiKS5vbm1vdXNlbW92ZSA9IG9uQ2FudmFzTW91c2VNb3ZlbWVudDtcbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZHluYW1pY1wiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgY2FudmFzQ2xpY2spO1xuXG5kb2N1bWVudC5vbmtleWRvd24gPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgICAgY2FuY2VsVG93ZXJQbGFjZW1lbnQoKTtcbiAgICB9XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT0gVUkgRnVuY3Rpb25zID09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qXG5UYWtlcyBpbiB0aHJlZSBhcmd1bWVudHMgLSBsb2NhdGlvbiBvZiB0aGUgY2xpY2ssIGxvY2F0aW9uIG9mIGFuIGVsZW1lbnRcbihpLmUuIG1vbnN0ZXIgb3IgdG93ZXIpIGFuZCB0aGUgdHlwZSAod2hldGhlciBpdCBpcyBhIG1vbnN0ZXIgb3IgYSB0b3dlciAtXG5kaWZmZXJlbnQgZGltZW5zaW9ucylcblJldHVybnMgYSBib29sZWFuIC0gdHJ1ZSBpZiB0aGUgY2xpY2sgb3ZlcmxhcHMgd2l0aCBhbiBlbGVtZW50IGFuZCBmYWxzZVxuaWYgaXQgZG9lcyBub3RcbiovXG5mdW5jdGlvbiBjb21wYXJlUG9zaXRpb25zKGNsaWNrUG9zaXRpb24sIGVsZW1lbnRQb3NpdGlvbiwgdHlwZSkge1xuICAgIHZhciBzaWRlTGVuZ3RoID0gdHlwZSA9PT0gXCJtb25zdGVyXCIgPyAzMCA6IDUwOyAvLyB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBlbGVtZW50XG4gICAgaWYgKGNsaWNrUG9zaXRpb24ueCA+PSBlbGVtZW50UG9zaXRpb24ueFxuICAgICYmIGNsaWNrUG9zaXRpb24ueCA8PSBlbGVtZW50UG9zaXRpb24ueCArIHNpZGVMZW5ndGhcbiAgICAmJiBjbGlja1Bvc2l0aW9uLnkgPj0gZWxlbWVudFBvc2l0aW9uLnlcbiAgICAmJiBjbGlja1Bvc2l0aW9uLnkgPD0gZWxlbWVudFBvc2l0aW9uLnkgKyBzaWRlTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8qXG5UYWtlcyBpbiBhIHBvc2l0aW9uIG9iamVjdCAobG9jYXRpb24gb2YgdGhlIGNsaWNrKVxuUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGlzIGF0IHRoYXQgcG9zaXRpb25cbnt0eXBlOiBudWxsfSBpZiBub3RoaW5nIGZvdW5kXG4qL1xuZnVuY3Rpb24gY2hlY2tDbGlja0xvY2F0aW9uKHBvc2l0aW9uKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB7fTtcbiAgICAvLyBMb29wcyB0aHJvdWdoIGFjdGl2ZU1vbnN0ZXJzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnYW1lLmFjdGl2ZU1vbnN0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjb21wYXJlUG9zaXRpb25zKHBvc2l0aW9uLCBnYW1lLmFjdGl2ZU1vbnN0ZXJzW2ldLnBvc2l0aW9uLCBcIm1vbnN0ZXJcIikpIHtcbiAgICAgICAgICAgIGVsZW1lbnQudHlwZSA9IFwibW9uc3RlclwiO1xuICAgICAgICAgICAgZWxlbWVudC5pZCA9IGdhbWUuYWN0aXZlTW9uc3RlcnNbaV0uaWQ7XG4gICAgICAgICAgICBlbGVtZW50LmluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbm90aGluZyB3YXMgZm91bmQsIGxvb3AgdGhyb3VnaCB0b3dlcnNcbiAgICBpZiAoZWxlbWVudC50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnYW1lLnRvd2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvbXBhcmVQb3NpdGlvbnMocG9zaXRpb24sIGdhbWUudG93ZXJzW2ldLnBvc2l0aW9uLCBcInRvd2VyXCIpKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC50eXBlID0gXCJ0b3dlclwiO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuaWQgPSBnYW1lLnRvd2Vyc1tpXS5pZDtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vIHRvd2VycyBvciBtb25zdGVycyBmb3VuZCByZXR1cm4gYSB0eXBlIG9mIG51bGxcbiAgICBpZiAoZWxlbWVudC50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWxlbWVudC50eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbn1cblxuLyogQ2xpY2sgZXZlbnQgbGlzdGVuZXIgb24gdGhlIHRvd2VyIGNhcmRzXG5Vc2VkIHRvIGNvbnRyb2wgd2hhdCB0b3dlciBpcyBiZWluZyBhY3RpdmVseSBwbGFjZWQgb24gdGhlIGNhbnZhc1xuNCBwb3NzaWJsZSBmbG93cyBiYXNlZCBvbiB0aGUgc3RhdGUgb2YgdGhlIGludGVyZmFjZVxuMSkgVGhlIHRvd2VyIHRoYXQgd2FzIGNsaWNrZWQgaXMgY3VycmVudGx5IGRpc2FibGVkOlxuICAgIC0+IGZ1bmN0aW9uIHJldHVybnNcbjIpIE5vIHRvd2VycyBhcmUgYWN0aXZlbHkgYmVpbmcgcGxhY2VkXG4gICAgLT4gdGhlIGNsaWNrZWQgdG93ZXIgY2FyZCBub3cgYmVjb21lcyB0aGUgYWN0aXZlIHRvd2VyIGJlaW5nIHBsYWNlZFxuMykgVGhlIGNsaWNrZWQgdG93ZXIgaXMgdGhlIHNhbWUgYXMgdGhlIHRvd2VyIGFjdGl2ZWx5IGJlaW5nIHBsYWNlZFxuICAgIC0+IHRoZSBzdGF0ZSBpcyByZXNldCBzbyB0aGF0IG5vIHRvd2VycyBhcmUgYWN0aXZlbHkgYmVpbmcgcGxhY2VkXG40KSBUaGUgY2xpY2tlZCB0b3dlciBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgdG93ZXIgYWN0aXZlbHkgYmVpbmcgcGxhY2VkXG4gICAgLT4gdGhlIHN0YXRlIGlzIGNoYW5nZWQgdG8gdGhlIGNsaWNrZWQgdG93ZXIgYmVjb21pbmcgdGhlIGFjdGl2ZSB0b3dlclxuKi9cbmZ1bmN0aW9uIHRvd2VyQ2FyZENsaWNrKCkge1xuXG4gICAgdmFyIHRvd2VyTmFtZSA9IHRoaXMuZ2V0QXR0cmlidXRlKFwiZGF0YS10b3dlclwiKSxcbiAgICAgICAgb2xkVG93ZXJJbmRleCA9IGdldFRvd2VyQ2FyZEluZGV4KGFjdGl2ZVRvd2VyU2VsZWN0ZWQpLFxuICAgICAgICBuZXdUb3dlckluZGV4ID0gZ2V0VG93ZXJDYXJkSW5kZXgodG93ZXJOYW1lKTtcblxuICAgIGlmICgvZGlzYWJsZWQvaS50ZXN0KHRoaXMuY2xhc3NOYW1lKSkge1xuICAgICAgICByZXR1cm47XG5cbiAgICB9IGVsc2UgaWYgKGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPT09IG51bGwpIHtcbiAgICAgICAgYWN0aXZlVG93ZXJTZWxlY3RlZCA9IHRvd2VyTmFtZTtcbiAgICAgICAgYWRkQ2xhc3ModG93ZXJDYXJkc1tuZXdUb3dlckluZGV4XSwgXCJhY3RpdmVcIik7XG5cbiAgICB9IGVsc2UgaWYgKGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPT09IHRvd2VyTmFtZSkge1xuICAgICAgICBjYW5jZWxUb3dlclBsYWNlbWVudCgpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlQ2xhc3ModG93ZXJDYXJkc1tvbGRUb3dlckluZGV4XSwgXCJhY3RpdmVcIik7XG4gICAgICAgIGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPSB0b3dlck5hbWU7XG4gICAgICAgIGFkZENsYXNzKHRvd2VyQ2FyZHNbbmV3VG93ZXJJbmRleF0sIFwiYWN0aXZlXCIpO1xuICAgIH1cbn1cblxuLypcbkNhbGxlZCBmcm9tIHRvd2VyQ2FyZENsaWNrICh3aGVuIGNsaWNraW5nIHRoZSBhY3RpdmUgdG93ZXIgY2FyZCkgYW5kIG9uIGFuIGVzY2FwZSBrZXkgcHJlc3NcblJlc2V0cyB0aGUgYWN0aXZlIHRvd2VyIHBsYWNlbWVudCBzdGF0ZSB0byBudWxsXG4qL1xuZnVuY3Rpb24gY2FuY2VsVG93ZXJQbGFjZW1lbnQoKSB7XG4gICAgcmVtb3ZlQ2xhc3ModG93ZXJDYXJkc1tnZXRUb3dlckNhcmRJbmRleChhY3RpdmVUb3dlclNlbGVjdGVkKV0sIFwiYWN0aXZlXCIpO1xuICAgIGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPSBudWxsO1xufVxuXG4vKiBNb3VzZSBtb3ZlIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSBjYW52YXNcblNUSUxMIFRPRE8gVE9ET1xuSWYgdGhlIGFjdGl2ZSB0b3dlciBzZWxlY3RlZCBzdGF0ZSAoYSB0b3dlciBpcyBiZWluZyBwbGFjZWQgYnkgdGhlIHVzZXIpOlxuICAgIC0+IHRoZSB0b3dlciBpcyByZW5kZXJlZCBhdCB0aGUgbW91c2UgcG9zaXRpb24gKHNsaWdodGx5IG9wYWNpdGllZClcbm90aGVyd2lzZTpcbiAgICAtPiBkbyBub3RoaW5nXG4qL1xuZnVuY3Rpb24gb25DYW52YXNNb3VzZU1vdmVtZW50KGUpIHtcbiAgICBpZiAoYWN0aXZlVG93ZXJTZWxlY3RlZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm5cbiAgICB9O1xuXG4gICAgdmFyIGNhbnZhc0NvbnRhaW5lciA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIG9mZnNldFggPSBlLmNsaWVudFggLSBjYW52YXNDb250YWluZXIubGVmdCxcbiAgICAgICAgb2Zmc2V0WSA9IGUuY2xpZW50WSAtIGNhbnZhc0NvbnRhaW5lci50b3A7XG4gICAgLy8gc2VuZCB0byBkaXNwbGF5IHRvIGdldCByZW5kZXJlZFxufTtcblxuXG4vKiBDbGljayBldmVudCBsaXN0ZW5lciBvbiB0aGUgY2FudmFzXG5IYW5kbGVzIHR3byBwb3NzaWJsZSBjYW52YXMgY2xpY2sgc2NlbmFyaW9zXG4xKSBBIHRvd2VyIGlzIHNlbGVjdGVkIGFuZCBpcyBhY3RpdmVseSBiZWluZyBwbGFjZWRcbiAgICAtPiBDbGlja2luZyB3aWxsIHZhbGlkYXRlIHRoZSB0b3dlciBwbGFjZW1lbnQgYW5kIGNoZWNrIHRoZSB1c2VyJ3MgZ29sZFxuICAgIGlmIGJvdGggYXJlIHZhbGlkLCB3aWxsIHRvd2VyIHdpbGwgYmUgcGxhY2VkIChieSBnYW1lIG9iamVjdClcbiAgICBvdGhlcndpc2UsIGFuIGVycm9yIG1lc3NhZ2Ugd2lsbCBzaG93IHVwXG4yKSBBIHRvd2VyIGlzIG5vdCBzZWxlY3RlZCBhbmQgaXMgbm90IGJlaW5nIHBsYWNlZFxuICAgIC0+IFdpbGwgY2hlY2sgd2hldGhlciB0aGUgY2xpY2sgcG9zaXRpb24gb3ZlcmxhcHMgd2l0aCB0aGUgYm91bmRpbmdcbiAgICByZWN0YW5nbGUgb2YgbW9uc3RlciBvciB0b3dlciAtIGlmIHNvLCBpdCB3aWxsIHJldHVybiB0aGUgaW5mb3JtYXRpb25cbiAgICBpbiB0aGUgaW5mb3JtYXRpb24gY29udGFpbmVyXG4qL1xuZnVuY3Rpb24gY2FudmFzQ2xpY2soZSkge1xuICAgIC8vIEdldCBjbGljayBsb2NhdGlvbiByZWxhdGl2ZSB0byB0aGUgY2FudmFzIGVsZW1lbnRcbiAgICB2YXIgY2FudmFzQ29udGFpbmVyID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICBwb3NpdGlvbiA9IHt9O1xuXG4gICAgcG9zaXRpb24ueCA9IGUuY2xpZW50WCAtIGNhbnZhc0NvbnRhaW5lci5sZWZ0O1xuICAgIHBvc2l0aW9uLnkgPSBlLmNsaWVudFkgLSBjYW52YXNDb250YWluZXIudG9wO1xuXG4gICAgLy8gUnVucyBpZiB0aGUgdXNlciBpcyBwbGFjaW5nIGEgdG93ZXJcbiAgICBpZiAoYWN0aXZlVG93ZXJTZWxlY3RlZCAhPT0gbnVsbCkgeyAvL1xuICAgICAgICB2YXIgdG93ZXJOYW1lID0gYWN0aXZlVG93ZXJTZWxlY3RlZDtcblxuICAgICAgICAvLyBWYWxpZGF0ZSB0b3dlciBwbGFjZW1lbnRcbiAgICAgICAgaWYgKGdhbWUudmFsaWRhdGVUb3dlclBsYWNlbWVudChwb3NpdGlvbilcbiAgICAgICAgJiYgZ2FtZS5jaGVja0dvbGQodG93ZXJEYXRhW3Rvd2VyTmFtZV0uZ29sZENvc3QpKSB7XG5cbiAgICAgICAgICAgIGdhbWUuYWRkVG93ZXIocG9zaXRpb24sIHRvd2VyTmFtZSk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgaWYgKCFnYW1lLnZhbGlkYXRlVG93ZXJQbGFjZW1lbnQocG9zaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlRXJyb3JNZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQgVG93ZXIgUGxhY2VtZW50XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVyOiA1MCAvLyBmcmFtZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjdGl2ZUVycm9yTWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJOb3QgRW5vdWdoIEdvbGRcIixcbiAgICAgICAgICAgICAgICAgICAgdGltZXI6IDUwIC8vIGZyYW1lc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlbW92ZUNsYXNzKHRvd2VyQ2FyZHNbZ2V0VG93ZXJDYXJkSW5kZXgoYWN0aXZlVG93ZXJTZWxlY3RlZCldLCBcImFjdGl2ZVwiKTtcbiAgICAgICAgYWN0aXZlVG93ZXJTZWxlY3RlZCA9IG51bGw7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVc2VyIGlzIG5vdCBydW5uaW5nIGEgdG93ZXIgcGxhY2VtZW50XG4gICAgICAgIGFjdGl2ZUNhbnZhc0VsZW1lbnQgPSBjaGVja0NsaWNrTG9jYXRpb24ocG9zaXRpb24pO1xuICAgIH1cblxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9qcy9pbnRlcmZhY2UuanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgdG93ZXJEYXRhID0gcmVxdWlyZShcIi4uL2dhbWVEYXRhL3Rvd2VyZGF0YS5qc1wiKTtcbi8vIFBvc2l0aW9uIHJlZmVycyB0byB0aGUgdXBwZXIgbGVmdCBjb3JuZXIgb2YgdGhlIGVsZW1lbnRzXG4vLyBUb3dlciB3aWR0aCAtIDUwIHggNTBcbnZhciBUb3dlciA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBpZCkge1xuICAgIGlmICh0b3dlckRhdGFbaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIHRvd2VyIG5hbWUsIGNoZWNrIGh0bWwgZGF0YWF0dHJpYnV0ZSBvciB0b3dlcmRhdGFcIilcbiAgICB9XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuZGFtYWdlID0gdG93ZXJEYXRhW2lkXS5kYW1hZ2U7XG4gICAgdGhpcy5zcGVlZCA9IHRvd2VyRGF0YVtpZF0uc3BlZWQ7IC8vIEF0dGFjayBzcGVlZFxuICAgIHRoaXMucmFuZ2UgPSB0b3dlckRhdGFbaWRdLnJhbmdlOyAvLyBSYW5nZSBvZiB0aGUgdG93ZXJcbiAgICB0aGlzLnR5cGUgPSB0b3dlckRhdGFbaWRdLnR5cGU7IC8vIFR5cGUgb2YgZGFtYWdlXG4gICAgdGhpcy5lZmZlY3QgPSB0b3dlckRhdGFbaWRdLmVmZmVjdDsgLy8gU3BlY2lhbCBlZmZlY3QgKGUuZy4gc2xvdywgc3BsYXNoLCBldGMpXG4gICAgdGhpcy5nb2xkQ29zdCA9IHRvd2VyRGF0YVtpZF0uZ29sZENvc3Q7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uOyAvLyBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvb3JkaW5hdGVzIC0gc2hvdWxkIG5vdCBjaGFuZ2Vcbn1cbi8vIE1ldGhvZCB0aGUgZ2FtZSBvYmplY3QgdXNlcyB0byBydW4gdG93ZXJzXG5Ub3dlci5wcm90b3R5cGUucnVuQ3ljbGUgPSBmdW5jdGlvbigpIHtcblxufVxuLy8gY2hhbmdlIHRoaXMgdG8gcmVmZXJlbmNlIGEgbGlzdCBvciBzb21ldGhpbmcgd2hlcmUgYSBuYW1lIGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSB0aGUgcHJvcGVydGllc1xuLy8gVGFrZXMgaW4gYSBtb25zdGVyJ3MgcG9zaXRpb24gYW5kIGNoZWNrcyB3aGV0aGVyIHRoYXQgaXMgaW4gcmFuZ2UgYmFzZWQgb24gdGhlIHJhbmdlIC0gcmV0dXJucyB0cnVlIG9yIGZhbHNlIGlmIGluIHJhbmdlIHdoaWNoIGNhbiBiZSB1c2VkIHRvXG5Ub3dlci5wcm90b3R5cGUuY2hlY2tJblJhbmdlID0gZnVuY3Rpb24obW9uc3RlclBvc2l0aW9uKSB7XG4gICAgLy8gdXNpbmcgc3FydCgoeDIteDEpXjIgLSAoeTIteTEpXjIpXG4gICAgdmFyIG1vbnN0ZXJEaXN0YW5jZSA9XG4gICAgTWF0aC5zcXJ0KFxuICAgICAgICBNYXRoLlBvdyhtb25zdGVyUG9zaXRpb24ueC10aGlzLnBvc2l0aW9uLngpXG4gICAgLSAgIE1hdGguUG93KG1vbnN0ZXJQb3NpdGlvbi55LXRoaXMucG9zaXRpb24ueSlcbiAgICk7XG5cbiAgIGlmIChtb25zdGVyRGlzdGFuY2UgPD0gdGhpcy5yYW5nZSkge1xuICAgICAgIHJldHVybiB0cnVlO1xuICAgfSBlbHNlIHtcbiAgICAgICByZXR1cm4gZmFsc2U7XG4gICB9XG59XG5cblRvd2VyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oKSB7XG4gICAgZHluYW1pY0NvbnRleHQuZmlsbFN0eWxlID0gXCJncmVlblwiO1xuICAgIGR5bmFtaWNDb250ZXh0LmZpbGxSZWN0KHRoaXMucG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNTApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRvd2VyO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9qcy9jbGFzc2VzL1Rvd2VyLmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYmFzaWM6IHtcbiAgICAgICAgZGFtYWdlOiAxMCxcbiAgICAgICAgc3BlZWQ6IDEwLFxuICAgICAgICByYW5nZTogMTAwLFxuICAgICAgICBnb2xkQ29zdDogMTAsXG4gICAgICAgIHR5cGU6IFwiYmFzaWNcIixcbiAgICAgICAgZWZmZWN0OiBcIm5vbmVcIlxuICAgIH1cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2pzL2dhbWVEYXRhL3Rvd2VyZGF0YS5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vICByZXF1aXJlIE1vbnN0ZXIgdG8gZ2FpbiBhY2Nlc3NcbnZhciBNb25zdGVyID0gcmVxdWlyZShcIi4vTW9uc3Rlci5qc1wiKSxcbiAgICBUb3dlciA9IHJlcXVpcmUoXCIuL1Rvd2VyLmpzXCIpO1xuXG52YXIgR2FtZUVuZ2luZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudXNlckdvbGQgPSAxMDtcbiAgICB0aGlzLmxldmVsID0gMTtcbiAgICB0aGlzLnVzZXJMaXZlcyA9IDMwO1xuICAgIHRoaXMuYWN0aXZlTW9uc3RlcnMgPSBbXTsgLy8gTGlzdCBvZiBhY3RpdmUgbW9uc3RlcnMgaW4gdGhlXG4gICAgdGhpcy50b3dlcnMgPSBbXTsgLy8gb2JqZWN0IG9mIHRvd2VyIG9iamVjdHNcbiAgICB0aGlzLnRpbWVyID0gMTtcbiAgICAvLyBHb2VzIHRocm91Z2ggYW5kIGRpc2FibGVzIHRvd2VycyB0aGF0IGNhbid0IGJlIHVzZWQgeWV0XG59XG5cbkdhbWVFbmdpbmUucHJvdG90eXBlLmFkZE1vbnN0ZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgLy8gYWRkIG1vbnN0ZXIgKHNwZWNpZmllZCBieSBuYW1lKSB0byBnYW1lXG4gICAgdmFyIG1vbnN0ZXIgPSBuZXcgTW9uc3RlcihcIm1vbnN0ZXIxXCIpO1xuICAgIHRoaXMuYWN0aXZlTW9uc3RlcnMucHVzaChtb25zdGVyKTtcbn1cblxuR2FtZUVuZ2luZS5wcm90b3R5cGUuYWRkVG93ZXIgPSBmdW5jdGlvbihwb3NpdGlvbiwgaWQpIHtcbiAgICAvLyBDaGVjayBnb2xkIGNvc3QgYW5kIHRoZW4gcmVkdWNlIGdvbGRcbiAgICB2YXIgdG93ZXIgPSBuZXcgVG93ZXIocG9zaXRpb24sIGlkKTtcbiAgICB0aGlzLnRvd2Vycy5wdXNoKHRvd2VyKTtcblxufVxuXG4vLyBtZXRob2QgdG8gY2hlY2sgZ29sZCBiZWZvcmUgcGxhY2UgdG93ZXIgb3IgdXBncmFkZVxuR2FtZUVuZ2luZS5wcm90b3R5cGUuY2hlY2tHb2xkID0gZnVuY3Rpb24oZ29sZENvc3QpIHtcbiAgICBpZiAoZ29sZENvc3QgPiB0aGlzLnVzZXJHb2xkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG5HYW1lRW5naW5lLnByb3RvdHlwZS5nYW1lT3ZlciA9IGZ1bmN0aW9uKCkge1xuXG59XG5cbkdhbWVFbmdpbmUucHJvdG90eXBlLmdhbWVXb24gPSBmdW5jdGlvbigpIHtcblxufVxuXG4vLyBOZXcgbGV2ZWwgbWV0aG9kXG5HYW1lRW5naW5lLnByb3RvdHlwZS5uZXh0TGV2ZWwgPSBmdW5jdGlvbigpIHtcblxufVxuXG5HYW1lRW5naW5lLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBzZW5kIHN0YXRlIHRvIHRoZSBkaXNwbGF5IG9iamVjdCB0byByZW5kZXJcbiAgICBkeW5hbWljQ29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBkeW5hbWljQ29udGV4dC5jbGVhclJlY3QoMCwgMCwgZHluYW1pY0NhbnZhcy53aWR0aCwgZHluYW1pY0NhbnZhcy5oZWlnaHQpO1xuXG4gICAgLy8gUmVuZGVyIHRvd2VycyBmaXJzdCBzbyB0aGF0IGlmIG1vbnN0ZXJzIGFyZSBsYXJnZXIgdGhleSBzaG93IGFib3ZlIHRvd2Vyc1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gdGhpcy50b3dlcnMubGVuZ3RoOyBpIDwgajsgaSArKykge1xuICAgICAgICB0aGlzLnRvd2Vyc1tpXS5kcmF3KCk7XG4gICAgfVxuXG4gICAgLy8gIGxvb3AgdGhyb3VnaCBsaXN0IG9mIGFjdGl2ZSBtb25zdGVycyBhbmQgcmVuZGVyIHRoZW1cbiAgICAvLyAgVE9ETyBwcm9iYWJseSBuZWVkIHRvIGZpbmQgYSBiZXR0ZXIgd2F5IHRvIHJlbmQgdGhlbSBhcGFydCBmcm9tIHJhbmRvbSByZWN0YW5nbGVcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuYWN0aXZlTW9uc3RlcnMubGVuZ3RoOyBpIDwgajsgaSArKykge1xuICAgICAgICB0aGlzLmFjdGl2ZU1vbnN0ZXJzW2ldLmRyYXcoKTtcbiAgICB9XG5cblxuXG4gICAgLy8gZHluYW1pY0NvbnRleHQuXG59O1xuXG5HYW1lRW5naW5lLnByb3RvdHlwZS5ydW5DeWNsZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vICBiZWdpbm5pbmcgb2YgY3ljbGUgY2hlY2sgaWYgYW55IG1vbnN0ZXJzIGhhdmUgZGllZCBpZiBzbyByZW1vdmUgZnJvbSBhY3RpdmUgbW9uc3RlcnNcbiAgICB0aGlzLmNoZWNrTW9uc3RlckRlYXRoKCk7XG4gICAgLy8gbG9vcCB0aHJvdWdoIGFjdGl2ZSBtb25zdGVycyBhbmQgdG93ZXJzIGFuZCBydW4gdGhlIGN5Y2xlXG4gICAgLy8gRWFjaCBydW5DeWNsZSBtZXRob2QgcmV0dXJucyBpbmZvcm1hdGlvbiBmb3IgdGhlIGdhbWVFbmdpbmUgdG9cbiAgICAvLyBwcm9jZXNzIChlLmcuIHRoZSBtb25zdGVyIGRpZWQsIHRvd2VyIGNoYW5nZWQpXG5cbiAgICAvLyAgdGltZXIgdG8gYWRkIG1vbnN0ZXJzXG4gICAgdGhpcy50aW1lci0tO1xuICAgIGlmICh0aGlzLnRpbWVyIDwgMSkge1xuICAgICAgICB0aGlzLmFkZE1vbnN0ZXIoJ2JsYWgnKTtcbiAgICAgICAgdGhpcy50aW1lciA9IDEwO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuYWN0aXZlTW9uc3RlcnMubGVuZ3RoOyBpIDwgajsgaSArKykge1xuICAgICAgICB0aGlzLmFjdGl2ZU1vbnN0ZXJzW2ldLm1vdmUoKTtcbiAgICB9XG4gICAgLy8gU2VuZCBpbmZvcm1hdGlvbiB0byByZW5kZXJcbn1cblxuLy8gbWV0aG9kIHRvIHVwZ3JhZGUgdG93ZXJcblxuLy8gNTAgeCA1MCB0b3dlclxuR2FtZUVuZ2luZS5wcm90b3R5cGUudmFsaWRhdGVUb3dlclBsYWNlbWVudCA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgdmFyIHBvc2l0aW9uVmFsaWQgPSBmYWxzZTtcbiAgICAvLyByZXR1cm5zIHRydWUgb3IgZmFsc2Ugd2hldGhlciB0b3dlciBwbGFjZW1lbnQgaXMgdmFsaWRcbiAgICByZXR1cm4gcG9zaXRpb25WYWxpZDtcbn1cblxuR2FtZUVuZ2luZS5wcm90b3R5cGUuY2hlY2tNb25zdGVyRGVhdGggPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuYWN0aXZlTW9uc3RlcnMubGVuZ3RoOyBpIDwgajsgaSArKykge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVNb25zdGVyc1tpXS5jaGVja0RlYXRoKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlTW9uc3RlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgai0tO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyByZWRyYXcgY2FudmFzXG5cbm1vZHVsZS5leHBvcnRzID0gR2FtZUVuZ2luZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvY2xhc3Nlcy9HYW1lLmpzXG4gKiogbW9kdWxlIGlkID0gNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIG1vbnN0ZXJEYXRhID0gcmVxdWlyZShcIi4uL2dhbWVEYXRhL21vbnN0ZXJkYXRhLmpzXCIpO1xuXG52YXIgTW9uc3RlciA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuY3VycmVudEhwID0gbW9uc3RlckRhdGFbaWRdLm1heEhwO1xuICAgIHRoaXMubWF4SHAgPSBtb25zdGVyRGF0YVtpZF0ubWF4SHA7XG4gICAgdGhpcy5iYXNlTXMgPSBtb25zdGVyRGF0YVtpZF0uYmFzZU1zOyAvLyBNb3ZlbWVudCBzcGVlZCAtIFwidW5pdHNcIiBwZXIgc2Vjb25kXG4gICAgdGhpcy50eXBlID0gbW9uc3RlckRhdGFbaWRdLnR5cGU7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHsgLy8gQWxsIG1vbnN0ZXJzIGFyZSBjcmVhdGVkIGluIHRoZSBzYW1lIHBvc2l0aW9uXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDQ4NVxuICAgIH1cbn07XG4vLyBNZXRob2QgdGhlIGdhbWUgb2JqZWN0IHVzZXMgdG8gbW92ZSBtb25zdGVyc1xuTW9uc3Rlci5wcm90b3R5cGUucnVuQ3ljbGUgPSBmdW5jdGlvbigpIHtcblxufVxuXG5Nb25zdGVyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oKSB7XG4gICAgZHluYW1pY0NvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgZHluYW1pY0NvbnRleHQucmVjdCh0aGlzLnBvc2l0aW9uLngsIHRoaXMucG9zaXRpb24ueSwgMzAsIDMwKTtcbiAgICBkeW5hbWljQ29udGV4dC5zdHJva2UoKTtcbiAgICBkeW5hbWljQ29udGV4dC5maWxsU3R5bGUgPSBcInJlZFwiO1xuICAgIGR5bmFtaWNDb250ZXh0LmZpbGxSZWN0KHRoaXMucG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uLnkgKyAzMC8zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMwICogdGhpcy5jdXJyZW50SHAvdGhpcy5tYXhIcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzMC8zKTtcbn1cblxuTW9uc3Rlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXG59O1xuXG5Nb25zdGVyLnByb3RvdHlwZS5jaGVja0RlYXRoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudEhwIDw9IDA7XG59O1xuXG4vLyBFeHBlY3RzIHVwLCBkb3duLCBsZWZ0IG9yIHJpZ2h0XG5Nb25zdGVyLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgdmFyIHNwZWVkID0gdGhpcy5iYXNlTXM7XG5cbiAgICAvLyBzb21lIGJhc2ljIG1vbnN0ZXIgTW92ZW1lbnRcbiAgICAvLyAgTk9URSBzdWNoIGEgaGFzc2xlIHRvIGZpZ3VyZSB0aGlzIG91dFxuICAgIC8vICBUT0RPIG5vdCBmaW5pc2hlZCwgbm90IGV2ZW4gZ29pbmcgdG8gdHJ5IGFuZCBmaW5pc2ggd2lsbCBmaWd1cmUgb3V0IGhvdyB0aGlzIHNob3VsZCB3b3JrIGxhdGVyXG4gICAgaWYgKHRoaXMucG9zaXRpb24ueCA8PSA1MCAmJiB0aGlzLnBvc2l0aW9uLnkgPCA1MDApIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi54ICs9IHNwZWVkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wb3NpdGlvbi54ID49IDUwICYmIHRoaXMucG9zaXRpb24ueSA+PSA5MCkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uLnkgLT0gc3BlZWQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBvc2l0aW9uLnggPD0gMTgwICYmIHRoaXMucG9zaXRpb24ueSA+PSA4MCkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uLnggKz0gc3BlZWQ7XG4gICAgfVxuXG4gICAgLy8gIG1heSBub3QgYmUgdGhlIGJlc3Qgd2F5IHRvIGRvIHRoaXMgYnV0IGlsbCBrZWVwIGl0IGJlY2F1c2Ugbm90IGV2ZW4gc3VyZSBob3cgdG8gZG8gdGhpcyBtb3ZlbWVudCBwYXJ0XG4gICAgLy8gaWYgKHR5cGVvZiBkaXJlY3Rpb24gIT09IFwic3RyaW5nXCIpIHtcbiAgICAvLyAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImRpcmVjdGlvbiBpcyBub3QgYSBzdHJpbmdcIik7XG4gICAgLy8gfVxuICAgIC8vIGRpcmVjdGlvbiA9IGRpcmVjdGlvbi50b0xvd2VyQ2FzZSgpO1xuICAgIC8vIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgLy8gICAgIGNhc2UgXCJ1cFwiOlxuICAgIC8vICAgICBjYXNlIFwiZG93blwiOlxuICAgIC8vICAgICBjYXNlIFwibGVmdFwiOlxuICAgIC8vICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAvLyAgICAgZGVmYXVsdDpcbiAgICAvLyAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGlyZWN0aW9uXCIpO1xuICAgIC8vIH1cbn07XG5cbi8vIENhbiB0YWtlIGluIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgbnVtYmVyXG5Nb25zdGVyLnByb3RvdHlwZS51cGRhdGVIcCA9IGZ1bmN0aW9uKGhwQ2hhbmdlKSB7XG4gICAgdGhpcy5jdXJyZW50SHAgKz0gaHBDaGFuZ2U7XG5cbiAgICBpZiAodGhpcy5jdXJyZW50SHAgPiB0aGlzLm1heEhwKSB7XG4gICAgICAgIHRoaXMuY3VycmVudEhwID0gdGhpcy5tYXhIcDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vbnN0ZXI7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2pzL2NsYXNzZXMvTW9uc3Rlci5qc1xuICoqIG1vZHVsZSBpZCA9IDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG1vbnN0ZXIxOiB7XG4gICAgICAgIG1heEhwOiAzMCxcbiAgICAgICAgYmFzZU1zOiAxMCxcbiAgICAgICAgdHlwZTogMSAvLyBDaGFuZ2UgdGhpcyB0eXBlIGxhdGVyXG4gICAgfVxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvZ2FtZURhdGEvbW9uc3RlcmRhdGEuanNcbiAqKiBtb2R1bGUgaWQgPSA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9