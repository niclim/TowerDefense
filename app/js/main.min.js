/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/src/js/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	// Canvas
	__webpack_require__(2);
	
	// User interaction elements
	__webpack_require__(3);


/***/ },
/* 2 */
/***/ function(module, exports) {

	// background contains the static canvas elements
	var background = document.getElementById("static");
	var backgroundContext = background.getContext("2d");
	
	// Settings for the background - move out to a separate file
	var settings = {
	    backgroundColor: "#8CD1E6",
	    pathColor: "gray"
	}
	
	// Drawing the background
	backgroundContext.fillStyle = settings.backgroundColor;
	backgroundContext.fillRect(0, 0, background.width, background.height);
	
	/* Main path will go from [0, 500], [75, 500], [75, 100], [225, 100], [225, 500], [375, 500], [375, 100], [525, 100], [525, 500], [675, 500], [675, 100], [825, 100], [825, 500], [900, 500] */
	
	// Drawing the path - width of the path is 50px
	backgroundContext.fillStyle = settings.pathColor;
	
	backgroundContext.beginPath();
	
	// For the bottom part of the path
	backgroundContext.moveTo(0, 525);
	
	backgroundContext.lineTo(100, 525);
	backgroundContext.lineTo(100, 125); // Top
	backgroundContext.lineTo(200, 125);
	backgroundContext.lineTo(200, 525); // Bottom
	backgroundContext.lineTo(400, 525);
	backgroundContext.lineTo(400, 125); // Top
	backgroundContext.lineTo(500, 125);
	backgroundContext.lineTo(500, 525); // Bottom
	backgroundContext.lineTo(700, 525);
	backgroundContext.lineTo(700, 125); // Top
	backgroundContext.lineTo(800, 125);
	backgroundContext.lineTo(800, 525); // Bottom
	
	//Middle section to the side
	backgroundContext.lineTo(900, 525);
	backgroundContext.lineTo(900, 475);
	backgroundContext.lineTo(850, 475);
	
	// For the top part of the path
	backgroundContext.lineTo(850, 75);
	backgroundContext.lineTo(650, 75);
	backgroundContext.lineTo(650, 475);
	backgroundContext.lineTo(550, 475);
	backgroundContext.lineTo(550, 75);
	backgroundContext.lineTo(350, 75);
	backgroundContext.lineTo(350, 475);
	backgroundContext.lineTo(250, 475);
	backgroundContext.lineTo(250, 75);
	backgroundContext.lineTo(50, 75);
	backgroundContext.lineTo(50, 475);
	
	// End section
	backgroundContext.lineTo(0, 475);
	
	backgroundContext.fill();
	// backgroundContext.lineTo();


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	// Initiate all the components
	var Tower = __webpack_require__(4),
	    GameEngine = __webpack_require__(6)
	
	// Cache reused DOM elements
	var infoName = document.getElementById("info-name"),
	    infoBox1 = document.getElementById("info-box-1"),
	    infoBox2 = document.getElementById("info-box-2"),
	    infoBox3 = document.getElementById("info-box-3"),
	    infoBox4 = document.getElementById("info-box-4");
	
	//  creates global variables
	game = new GameEngine;
	dynamicCanvas = document.getElementById('dynamic');
	dynamicContext = dynamicCanvas.getContext('2d');
	
	runCycle = function() {
	    game.runCycle();
	    setTimeout(runCycle, 1000);
	}
	
	renderCycle = function() {
	    game.render();
	    requestAnimationFrame(renderCycle);
	}
	
	// HERE IS ALL THE INTERACTION EVENT LISTENERS
	
	/* ============== On start click handlers ==============*/
	/* =====================================================*/
	
	// On start, create a game element - these event listeners will be destroyed when the container is overriden
	document.getElementById("start-btn").addEventListener("click", function() {
	    // Hides the modal lightbox
	    document.getElementsByClassName("modal-content")[0].style.display = "none";
	    document.getElementsByClassName("modal-background")[0].style.display = "none";
	
	    // run repeating function that runs game engine run cycle and rendering
	    setTimeout(runCycle, 1000);
	    requestAnimationFrame(renderCycle);
	});
	
	// On clicking the information button, show the information panel
	document.getElementById("information-btn").addEventListener("click", function() {
	    console.log("show information container here");
	});
	
	/* ======== Information container interactions =========*/
	/* =====================================================*/
	
	
	
	/* ================= Information Click =================*/
	/* =====================================================*/
	// Shows information about towers or monsters if hovered over
	// or active
	var activeCanvasElement = null;
	
	
	function comparePositions(clickPosition, elementPosition, type) {
	    var sideLength = type === "monster" ? 30 : 50; // width and height of the element
	    if (clickPosition.x >= elementPosition.x
	    && clickPosition.x <= elementPosition.x + sideLength
	    && clickPosition.y >= elementPosition.y
	    && clickPosition.y <= elementPosition.y + sideLength) {
	        return true;
	    } else {
	        return false;
	    }
	}
	
	// Takes in a position object (location of the click)
	// returns an object with information about what is at that position
	function checkClickLocation(position) {
	    var element = {};
	    // Loops through activeMonsters
	    for (var i = 0; i < game.activeMonsters.length; i++) {
	        if (comparePositions(position, game.activeMonsters[i].position, "monster")) {
	            element.type = "monster";
	            element.id = game.activeMonsters[i].id;
	            element.index = i;
	            break;
	        }
	    }
	
	    // If nothing was found, loop through towers
	    if (element.type === undefined) {
	        for (var i = 0; i < game.towers.length; i++) {
	            if (comparePositions(position, game.towers[i].position, "tower")) {
	                element.type = "tower";
	                element.id = game.towers[i].id;
	                element.index = i;
	                break;
	            }
	        }
	    }
	
	    // If no towers or monsters found return a type of null
	    if (element.type === undefined) {
	        element.type = null;
	    }
	
	    return element;
	}
	
	// Get information from towerdata.js
	
	/* ========== Tower Card Click and placements ==========*/
	/* =====================================================*/
	// Click a tower card and make "active" which can be placed on UI element
	// While it is active - use #dynamic.onmousemove = function -> to Send
	// information to the canvas
	
	// set up event listeners at the start which reference functions - these functions depend on the state on the application to control their control flow
	var activeTowerSelected = null;
	var towerCards = document.getElementsByClassName("tower-card");
	var towerCardList = [];
	
	function addClass(element, cssClass) {
	    if (element.className === "") {
	        element.className = cssClass;
	    } else {
	        element.className += " " + cssClass;
	    }
	}
	
	function removeClass(element, cssClass) {
	    var arrayOfClasses = element.className.split(" ");
	    for (var i = 0, j = arrayOfClasses.length; i < j; i++) {
	        if (arrayOfClasses[i] === cssClass) {
	            arrayOfClasses.splice(i, 1);
	            i--; j--;
	        }
	    }
	    element.className = arrayOfClasses.join(" ");
	}
	
	function getIndex(towerName) {
	    return towerCardList.indexOf(towerName);
	}
	
	function towerCardClick() {
	
	    var towerName = this.getAttribute("data-tower");
	
	    if (/disabled/i.test(this.className)) { // Tower is disabled
	        return;
	    } else if (activeTowerSelected === null) { // There is no active tower being placed
	        // set the active tower selected to be the tower name
	        // Set up active elements
	        activeTowerSelected = towerName;
	        addClass(towerCards[getIndex(activeTowerSelected)], "active");
	    } else if (activeTowerSelected === towerName) { // The tower card clicked is the same as the active tower
	        cancelTowerPlacement();
	    } else { // There is an active tower which is not the same as what was clicked
	        removeClass(towerCards[getIndex(activeTowerSelected)], "active");
	        activeTowerSelected = towerName;
	        addClass(towerCards[getIndex(activeTowerSelected)], "active");
	    }
	}
	
	function onTowerMouseMovement(e) {
	    if (activeTowerSelected === null) {
	        return
	    };
	    var canvasContainer = this.getBoundingClientRect();
	    var offsetX = e.clientX - canvasContainer.left,
	        offsetY = e.clientY - canvasContainer.top;
	    // send to display to get rendered
	};
	
	// Two possible canvas click scenarios:
	// 1) Tower selection is active (place a tower)
	// 2) Tower selection is inactive (clicking to get information about a monster or tower on the map)
	function canvasClick(e) {
	    // Get click location relative to the canvas element
	    var canvasContainer = this.getBoundingClientRect(),
	    position = {};
	
	    position.x = e.clientX - canvasContainer.left;
	    position.y = e.clientY - canvasContainer.top;
	
	    if (activeTowerSelected !== null) { //
	        var towerName = activeTowerSelected; // NOTE CHANGE GET TOWER NAME FROM LIST
	
	        if (game.validateTowerPlacement(towerName, position)) {
	            console.log("towerPlaced");
	            game.addTower(towerName, position);
	        } else {
	            console.log("invalid tower placement");
	            // show error message somewhere for the user
	        }
	        removeClass(towerCards[getIndex(activeTowerSelected)], "active");
	        activeTowerSelected = null;
	
	    } else {
	        // check if the position overlaps with the bounding rectangle of monster or tower
	        var element = checkClickLocation(position);
	        console.log(element);
	        if (element.type === "monster") {
	            infoName.innerHTML = element.id;
	
	        } else if (element.type === "tower") {
	            console.log("show tower information")
	        } else {
	            infoName.innerHTML = "Awesome TD";
	            console.log("show default information")
	        }
	        // if it is, change the information container
	    }
	
	}
	
	function cancelTowerPlacement() {
	
	    removeClass(towerCards[getIndex(activeTowerSelected)], "active");
	    activeTowerSelected = null;
	}
	
	
	// Set up event listeners
	// Convert from nodelist to array
	towerCards = Array.prototype.slice.call(towerCards);
	
	// Tower card click event listeners
	towerCards.map(function(towerCard, i) {
	    towerCardList.push(towerCard.getAttribute("data-tower"));
	    towerCard.addEventListener("click", towerCardClick);
	});
	
	// Game container event listeners
	document.getElementById("dynamic").onmousemove = onTowerMouseMovement;
	document.getElementById("dynamic").addEventListener("click", canvasClick);
	
	// Tower placement cancelling event listeners
	document.onkeydown = function(e) {
	    if (e.keyCode === 27) {
	        cancelTowerPlacement();
	    }
	}


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var towerData = __webpack_require__(5);
	
	var Tower = function(position, id) {
	    this.id = id;
	    this.damage = towerData[id].damage;
	    this.speed = towerData[id].speed; // Attack speed
	    this.range = towerData[id].range; // Range of the tower
	    this.type = towerData[id].type; // Type of damage
	    this.effect = towerData[id].effect; // Special effect (e.g. slow, splash, etc)
	    this.position = position; // object with x and y coordinates - should not change
	}
	// Method the game object uses to run towers
	Tower.prototype.runCycle = function() {
	
	}
	// change this to reference a list or something where a name can be used to determine the properties
	// Takes in a monster's position and checks whether that is in range based on the range - returns true or false if in range which can be used to
	Tower.prototype.checkInRange = function(monsterPosition) {
	
	}
	
	module.exports = Tower;


/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = {
	    basic: {
	        damage: 10,
	        speed: 10,
	        range: 100,
	        type: "basic",
	        effect: "none"
	    }
	};


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	//  require Monster to gain access
	var Monster = __webpack_require__(7);
	
	var GameEngine = function() {
	    this.userGold = 10;
	    this.level = 1;
	    this.userLives = 30;
	    this.activeMonsters = []; // List of active monsters in the
	    this.towers = []; // object of tower objects
	    this.timer = 1;
	    // Goes through and disables towers that can't be used yet
	}
	
	GameEngine.prototype.addMonster = function(name) {
	    // add monster (specified by name) to game
	    var monster = new Monster("monster1");
	    this.activeMonsters.push(monster);
	}
	
	GameEngine.prototype.addTower = function(name, position) {
	    // add tower (specified by name) at location
	}
	
	// method to check gold before place tower or upgrade
	GameEngine.prototype.checkGold = function(goldCost) {
	    if (goldCost > this.userGold) {
	        return true;
	    } else {
	        return false;
	    }
	};
	
	GameEngine.prototype.gameOver = function() {
	
	}
	
	GameEngine.prototype.gameWon = function() {
	
	}
	
	// New level method
	GameEngine.prototype.nextLevel = function() {
	
	}
	
	GameEngine.prototype.render = function() {
	    // send state to the display object to render
	    dynamicContext.beginPath();
	    dynamicContext.clearRect(0, 0, dynamicCanvas.width, dynamicCanvas.height);
	
	    //  loop through list of active monsters and render them
	    //  TODO probably need to find a better way to rend them apart from random rectangle
	    for (var i = 0, j = this.activeMonsters.length; i < j; i ++) {
	        this.activeMonsters[i].draw();
	    }
	
	    // dynamicContext.
	};
	
	GameEngine.prototype.runCycle = function() {
	    //  beginning of cycle check if any monsters have died if so remove from active monsters
	    this.checkMonsterDeath();
	    // loop through active monsters and towers and run the cycle
	    // Each runCycle method returns information for the gameEngine to
	    // process (e.g. the monster died, tower changed)
	
	    //  timer to add monsters
	    this.timer--;
	    if (this.timer < 1) {
	        this.addMonster('blah');
	        this.timer = 10;
	    }
	    for (var i = 0, j = this.activeMonsters.length; i < j; i ++) {
	        this.activeMonsters[i].move();
	    }
	    // Send information to render
	}
	
	// method to upgrade tower
	
	GameEngine.prototype.validateTowerPlacement = function(name, position) {
	    // returns true or false whether tower placement is valid
	    return true;
	}
	
	GameEngine.prototype.checkMonsterDeath = function() {
	    for (var i = 0, j = this.activeMonsters.length; i < j; i ++) {
	        if (this.activeMonsters[i].checkDeath()) {
	            this.activeMonsters.splice(i, 1);
	            i--;
	            j--;
	        }
	    }
	}
	
	// redraw canvas
	
	module.exports = GameEngine;


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var monsterData = __webpack_require__(8);
	
	var Monster = function(id) {
	    this.id = id;
	    this.currentHp = monsterData[id].maxHp;
	    this.maxHp = monsterData[id].maxHp;
	    this.baseMs = monsterData[id].baseMs; // Movement speed - "units" per second
	    this.type = monsterData[id].type;
	    this.position = { // All monsters are created in the same position
	        x: 0,
	        y: 485
	    }
	};
	// Method the game object uses to move monsters
	Monster.prototype.runCycle = function() {
	
	}
	
	Monster.prototype.draw = function() {
	    dynamicContext.beginPath();
	    dynamicContext.rect(this.position.x, this.position.y, 30, 30);
	    dynamicContext.stroke();
	    dynamicContext.fillStyle = "red";
	    dynamicContext.fillRect(this.position.x,
	                            this.position.y + 30/3,
	                            30 * this.currentHp/this.maxHp,
	                            30/3);
	}
	
	Monster.prototype.destroy = function() {
	
	};
	
	Monster.prototype.checkDeath = function() {
	    return this.currentHp <= 0;
	};
	
	// Expects up, down, left or right
	Monster.prototype.move = function(direction) {
	    var speed = this.baseMs;
	
	    // some basic monster Movement
	    //  NOTE such a hassle to figure this out
	    //  TODO not finished, not even going to try and finish will figure out how this should work later
	    if (this.position.x <= 50 && this.position.y < 500) {
	        this.position.x += speed;
	    } else if (this.position.x >= 50 && this.position.y >= 90) {
	        this.position.y -= speed;
	    } else if (this.position.x <= 180 && this.position.y >= 80) {
	        this.position.x += speed;
	    }
	
	    //  may not be the best way to do this but ill keep it because not even sure how to do this movement part
	    // if (typeof direction !== "string") {
	    //     throw new TypeError("direction is not a string");
	    // }
	    // direction = direction.toLowerCase();
	    // switch (direction) {
	    //     case "up":
	    //     case "down":
	    //     case "left":
	    //     case "right":
	    //     default:
	    //         throw new Error("Invalid direction");
	    // }
	};
	
	// Can take in a positive or negative number
	Monster.prototype.updateHp = function(hpChange) {
	    this.currentHp += hpChange;
	
	    if (this.currentHp > this.maxHp) {
	        this.currentHp = this.maxHp;
	    }
	};
	
	module.exports = Monster;


/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = {
	    monster1: {
	        maxHp: 30,
	        baseMs: 10,
	        type: 1 // Change this type later
	    }
	};


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgY2I0NWI2NTEzMTQ4NTMyZDUzYjYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2VudHJ5LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9iYWNrZ3JvdW5kLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NsYXNzZXMvVG93ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2dhbWVEYXRhL3Rvd2VyZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY2xhc3Nlcy9HYW1lLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9jbGFzc2VzL01vbnN0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2dhbWVEYXRhL21vbnN0ZXJkYXRhLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0Esb0NBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDM0RBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxtREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixnQ0FBZ0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsNENBQTJDO0FBQzNDO0FBQ0EsTUFBSyx5Q0FBeUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLLDhDQUE4QztBQUNuRDtBQUNBLE1BQUssT0FBTztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0NBQXVDO0FBQ3ZDLDZDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBUztBQUNUO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMvT0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0NBQXFDO0FBQ3JDLHNDQUFxQztBQUNyQyxvQ0FBbUM7QUFDbkMsd0NBQXVDO0FBQ3ZDLDhCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDUkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QixzQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBbUQsT0FBTztBQUMxRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFtRCxPQUFPO0FBQzFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0RBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNqR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBeUM7QUFDekM7QUFDQSxzQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Im1haW4ubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL3NyYy9qcy9cIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIGNiNDViNjUxMzE0ODUzMmQ1M2I2XG4gKiovIiwiLy8gQ2FudmFzXG5yZXF1aXJlKFwiLi9iYWNrZ3JvdW5kLmpzXCIpO1xuXG4vLyBVc2VyIGludGVyYWN0aW9uIGVsZW1lbnRzXG5yZXF1aXJlKFwiLi9pbnRlcmZhY2UuanNcIik7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2pzL2VudHJ5LmpzXG4gKiogbW9kdWxlIGlkID0gMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gYmFja2dyb3VuZCBjb250YWlucyB0aGUgc3RhdGljIGNhbnZhcyBlbGVtZW50c1xudmFyIGJhY2tncm91bmQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN0YXRpY1wiKTtcbnZhciBiYWNrZ3JvdW5kQ29udGV4dCA9IGJhY2tncm91bmQuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4vLyBTZXR0aW5ncyBmb3IgdGhlIGJhY2tncm91bmQgLSBtb3ZlIG91dCB0byBhIHNlcGFyYXRlIGZpbGVcbnZhciBzZXR0aW5ncyA9IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzhDRDFFNlwiLFxuICAgIHBhdGhDb2xvcjogXCJncmF5XCJcbn1cblxuLy8gRHJhd2luZyB0aGUgYmFja2dyb3VuZFxuYmFja2dyb3VuZENvbnRleHQuZmlsbFN0eWxlID0gc2V0dGluZ3MuYmFja2dyb3VuZENvbG9yO1xuYmFja2dyb3VuZENvbnRleHQuZmlsbFJlY3QoMCwgMCwgYmFja2dyb3VuZC53aWR0aCwgYmFja2dyb3VuZC5oZWlnaHQpO1xuXG4vKiBNYWluIHBhdGggd2lsbCBnbyBmcm9tIFswLCA1MDBdLCBbNzUsIDUwMF0sIFs3NSwgMTAwXSwgWzIyNSwgMTAwXSwgWzIyNSwgNTAwXSwgWzM3NSwgNTAwXSwgWzM3NSwgMTAwXSwgWzUyNSwgMTAwXSwgWzUyNSwgNTAwXSwgWzY3NSwgNTAwXSwgWzY3NSwgMTAwXSwgWzgyNSwgMTAwXSwgWzgyNSwgNTAwXSwgWzkwMCwgNTAwXSAqL1xuXG4vLyBEcmF3aW5nIHRoZSBwYXRoIC0gd2lkdGggb2YgdGhlIHBhdGggaXMgNTBweFxuYmFja2dyb3VuZENvbnRleHQuZmlsbFN0eWxlID0gc2V0dGluZ3MucGF0aENvbG9yO1xuXG5iYWNrZ3JvdW5kQ29udGV4dC5iZWdpblBhdGgoKTtcblxuLy8gRm9yIHRoZSBib3R0b20gcGFydCBvZiB0aGUgcGF0aFxuYmFja2dyb3VuZENvbnRleHQubW92ZVRvKDAsIDUyNSk7XG5cbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygxMDAsIDUyNSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oMTAwLCAxMjUpOyAvLyBUb3BcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygyMDAsIDEyNSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oMjAwLCA1MjUpOyAvLyBCb3R0b21cbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg0MDAsIDUyNSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNDAwLCAxMjUpOyAvLyBUb3BcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg1MDAsIDEyNSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNTAwLCA1MjUpOyAvLyBCb3R0b21cbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg3MDAsIDUyNSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNzAwLCAxMjUpOyAvLyBUb3BcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg4MDAsIDEyNSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oODAwLCA1MjUpOyAvLyBCb3R0b21cblxuLy9NaWRkbGUgc2VjdGlvbiB0byB0aGUgc2lkZVxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDkwMCwgNTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg5MDAsIDQ3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oODUwLCA0NzUpO1xuXG4vLyBGb3IgdGhlIHRvcCBwYXJ0IG9mIHRoZSBwYXRoXG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oODUwLCA3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNjUwLCA3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNjUwLCA0NzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDU1MCwgNDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg1NTAsIDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygzNTAsIDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygzNTAsIDQ3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oMjUwLCA0NzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDI1MCwgNzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDUwLCA3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNTAsIDQ3NSk7XG5cbi8vIEVuZCBzZWN0aW9uXG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oMCwgNDc1KTtcblxuYmFja2dyb3VuZENvbnRleHQuZmlsbCgpO1xuLy8gYmFja2dyb3VuZENvbnRleHQubGluZVRvKCk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2pzL2JhY2tncm91bmQuanNcbiAqKiBtb2R1bGUgaWQgPSAyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBJbml0aWF0ZSBhbGwgdGhlIGNvbXBvbmVudHNcbnZhciBUb3dlciA9IHJlcXVpcmUoXCIuL2NsYXNzZXMvVG93ZXIuanNcIiksXG4gICAgR2FtZUVuZ2luZSA9IHJlcXVpcmUoXCIuL2NsYXNzZXMvR2FtZS5qc1wiKVxuXG4vLyBDYWNoZSByZXVzZWQgRE9NIGVsZW1lbnRzXG52YXIgaW5mb05hbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImluZm8tbmFtZVwiKSxcbiAgICBpbmZvQm94MSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5mby1ib3gtMVwiKSxcbiAgICBpbmZvQm94MiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5mby1ib3gtMlwiKSxcbiAgICBpbmZvQm94MyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5mby1ib3gtM1wiKSxcbiAgICBpbmZvQm94NCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5mby1ib3gtNFwiKTtcblxuLy8gIGNyZWF0ZXMgZ2xvYmFsIHZhcmlhYmxlc1xuZ2FtZSA9IG5ldyBHYW1lRW5naW5lO1xuZHluYW1pY0NhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkeW5hbWljJyk7XG5keW5hbWljQ29udGV4dCA9IGR5bmFtaWNDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxucnVuQ3ljbGUgPSBmdW5jdGlvbigpIHtcbiAgICBnYW1lLnJ1bkN5Y2xlKCk7XG4gICAgc2V0VGltZW91dChydW5DeWNsZSwgMTAwMCk7XG59XG5cbnJlbmRlckN5Y2xlID0gZnVuY3Rpb24oKSB7XG4gICAgZ2FtZS5yZW5kZXIoKTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyQ3ljbGUpO1xufVxuXG4vLyBIRVJFIElTIEFMTCBUSEUgSU5URVJBQ1RJT04gRVZFTlQgTElTVEVORVJTXG5cbi8qID09PT09PT09PT09PT09IE9uIHN0YXJ0IGNsaWNrIGhhbmRsZXJzID09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuLy8gT24gc3RhcnQsIGNyZWF0ZSBhIGdhbWUgZWxlbWVudCAtIHRoZXNlIGV2ZW50IGxpc3RlbmVycyB3aWxsIGJlIGRlc3Ryb3llZCB3aGVuIHRoZSBjb250YWluZXIgaXMgb3ZlcnJpZGVuXG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN0YXJ0LWJ0blwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgLy8gSGlkZXMgdGhlIG1vZGFsIGxpZ2h0Ym94XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIm1vZGFsLWNvbnRlbnRcIilbMF0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJtb2RhbC1iYWNrZ3JvdW5kXCIpWzBdLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblxuICAgIC8vIHJ1biByZXBlYXRpbmcgZnVuY3Rpb24gdGhhdCBydW5zIGdhbWUgZW5naW5lIHJ1biBjeWNsZSBhbmQgcmVuZGVyaW5nXG4gICAgc2V0VGltZW91dChydW5DeWNsZSwgMTAwMCk7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlckN5Y2xlKTtcbn0pO1xuXG4vLyBPbiBjbGlja2luZyB0aGUgaW5mb3JtYXRpb24gYnV0dG9uLCBzaG93IHRoZSBpbmZvcm1hdGlvbiBwYW5lbFxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbmZvcm1hdGlvbi1idG5cIikuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgIGNvbnNvbGUubG9nKFwic2hvdyBpbmZvcm1hdGlvbiBjb250YWluZXIgaGVyZVwiKTtcbn0pO1xuXG4vKiA9PT09PT09PSBJbmZvcm1hdGlvbiBjb250YWluZXIgaW50ZXJhY3Rpb25zID09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuXG4vKiA9PT09PT09PT09PT09PT09PSBJbmZvcm1hdGlvbiBDbGljayA9PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vLyBTaG93cyBpbmZvcm1hdGlvbiBhYm91dCB0b3dlcnMgb3IgbW9uc3RlcnMgaWYgaG92ZXJlZCBvdmVyXG4vLyBvciBhY3RpdmVcbnZhciBhY3RpdmVDYW52YXNFbGVtZW50ID0gbnVsbDtcblxuXG5mdW5jdGlvbiBjb21wYXJlUG9zaXRpb25zKGNsaWNrUG9zaXRpb24sIGVsZW1lbnRQb3NpdGlvbiwgdHlwZSkge1xuICAgIHZhciBzaWRlTGVuZ3RoID0gdHlwZSA9PT0gXCJtb25zdGVyXCIgPyAzMCA6IDUwOyAvLyB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBlbGVtZW50XG4gICAgaWYgKGNsaWNrUG9zaXRpb24ueCA+PSBlbGVtZW50UG9zaXRpb24ueFxuICAgICYmIGNsaWNrUG9zaXRpb24ueCA8PSBlbGVtZW50UG9zaXRpb24ueCArIHNpZGVMZW5ndGhcbiAgICAmJiBjbGlja1Bvc2l0aW9uLnkgPj0gZWxlbWVudFBvc2l0aW9uLnlcbiAgICAmJiBjbGlja1Bvc2l0aW9uLnkgPD0gZWxlbWVudFBvc2l0aW9uLnkgKyBzaWRlTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8vIFRha2VzIGluIGEgcG9zaXRpb24gb2JqZWN0IChsb2NhdGlvbiBvZiB0aGUgY2xpY2spXG4vLyByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgaXMgYXQgdGhhdCBwb3NpdGlvblxuZnVuY3Rpb24gY2hlY2tDbGlja0xvY2F0aW9uKHBvc2l0aW9uKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB7fTtcbiAgICAvLyBMb29wcyB0aHJvdWdoIGFjdGl2ZU1vbnN0ZXJzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnYW1lLmFjdGl2ZU1vbnN0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjb21wYXJlUG9zaXRpb25zKHBvc2l0aW9uLCBnYW1lLmFjdGl2ZU1vbnN0ZXJzW2ldLnBvc2l0aW9uLCBcIm1vbnN0ZXJcIikpIHtcbiAgICAgICAgICAgIGVsZW1lbnQudHlwZSA9IFwibW9uc3RlclwiO1xuICAgICAgICAgICAgZWxlbWVudC5pZCA9IGdhbWUuYWN0aXZlTW9uc3RlcnNbaV0uaWQ7XG4gICAgICAgICAgICBlbGVtZW50LmluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbm90aGluZyB3YXMgZm91bmQsIGxvb3AgdGhyb3VnaCB0b3dlcnNcbiAgICBpZiAoZWxlbWVudC50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnYW1lLnRvd2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvbXBhcmVQb3NpdGlvbnMocG9zaXRpb24sIGdhbWUudG93ZXJzW2ldLnBvc2l0aW9uLCBcInRvd2VyXCIpKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC50eXBlID0gXCJ0b3dlclwiO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuaWQgPSBnYW1lLnRvd2Vyc1tpXS5pZDtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vIHRvd2VycyBvciBtb25zdGVycyBmb3VuZCByZXR1cm4gYSB0eXBlIG9mIG51bGxcbiAgICBpZiAoZWxlbWVudC50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWxlbWVudC50eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbn1cblxuLy8gR2V0IGluZm9ybWF0aW9uIGZyb20gdG93ZXJkYXRhLmpzXG5cbi8qID09PT09PT09PT0gVG93ZXIgQ2FyZCBDbGljayBhbmQgcGxhY2VtZW50cyA9PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8vIENsaWNrIGEgdG93ZXIgY2FyZCBhbmQgbWFrZSBcImFjdGl2ZVwiIHdoaWNoIGNhbiBiZSBwbGFjZWQgb24gVUkgZWxlbWVudFxuLy8gV2hpbGUgaXQgaXMgYWN0aXZlIC0gdXNlICNkeW5hbWljLm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24gLT4gdG8gU2VuZFxuLy8gaW5mb3JtYXRpb24gdG8gdGhlIGNhbnZhc1xuXG4vLyBzZXQgdXAgZXZlbnQgbGlzdGVuZXJzIGF0IHRoZSBzdGFydCB3aGljaCByZWZlcmVuY2UgZnVuY3Rpb25zIC0gdGhlc2UgZnVuY3Rpb25zIGRlcGVuZCBvbiB0aGUgc3RhdGUgb24gdGhlIGFwcGxpY2F0aW9uIHRvIGNvbnRyb2wgdGhlaXIgY29udHJvbCBmbG93XG52YXIgYWN0aXZlVG93ZXJTZWxlY3RlZCA9IG51bGw7XG52YXIgdG93ZXJDYXJkcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJ0b3dlci1jYXJkXCIpO1xudmFyIHRvd2VyQ2FyZExpc3QgPSBbXTtcblxuZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgY3NzQ2xhc3MpIHtcbiAgICBpZiAoZWxlbWVudC5jbGFzc05hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBjc3NDbGFzcztcbiAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSArPSBcIiBcIiArIGNzc0NsYXNzO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY3NzQ2xhc3MpIHtcbiAgICB2YXIgYXJyYXlPZkNsYXNzZXMgPSBlbGVtZW50LmNsYXNzTmFtZS5zcGxpdChcIiBcIik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBhcnJheU9mQ2xhc3Nlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgaWYgKGFycmF5T2ZDbGFzc2VzW2ldID09PSBjc3NDbGFzcykge1xuICAgICAgICAgICAgYXJyYXlPZkNsYXNzZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgaS0tOyBqLS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBhcnJheU9mQ2xhc3Nlcy5qb2luKFwiIFwiKTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5kZXgodG93ZXJOYW1lKSB7XG4gICAgcmV0dXJuIHRvd2VyQ2FyZExpc3QuaW5kZXhPZih0b3dlck5hbWUpO1xufVxuXG5mdW5jdGlvbiB0b3dlckNhcmRDbGljaygpIHtcblxuICAgIHZhciB0b3dlck5hbWUgPSB0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtdG93ZXJcIik7XG5cbiAgICBpZiAoL2Rpc2FibGVkL2kudGVzdCh0aGlzLmNsYXNzTmFtZSkpIHsgLy8gVG93ZXIgaXMgZGlzYWJsZWRcbiAgICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoYWN0aXZlVG93ZXJTZWxlY3RlZCA9PT0gbnVsbCkgeyAvLyBUaGVyZSBpcyBubyBhY3RpdmUgdG93ZXIgYmVpbmcgcGxhY2VkXG4gICAgICAgIC8vIHNldCB0aGUgYWN0aXZlIHRvd2VyIHNlbGVjdGVkIHRvIGJlIHRoZSB0b3dlciBuYW1lXG4gICAgICAgIC8vIFNldCB1cCBhY3RpdmUgZWxlbWVudHNcbiAgICAgICAgYWN0aXZlVG93ZXJTZWxlY3RlZCA9IHRvd2VyTmFtZTtcbiAgICAgICAgYWRkQ2xhc3ModG93ZXJDYXJkc1tnZXRJbmRleChhY3RpdmVUb3dlclNlbGVjdGVkKV0sIFwiYWN0aXZlXCIpO1xuICAgIH0gZWxzZSBpZiAoYWN0aXZlVG93ZXJTZWxlY3RlZCA9PT0gdG93ZXJOYW1lKSB7IC8vIFRoZSB0b3dlciBjYXJkIGNsaWNrZWQgaXMgdGhlIHNhbWUgYXMgdGhlIGFjdGl2ZSB0b3dlclxuICAgICAgICBjYW5jZWxUb3dlclBsYWNlbWVudCgpO1xuICAgIH0gZWxzZSB7IC8vIFRoZXJlIGlzIGFuIGFjdGl2ZSB0b3dlciB3aGljaCBpcyBub3QgdGhlIHNhbWUgYXMgd2hhdCB3YXMgY2xpY2tlZFxuICAgICAgICByZW1vdmVDbGFzcyh0b3dlckNhcmRzW2dldEluZGV4KGFjdGl2ZVRvd2VyU2VsZWN0ZWQpXSwgXCJhY3RpdmVcIik7XG4gICAgICAgIGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPSB0b3dlck5hbWU7XG4gICAgICAgIGFkZENsYXNzKHRvd2VyQ2FyZHNbZ2V0SW5kZXgoYWN0aXZlVG93ZXJTZWxlY3RlZCldLCBcImFjdGl2ZVwiKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG9uVG93ZXJNb3VzZU1vdmVtZW50KGUpIHtcbiAgICBpZiAoYWN0aXZlVG93ZXJTZWxlY3RlZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm5cbiAgICB9O1xuICAgIHZhciBjYW52YXNDb250YWluZXIgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBvZmZzZXRYID0gZS5jbGllbnRYIC0gY2FudmFzQ29udGFpbmVyLmxlZnQsXG4gICAgICAgIG9mZnNldFkgPSBlLmNsaWVudFkgLSBjYW52YXNDb250YWluZXIudG9wO1xuICAgIC8vIHNlbmQgdG8gZGlzcGxheSB0byBnZXQgcmVuZGVyZWRcbn07XG5cbi8vIFR3byBwb3NzaWJsZSBjYW52YXMgY2xpY2sgc2NlbmFyaW9zOlxuLy8gMSkgVG93ZXIgc2VsZWN0aW9uIGlzIGFjdGl2ZSAocGxhY2UgYSB0b3dlcilcbi8vIDIpIFRvd2VyIHNlbGVjdGlvbiBpcyBpbmFjdGl2ZSAoY2xpY2tpbmcgdG8gZ2V0IGluZm9ybWF0aW9uIGFib3V0IGEgbW9uc3RlciBvciB0b3dlciBvbiB0aGUgbWFwKVxuZnVuY3Rpb24gY2FudmFzQ2xpY2soZSkge1xuICAgIC8vIEdldCBjbGljayBsb2NhdGlvbiByZWxhdGl2ZSB0byB0aGUgY2FudmFzIGVsZW1lbnRcbiAgICB2YXIgY2FudmFzQ29udGFpbmVyID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICBwb3NpdGlvbiA9IHt9O1xuXG4gICAgcG9zaXRpb24ueCA9IGUuY2xpZW50WCAtIGNhbnZhc0NvbnRhaW5lci5sZWZ0O1xuICAgIHBvc2l0aW9uLnkgPSBlLmNsaWVudFkgLSBjYW52YXNDb250YWluZXIudG9wO1xuXG4gICAgaWYgKGFjdGl2ZVRvd2VyU2VsZWN0ZWQgIT09IG51bGwpIHsgLy9cbiAgICAgICAgdmFyIHRvd2VyTmFtZSA9IGFjdGl2ZVRvd2VyU2VsZWN0ZWQ7IC8vIE5PVEUgQ0hBTkdFIEdFVCBUT1dFUiBOQU1FIEZST00gTElTVFxuXG4gICAgICAgIGlmIChnYW1lLnZhbGlkYXRlVG93ZXJQbGFjZW1lbnQodG93ZXJOYW1lLCBwb3NpdGlvbikpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidG93ZXJQbGFjZWRcIik7XG4gICAgICAgICAgICBnYW1lLmFkZFRvd2VyKHRvd2VyTmFtZSwgcG9zaXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJpbnZhbGlkIHRvd2VyIHBsYWNlbWVudFwiKTtcbiAgICAgICAgICAgIC8vIHNob3cgZXJyb3IgbWVzc2FnZSBzb21ld2hlcmUgZm9yIHRoZSB1c2VyXG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlQ2xhc3ModG93ZXJDYXJkc1tnZXRJbmRleChhY3RpdmVUb3dlclNlbGVjdGVkKV0sIFwiYWN0aXZlXCIpO1xuICAgICAgICBhY3RpdmVUb3dlclNlbGVjdGVkID0gbnVsbDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBwb3NpdGlvbiBvdmVybGFwcyB3aXRoIHRoZSBib3VuZGluZyByZWN0YW5nbGUgb2YgbW9uc3RlciBvciB0b3dlclxuICAgICAgICB2YXIgZWxlbWVudCA9IGNoZWNrQ2xpY2tMb2NhdGlvbihwb3NpdGlvbik7XG4gICAgICAgIGNvbnNvbGUubG9nKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSBcIm1vbnN0ZXJcIikge1xuICAgICAgICAgICAgaW5mb05hbWUuaW5uZXJIVE1MID0gZWxlbWVudC5pZDtcblxuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQudHlwZSA9PT0gXCJ0b3dlclwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInNob3cgdG93ZXIgaW5mb3JtYXRpb25cIilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZm9OYW1lLmlubmVySFRNTCA9IFwiQXdlc29tZSBURFwiO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJzaG93IGRlZmF1bHQgaW5mb3JtYXRpb25cIilcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBpdCBpcywgY2hhbmdlIHRoZSBpbmZvcm1hdGlvbiBjb250YWluZXJcbiAgICB9XG5cbn1cblxuZnVuY3Rpb24gY2FuY2VsVG93ZXJQbGFjZW1lbnQoKSB7XG5cbiAgICByZW1vdmVDbGFzcyh0b3dlckNhcmRzW2dldEluZGV4KGFjdGl2ZVRvd2VyU2VsZWN0ZWQpXSwgXCJhY3RpdmVcIik7XG4gICAgYWN0aXZlVG93ZXJTZWxlY3RlZCA9IG51bGw7XG59XG5cblxuLy8gU2V0IHVwIGV2ZW50IGxpc3RlbmVyc1xuLy8gQ29udmVydCBmcm9tIG5vZGVsaXN0IHRvIGFycmF5XG50b3dlckNhcmRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodG93ZXJDYXJkcyk7XG5cbi8vIFRvd2VyIGNhcmQgY2xpY2sgZXZlbnQgbGlzdGVuZXJzXG50b3dlckNhcmRzLm1hcChmdW5jdGlvbih0b3dlckNhcmQsIGkpIHtcbiAgICB0b3dlckNhcmRMaXN0LnB1c2godG93ZXJDYXJkLmdldEF0dHJpYnV0ZShcImRhdGEtdG93ZXJcIikpO1xuICAgIHRvd2VyQ2FyZC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdG93ZXJDYXJkQ2xpY2spO1xufSk7XG5cbi8vIEdhbWUgY29udGFpbmVyIGV2ZW50IGxpc3RlbmVyc1xuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkeW5hbWljXCIpLm9ubW91c2Vtb3ZlID0gb25Ub3dlck1vdXNlTW92ZW1lbnQ7XG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImR5bmFtaWNcIikuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGNhbnZhc0NsaWNrKTtcblxuLy8gVG93ZXIgcGxhY2VtZW50IGNhbmNlbGxpbmcgZXZlbnQgbGlzdGVuZXJzXG5kb2N1bWVudC5vbmtleWRvd24gPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgICAgY2FuY2VsVG93ZXJQbGFjZW1lbnQoKTtcbiAgICB9XG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2pzL2ludGVyZmFjZS5qc1xuICoqIG1vZHVsZSBpZCA9IDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b3dlckRhdGEgPSByZXF1aXJlKFwiLi4vZ2FtZURhdGEvdG93ZXJkYXRhLmpzXCIpO1xuXG52YXIgVG93ZXIgPSBmdW5jdGlvbihwb3NpdGlvbiwgaWQpIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5kYW1hZ2UgPSB0b3dlckRhdGFbaWRdLmRhbWFnZTtcbiAgICB0aGlzLnNwZWVkID0gdG93ZXJEYXRhW2lkXS5zcGVlZDsgLy8gQXR0YWNrIHNwZWVkXG4gICAgdGhpcy5yYW5nZSA9IHRvd2VyRGF0YVtpZF0ucmFuZ2U7IC8vIFJhbmdlIG9mIHRoZSB0b3dlclxuICAgIHRoaXMudHlwZSA9IHRvd2VyRGF0YVtpZF0udHlwZTsgLy8gVHlwZSBvZiBkYW1hZ2VcbiAgICB0aGlzLmVmZmVjdCA9IHRvd2VyRGF0YVtpZF0uZWZmZWN0OyAvLyBTcGVjaWFsIGVmZmVjdCAoZS5nLiBzbG93LCBzcGxhc2gsIGV0YylcbiAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247IC8vIG9iamVjdCB3aXRoIHggYW5kIHkgY29vcmRpbmF0ZXMgLSBzaG91bGQgbm90IGNoYW5nZVxufVxuLy8gTWV0aG9kIHRoZSBnYW1lIG9iamVjdCB1c2VzIHRvIHJ1biB0b3dlcnNcblRvd2VyLnByb3RvdHlwZS5ydW5DeWNsZSA9IGZ1bmN0aW9uKCkge1xuXG59XG4vLyBjaGFuZ2UgdGhpcyB0byByZWZlcmVuY2UgYSBsaXN0IG9yIHNvbWV0aGluZyB3aGVyZSBhIG5hbWUgY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBwcm9wZXJ0aWVzXG4vLyBUYWtlcyBpbiBhIG1vbnN0ZXIncyBwb3NpdGlvbiBhbmQgY2hlY2tzIHdoZXRoZXIgdGhhdCBpcyBpbiByYW5nZSBiYXNlZCBvbiB0aGUgcmFuZ2UgLSByZXR1cm5zIHRydWUgb3IgZmFsc2UgaWYgaW4gcmFuZ2Ugd2hpY2ggY2FuIGJlIHVzZWQgdG9cblRvd2VyLnByb3RvdHlwZS5jaGVja0luUmFuZ2UgPSBmdW5jdGlvbihtb25zdGVyUG9zaXRpb24pIHtcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRvd2VyO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9qcy9jbGFzc2VzL1Rvd2VyLmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYmFzaWM6IHtcbiAgICAgICAgZGFtYWdlOiAxMCxcbiAgICAgICAgc3BlZWQ6IDEwLFxuICAgICAgICByYW5nZTogMTAwLFxuICAgICAgICB0eXBlOiBcImJhc2ljXCIsXG4gICAgICAgIGVmZmVjdDogXCJub25lXCJcbiAgICB9XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9qcy9nYW1lRGF0YS90b3dlcmRhdGEuanNcbiAqKiBtb2R1bGUgaWQgPSA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAgcmVxdWlyZSBNb25zdGVyIHRvIGdhaW4gYWNjZXNzXG52YXIgTW9uc3RlciA9IHJlcXVpcmUoXCIuL01vbnN0ZXIuanNcIik7XG5cbnZhciBHYW1lRW5naW5lID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy51c2VyR29sZCA9IDEwO1xuICAgIHRoaXMubGV2ZWwgPSAxO1xuICAgIHRoaXMudXNlckxpdmVzID0gMzA7XG4gICAgdGhpcy5hY3RpdmVNb25zdGVycyA9IFtdOyAvLyBMaXN0IG9mIGFjdGl2ZSBtb25zdGVycyBpbiB0aGVcbiAgICB0aGlzLnRvd2VycyA9IFtdOyAvLyBvYmplY3Qgb2YgdG93ZXIgb2JqZWN0c1xuICAgIHRoaXMudGltZXIgPSAxO1xuICAgIC8vIEdvZXMgdGhyb3VnaCBhbmQgZGlzYWJsZXMgdG93ZXJzIHRoYXQgY2FuJ3QgYmUgdXNlZCB5ZXRcbn1cblxuR2FtZUVuZ2luZS5wcm90b3R5cGUuYWRkTW9uc3RlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAvLyBhZGQgbW9uc3RlciAoc3BlY2lmaWVkIGJ5IG5hbWUpIHRvIGdhbWVcbiAgICB2YXIgbW9uc3RlciA9IG5ldyBNb25zdGVyKFwibW9uc3RlcjFcIik7XG4gICAgdGhpcy5hY3RpdmVNb25zdGVycy5wdXNoKG1vbnN0ZXIpO1xufVxuXG5HYW1lRW5naW5lLnByb3RvdHlwZS5hZGRUb3dlciA9IGZ1bmN0aW9uKG5hbWUsIHBvc2l0aW9uKSB7XG4gICAgLy8gYWRkIHRvd2VyIChzcGVjaWZpZWQgYnkgbmFtZSkgYXQgbG9jYXRpb25cbn1cblxuLy8gbWV0aG9kIHRvIGNoZWNrIGdvbGQgYmVmb3JlIHBsYWNlIHRvd2VyIG9yIHVwZ3JhZGVcbkdhbWVFbmdpbmUucHJvdG90eXBlLmNoZWNrR29sZCA9IGZ1bmN0aW9uKGdvbGRDb3N0KSB7XG4gICAgaWYgKGdvbGRDb3N0ID4gdGhpcy51c2VyR29sZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuR2FtZUVuZ2luZS5wcm90b3R5cGUuZ2FtZU92ZXIgPSBmdW5jdGlvbigpIHtcblxufVxuXG5HYW1lRW5naW5lLnByb3RvdHlwZS5nYW1lV29uID0gZnVuY3Rpb24oKSB7XG5cbn1cblxuLy8gTmV3IGxldmVsIG1ldGhvZFxuR2FtZUVuZ2luZS5wcm90b3R5cGUubmV4dExldmVsID0gZnVuY3Rpb24oKSB7XG5cbn1cblxuR2FtZUVuZ2luZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gc2VuZCBzdGF0ZSB0byB0aGUgZGlzcGxheSBvYmplY3QgdG8gcmVuZGVyXG4gICAgZHluYW1pY0NvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgZHluYW1pY0NvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGR5bmFtaWNDYW52YXMud2lkdGgsIGR5bmFtaWNDYW52YXMuaGVpZ2h0KTtcblxuICAgIC8vICBsb29wIHRocm91Z2ggbGlzdCBvZiBhY3RpdmUgbW9uc3RlcnMgYW5kIHJlbmRlciB0aGVtXG4gICAgLy8gIFRPRE8gcHJvYmFibHkgbmVlZCB0byBmaW5kIGEgYmV0dGVyIHdheSB0byByZW5kIHRoZW0gYXBhcnQgZnJvbSByYW5kb20gcmVjdGFuZ2xlXG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSB0aGlzLmFjdGl2ZU1vbnN0ZXJzLmxlbmd0aDsgaSA8IGo7IGkgKyspIHtcbiAgICAgICAgdGhpcy5hY3RpdmVNb25zdGVyc1tpXS5kcmF3KCk7XG4gICAgfVxuXG4gICAgLy8gZHluYW1pY0NvbnRleHQuXG59O1xuXG5HYW1lRW5naW5lLnByb3RvdHlwZS5ydW5DeWNsZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vICBiZWdpbm5pbmcgb2YgY3ljbGUgY2hlY2sgaWYgYW55IG1vbnN0ZXJzIGhhdmUgZGllZCBpZiBzbyByZW1vdmUgZnJvbSBhY3RpdmUgbW9uc3RlcnNcbiAgICB0aGlzLmNoZWNrTW9uc3RlckRlYXRoKCk7XG4gICAgLy8gbG9vcCB0aHJvdWdoIGFjdGl2ZSBtb25zdGVycyBhbmQgdG93ZXJzIGFuZCBydW4gdGhlIGN5Y2xlXG4gICAgLy8gRWFjaCBydW5DeWNsZSBtZXRob2QgcmV0dXJucyBpbmZvcm1hdGlvbiBmb3IgdGhlIGdhbWVFbmdpbmUgdG9cbiAgICAvLyBwcm9jZXNzIChlLmcuIHRoZSBtb25zdGVyIGRpZWQsIHRvd2VyIGNoYW5nZWQpXG5cbiAgICAvLyAgdGltZXIgdG8gYWRkIG1vbnN0ZXJzXG4gICAgdGhpcy50aW1lci0tO1xuICAgIGlmICh0aGlzLnRpbWVyIDwgMSkge1xuICAgICAgICB0aGlzLmFkZE1vbnN0ZXIoJ2JsYWgnKTtcbiAgICAgICAgdGhpcy50aW1lciA9IDEwO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuYWN0aXZlTW9uc3RlcnMubGVuZ3RoOyBpIDwgajsgaSArKykge1xuICAgICAgICB0aGlzLmFjdGl2ZU1vbnN0ZXJzW2ldLm1vdmUoKTtcbiAgICB9XG4gICAgLy8gU2VuZCBpbmZvcm1hdGlvbiB0byByZW5kZXJcbn1cblxuLy8gbWV0aG9kIHRvIHVwZ3JhZGUgdG93ZXJcblxuR2FtZUVuZ2luZS5wcm90b3R5cGUudmFsaWRhdGVUb3dlclBsYWNlbWVudCA9IGZ1bmN0aW9uKG5hbWUsIHBvc2l0aW9uKSB7XG4gICAgLy8gcmV0dXJucyB0cnVlIG9yIGZhbHNlIHdoZXRoZXIgdG93ZXIgcGxhY2VtZW50IGlzIHZhbGlkXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbkdhbWVFbmdpbmUucHJvdG90eXBlLmNoZWNrTW9uc3RlckRlYXRoID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSB0aGlzLmFjdGl2ZU1vbnN0ZXJzLmxlbmd0aDsgaSA8IGo7IGkgKyspIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlTW9uc3RlcnNbaV0uY2hlY2tEZWF0aCgpKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZU1vbnN0ZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gcmVkcmF3IGNhbnZhc1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdhbWVFbmdpbmU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2pzL2NsYXNzZXMvR2FtZS5qc1xuICoqIG1vZHVsZSBpZCA9IDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBtb25zdGVyRGF0YSA9IHJlcXVpcmUoXCIuLi9nYW1lRGF0YS9tb25zdGVyZGF0YS5qc1wiKTtcblxudmFyIE1vbnN0ZXIgPSBmdW5jdGlvbihpZCkge1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmN1cnJlbnRIcCA9IG1vbnN0ZXJEYXRhW2lkXS5tYXhIcDtcbiAgICB0aGlzLm1heEhwID0gbW9uc3RlckRhdGFbaWRdLm1heEhwO1xuICAgIHRoaXMuYmFzZU1zID0gbW9uc3RlckRhdGFbaWRdLmJhc2VNczsgLy8gTW92ZW1lbnQgc3BlZWQgLSBcInVuaXRzXCIgcGVyIHNlY29uZFxuICAgIHRoaXMudHlwZSA9IG1vbnN0ZXJEYXRhW2lkXS50eXBlO1xuICAgIHRoaXMucG9zaXRpb24gPSB7IC8vIEFsbCBtb25zdGVycyBhcmUgY3JlYXRlZCBpbiB0aGUgc2FtZSBwb3NpdGlvblxuICAgICAgICB4OiAwLFxuICAgICAgICB5OiA0ODVcbiAgICB9XG59O1xuLy8gTWV0aG9kIHRoZSBnYW1lIG9iamVjdCB1c2VzIHRvIG1vdmUgbW9uc3RlcnNcbk1vbnN0ZXIucHJvdG90eXBlLnJ1bkN5Y2xlID0gZnVuY3Rpb24oKSB7XG5cbn1cblxuTW9uc3Rlci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKCkge1xuICAgIGR5bmFtaWNDb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGR5bmFtaWNDb250ZXh0LnJlY3QodGhpcy5wb3NpdGlvbi54LCB0aGlzLnBvc2l0aW9uLnksIDMwLCAzMCk7XG4gICAgZHluYW1pY0NvbnRleHQuc3Ryb2tlKCk7XG4gICAgZHluYW1pY0NvbnRleHQuZmlsbFN0eWxlID0gXCJyZWRcIjtcbiAgICBkeW5hbWljQ29udGV4dC5maWxsUmVjdCh0aGlzLnBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi55ICsgMzAvMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzMCAqIHRoaXMuY3VycmVudEhwL3RoaXMubWF4SHAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMzAvMyk7XG59XG5cbk1vbnN0ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblxufTtcblxuTW9uc3Rlci5wcm90b3R5cGUuY2hlY2tEZWF0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRIcCA8PSAwO1xufTtcblxuLy8gRXhwZWN0cyB1cCwgZG93biwgbGVmdCBvciByaWdodFxuTW9uc3Rlci5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKGRpcmVjdGlvbikge1xuICAgIHZhciBzcGVlZCA9IHRoaXMuYmFzZU1zO1xuXG4gICAgLy8gc29tZSBiYXNpYyBtb25zdGVyIE1vdmVtZW50XG4gICAgLy8gIE5PVEUgc3VjaCBhIGhhc3NsZSB0byBmaWd1cmUgdGhpcyBvdXRcbiAgICAvLyAgVE9ETyBub3QgZmluaXNoZWQsIG5vdCBldmVuIGdvaW5nIHRvIHRyeSBhbmQgZmluaXNoIHdpbGwgZmlndXJlIG91dCBob3cgdGhpcyBzaG91bGQgd29yayBsYXRlclxuICAgIGlmICh0aGlzLnBvc2l0aW9uLnggPD0gNTAgJiYgdGhpcy5wb3NpdGlvbi55IDwgNTAwKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24ueCArPSBzcGVlZDtcbiAgICB9IGVsc2UgaWYgKHRoaXMucG9zaXRpb24ueCA+PSA1MCAmJiB0aGlzLnBvc2l0aW9uLnkgPj0gOTApIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi55IC09IHNwZWVkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wb3NpdGlvbi54IDw9IDE4MCAmJiB0aGlzLnBvc2l0aW9uLnkgPj0gODApIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi54ICs9IHNwZWVkO1xuICAgIH1cblxuICAgIC8vICBtYXkgbm90IGJlIHRoZSBiZXN0IHdheSB0byBkbyB0aGlzIGJ1dCBpbGwga2VlcCBpdCBiZWNhdXNlIG5vdCBldmVuIHN1cmUgaG93IHRvIGRvIHRoaXMgbW92ZW1lbnQgcGFydFxuICAgIC8vIGlmICh0eXBlb2YgZGlyZWN0aW9uICE9PSBcInN0cmluZ1wiKSB7XG4gICAgLy8gICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJkaXJlY3Rpb24gaXMgbm90IGEgc3RyaW5nXCIpO1xuICAgIC8vIH1cbiAgICAvLyBkaXJlY3Rpb24gPSBkaXJlY3Rpb24udG9Mb3dlckNhc2UoKTtcbiAgICAvLyBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgIC8vICAgICBjYXNlIFwidXBcIjpcbiAgICAvLyAgICAgY2FzZSBcImRvd25cIjpcbiAgICAvLyAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAvLyAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgLy8gICAgIGRlZmF1bHQ6XG4gICAgLy8gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRpcmVjdGlvblwiKTtcbiAgICAvLyB9XG59O1xuXG4vLyBDYW4gdGFrZSBpbiBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIG51bWJlclxuTW9uc3Rlci5wcm90b3R5cGUudXBkYXRlSHAgPSBmdW5jdGlvbihocENoYW5nZSkge1xuICAgIHRoaXMuY3VycmVudEhwICs9IGhwQ2hhbmdlO1xuXG4gICAgaWYgKHRoaXMuY3VycmVudEhwID4gdGhpcy5tYXhIcCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRIcCA9IHRoaXMubWF4SHA7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb25zdGVyO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9qcy9jbGFzc2VzL01vbnN0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtb25zdGVyMToge1xuICAgICAgICBtYXhIcDogMzAsXG4gICAgICAgIGJhc2VNczogMTAsXG4gICAgICAgIHR5cGU6IDEgLy8gQ2hhbmdlIHRoaXMgdHlwZSBsYXRlclxuICAgIH1cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2pzL2dhbWVEYXRhL21vbnN0ZXJkYXRhLmpzXG4gKiogbW9kdWxlIGlkID0gOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==