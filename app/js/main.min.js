/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/src/js/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	// Canvas
	__webpack_require__(2);
	
	// User interaction elements
	__webpack_require__(3);


/***/ },
/* 2 */
/***/ function(module, exports) {

	// background contains the static canvas elements
	var background = document.getElementById("static");
	var backgroundContext = background.getContext("2d");
	
	// Settings for the background - move out to a separate file
	var settings = {
	    backgroundColor: "#8CD1E6",
	    pathColor: "gray"
	}
	
	// Drawing the background
	backgroundContext.fillStyle = settings.backgroundColor;
	backgroundContext.fillRect(0, 0, background.width, background.height);
	
	/* Main path will go from [0, 500], [75, 500], [75, 100], [225, 100], [225, 500], [375, 500], [375, 100], [525, 100], [525, 500], [675, 500], [675, 100], [825, 100], [825, 500], [900, 500] */
	
	// Drawing the path - width of the path is 50px
	backgroundContext.fillStyle = settings.pathColor;
	
	backgroundContext.beginPath();
	
	// For the bottom part of the path
	backgroundContext.moveTo(0, 525);
	
	backgroundContext.lineTo(100, 525);
	backgroundContext.lineTo(100, 125); // Top
	backgroundContext.lineTo(200, 125);
	backgroundContext.lineTo(200, 525); // Bottom
	backgroundContext.lineTo(400, 525);
	backgroundContext.lineTo(400, 125); // Top
	backgroundContext.lineTo(500, 125);
	backgroundContext.lineTo(500, 525); // Bottom
	backgroundContext.lineTo(700, 525);
	backgroundContext.lineTo(700, 125); // Top
	backgroundContext.lineTo(800, 125);
	backgroundContext.lineTo(800, 525); // Bottom
	
	//Middle section to the side
	backgroundContext.lineTo(900, 525);
	backgroundContext.lineTo(900, 475);
	backgroundContext.lineTo(850, 475);
	
	// For the top part of the path
	backgroundContext.lineTo(850, 75);
	backgroundContext.lineTo(650, 75);
	backgroundContext.lineTo(650, 475);
	backgroundContext.lineTo(550, 475);
	backgroundContext.lineTo(550, 75);
	backgroundContext.lineTo(350, 75);
	backgroundContext.lineTo(350, 475);
	backgroundContext.lineTo(250, 475);
	backgroundContext.lineTo(250, 75);
	backgroundContext.lineTo(50, 75);
	backgroundContext.lineTo(50, 475);
	
	// End section
	backgroundContext.lineTo(0, 475);
	
	backgroundContext.fill();
	// backgroundContext.lineTo();
	
	// draw a grid (for development purposes)
	var width = 900, height = 600;
	// draw vertical lines
	for (var i = 0; i < width; i += 25) {
	    backgroundContext.moveTo(i, 0);
	    backgroundContext.lineTo(i, height);
	    backgroundContext.stroke();
	}
	// draw horizontal lines
	for (var i = 0; i < height; i += 25) {
	    backgroundContext.moveTo(0, i);
	    backgroundContext.lineTo(width, i);
	    backgroundContext.stroke();
	}


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	// Initiate all the components
	var Tower = __webpack_require__(4),
	    GameEngine = __webpack_require__(7);
	
	// Import and declare utility functions
	var utils = __webpack_require__(6);
	
	// Cache reused DOM elements
	var infoName = document.getElementById("info-name"),
	    infoIcon = document.getElementById("info-icon"),
	    infoBox1 = document.getElementById("info-box-1"),
	    infoBox2 = document.getElementById("info-box-2"),
	    infoBox3 = document.getElementById("info-box-3"),
	    infoBox4 = document.getElementById("info-box-4"),
	    levelInfo = document.getElementById("level"),
	    goldInfo = document.getElementById("gold"),
	    livesInfo = document.getElementById("lives");
	
	var towerCards = document.getElementsByClassName("tower-card"),
	    towerCardList = [];
	// Convert from nodelist to array
	towerCards = Array.prototype.slice.call(towerCards);
	
	/*
	Create state variables - These are modified on user interaction events
	State variables
	activeCanvasElement - Changed on a mouse click event on a monster, tower or nothing
	activeTowerSelected - The name of the tower that is being placed by the user
	activeMessage - Message displayed in the canvas (can be used for new levels, invalid tower placements, etc)
	canvasMousePosition -
	    onCanvas - boolean to represent whether the mouse is currently on the canvas
	    towerPosition - object with a grid value and coordinate value and sides
	        grid - the top left block of the tower being placed - towers are a 2x2 grid
	        coordinate - the top left corner coordinate
	        sides - 50 px
	    mousePosition - the current mouse coordinates
	*/
	
	var activeCanvasElement = {type: null},
	    activeTowerSelected = null,
	    activeMessage = {message: null},
	    canvasMousePosition = {
	        onCanvas: false,
	        towerPosition: {},
	        mousePosition: {}
	    };
	
	//  creates global variables
	game = new GameEngine;
	dynamicCanvas = document.getElementById('dynamic');
	dynamicContext = dynamicCanvas.getContext('2d');
	
	runCycle = function() {
	    game.runCycle();
	    updateGameInformation();
	    // I assume the game is going to run fast than this after? if not need to add updateGameInformation to a few other places
	    setTimeout(runCycle, 100);
	}
	
	renderCycle = function() {
	    game.render();
	    // Renders the information and error messages based on the state variables
	    renderTowerPlacement();
	    renderMessage();
	    requestAnimationFrame(renderCycle);
	}
	
	/* ================== Render functions =================*/
	/* =====================================================*/
	// Render functions run every game cycle (on the renderCycle function call)
	// Renders based on the state variables
	
	function updateGameInformation() {
	    livesInfo.innerHTML = game.userLives;
	    goldInfo.innerHTML = game.userGold;
	    levelInfo.innerHTML = game.level;
	
	    if (activeCanvasElement.type === "monster") {
	        renderMonsterInformation(activeCanvasElement.id, activeCanvasElement.index);
	    } else if (activeCanvasElement.type === "tower") {
	        renderTowerInformation(activeCanvasElement.id, activeCanvasElement.index);
	    } else {
	        renderDefaultInformation();
	    }
	}
	
	// ID refers to the type of monster and index is the index of the active monster in the active monster's array
	function renderMonsterInformation(id, index) {
	    // There will probably be a bug with the index somewhere when a mosnter is removed before this
	    var currentHp = game.activeMonsters[index].currentHp,
	        maxHp = game.activeMonsters[index].maxHp,
	        type = game.activeMonsters[index].type;
	    infoName.innerHTML = id;
	    // Change icon to active monster - use a sprite
	    infoBox1.innerHTML = "HP: " + currentHp + " / " + maxHp;
	    infoBox2.innerHTML = "Type: " + type;
	    infoBox3.innerHTML = "Strengths: All sorts mate" ;
	    infoBox4.innerHTML = "Weaknesses: Ducks" ;
	}
	
	// ID refers to the type of tower and index is the index of the active tower in the active tower's array
	function renderTowerInformation(id, index) {
	    infoName.innerHTML = id;
	    // Change icon to active monster - use a sprite
	    infoBox1.innerHTML = "Damage: <br> Range: <br> Effect: ";
	    infoBox2.innerHTML = "Attack Speed: <br> Type: " ;
	    infoBox3.innerHTML = "<a class='waves-effect waves-light btn red'>Upgrade</a>" ;
	    infoBox4.innerHTML = "<a class='waves-effect waves-light btn red'>Sell</a>" ;
	    // Change icon to tower monster - use a sprite
	
	}
	
	function renderDefaultInformation() {
	    infoName.innerHTML = "Awesome TD";
	    // Change icon to default image - use a sprite
	    infoBox1.innerHTML = "This is some text";
	    infoBox2.innerHTML = "This is different text";
	    infoBox3.innerHTML = "This is ??? text" ;
	    infoBox4.innerHTML = "This 1231241235" ;
	}
	
	// Maybe change this to "renderMessage"
	function renderMessage() {
	    if (activeMessage.message === null) {
	        return;
	    } else {
	        dynamicContext.globalAlpha = activeMessage.timer / 50;
	        dynamicContext.font = '40pt Droid Sans';
	        dynamicContext.textAlign = "center";
	        dynamicContext.fillStyle = "red";
	        dynamicContext.fillText(activeMessage.message, 450, 50);
	        dynamicContext.globalAlpha = 1;
	
	        if (activeMessage.timer === 0) {
	            activeMessage = {message: null}; // Reset error message
	        } else {
	            activeMessage.timer--;
	        }
	    }
	}
	
	function renderTowerPlacement() {
	    if (activeTowerSelected === null ||
	        !canvasMousePosition.onCanvas) {
	        return
	    };
	
	    var coordinates = canvasMousePosition.towerPosition.coordinates;
	    dynamicContext.beginPath();
	    dynamicContext.globalAlpha = 0.5;
	
	    if (game.validateTowerPlacement(canvasMousePosition.towerPosition.grid)) { // check for valid tower placement
	        dynamicContext.fillStyle = "green";
	    } else {
	        dynamicContext.fillStyle = "red";
	        // do some sort of logic to highlight the tiles that the tower would be placed on and show the tower on those positions
	        // this would run when tower placement is invalid
	    }
	    dynamicContext.fillRect(coordinates.x,
	                            coordinates.y,
	                            50,
	                            50
	     );
	
	    dynamicContext.globalAlpha = 0.7;
	    dynamicContext.arc(coordinates.x + 25,
	                       coordinates.y + 25,
	                       30,
	                       0,
	                       2 * Math.PI,
	                       false
	     );
	    dynamicContext.fillStyle = 'gray';
	    dynamicContext.fill();
	
	    dynamicContext.globalAlpha = 1;
	    dynamicContext.closePath();
	}
	
	/* ================ UI Event Listeners =================*/
	/* =====================================================*/
	document.getElementById("start-btn").addEventListener("click", function() {
	    // Hides the modal lightbox
	    document.getElementsByClassName("modal-content")[0].style.display = "none";
	    document.getElementsByClassName("modal-background")[0].style.display = "none";
	
	    // run repeating function that runs game engine run cycle and rendering
	    setTimeout(runCycle, 1000);
	    requestAnimationFrame(renderCycle);
	});
	
	// On clicking the information button, show the information panel
	document.getElementById("information-btn").addEventListener("click", function() {
	    // TODO - add information modal information thingy
	    console.log("show information container here");
	});
	
	/*
	These event listeners control the application by interacting with the game
	object and by changing the state variables (which the render functions use
	to read)
	*/
	towerCards.map(function(towerCard, i) {
	    towerCardList.push(towerCard.getAttribute("data-tower"));
	    towerCard.addEventListener("click", towerCardClick);
	});
	
	document.getElementById("dynamic").onmousemove = onCanvasMouseMovement;
	document.getElementById("dynamic").addEventListener("click", canvasClick);
	
	document.onkeydown = function(e) {
	    if (e.keyCode === 27) {
	        cancelTowerPlacement();
	    }
	}
	
	/* =================== UI Functions ====================*/
	/* =====================================================*/
	/* Click event listener on the tower cards
	Used to control what tower is being actively placed on the canvas
	4 possible flows based on the state of the interface
	1) The tower that was clicked is currently disabled:
	    -> function returns
	2) No towers are actively being placed
	    -> the clicked tower card now becomes the active tower being placed
	3) The clicked tower is the same as the tower actively being placed
	    -> the state is reset so that no towers are actively being placed
	4) The clicked tower is different from the tower actively being placed
	    -> the state is changed to the clicked tower becoming the active tower
	*/
	function towerCardClick() {
	
	    var towerName = this.getAttribute("data-tower"),
	        oldTowerIndex = towerCardList.indexOf(activeTowerSelected),
	        newTowerIndex = towerCardList.indexOf(towerName);
	
	    if (/disabled/i.test(this.className)) {
	        return;
	
	    } else if (activeTowerSelected === null) {
	        activeTowerSelected = towerName;
	        utils.addClass(towerCards[newTowerIndex], "active");
	        canvasMousePosition.onCanvas = false;
	    } else if (activeTowerSelected === towerName) {
	        cancelTowerPlacement();
	        canvasMousePosition.onCanvas = false;
	    } else {
	        utils.removeClass(towerCards[oldTowerIndex], "active");
	        activeTowerSelected = towerName;
	        utils.addClass(towerCards[newTowerIndex], "active");
	        canvasMousePosition.onCanvas = false;
	
	    }
	}
	
	/*
	Called from towerCardClick (when clicking the active tower card) and on an escape key press
	Resets the active tower placement state to null
	*/
	function cancelTowerPlacement() {
	    utils.removeClass(towerCards[towerCardList.indexOf(activeTowerSelected)], "active");
	    activeTowerSelected = null;
	}
	
	/* Mouse move event listener on the canvas
	If the active tower selected state (a tower is being placed by the user):
	    -> update the position of the mouse on the canvas (used by the renderTowerPlacement function)
	otherwise:
	    -> do nothing
	*/
	function onCanvasMouseMovement(e) {
	    if (activeTowerSelected === null) {
	        return
	    };
	
	    var canvasContainer = this.getBoundingClientRect(),
	        position = {};
	
	    position.x = e.clientX - canvasContainer.left;
	    position.y = e.clientY - canvasContainer.top;
	    canvasMousePosition.mousePosition = position;
	    canvasMousePosition.towerPosition = utils.convertPositionToTower(position);
	    canvasMousePosition.onCanvas = true;
	};
	
	
	/* Click event listener on the canvas
	Handles two possible canvas click scenarios
	1) A tower is selected and is actively being placed
	    -> Clicking will validate the tower placement and check the user's gold
	    if both are valid, will tower will be placed (by game object)
	    otherwise, an error message will show up
	2) A tower is not selected and is not being placed
	    -> Will check whether the click position overlaps with the bounding
	    rectangle of monster or tower - if so, it will return the information
	    in the information container
	*/
	function canvasClick(e) {
	    // Get click location relative to the canvas element
	    var canvasContainer = this.getBoundingClientRect(),
	        position = {},
	        towerGridPosition = canvasMousePosition.towerPosition.grid,
	        towerCoordinates = canvasMousePosition.towerPosition.coordinates; // Passes in grid blocks - this is the topLeft block
	
	    position.x = e.clientX - canvasContainer.left;
	    position.y = e.clientY - canvasContainer.top;
	
	    // Runs if the user is placing a tower
	    if (activeTowerSelected !== null) {
	        var towerName = activeTowerSelected,
	            towerPlaced = game.placeTower(towerName, towerGridPosition, towerCoordinates);
	
	        // If the tower was not placed, show an error message
	        if (!towerPlaced.placed) {
	            activeMessage = {
	                message: towerPlaced.message,
	                timer: 50 // frames
	            }
	        }
	
	        utils.removeClass(towerCards[towerCardList.indexOf(activeTowerSelected)], "active");
	        activeTowerSelected = null;
	    } else {
	        // User is not running a tower placement
	        activeCanvasElement = game.checkClickLocation(position);
	        updateGameInformation();
	    }
	
	}


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var towerData = __webpack_require__(5),
	    utils = __webpack_require__(6);
	
	// Position refers to the upper left corner of the elements
	// Tower width - 50 x 50
	var Tower = function(position, id) {
	    if (towerData[id] === undefined) {
	        throw new Error("Invalid tower name, check html dataattribute or towerdata")
	    }
	    this.id = id;
	    this.damage = towerData[id].damage;
	    this.speed = towerData[id].speed; // Attack speed
	    this.range = towerData[id].range; // Range of the tower
	    this.type = towerData[id].type; // Type of damage
	    this.effect = towerData[id].effect; // Special effect (e.g. slow, splash, etc)
	    this.goldCost = towerData[id].goldCost;
	    this.position = position; // object with x and y coordinates - references the top left corner of the tower
	    this.position.sideLength = 50;
	}
	// Method the game object uses to run towers
	Tower.prototype.runCycle = function() {
	
	}
	// change this to reference a list or something where a name can be used to determine the properties
	// Takes in a monster's position and checks whether that is in range based on the range - returns true or false if in range which can be used to
	Tower.prototype.checkInRange = function(monsterPosition) {
	    // using sqrt((x2-x1)^2 - (y2-y1)^2)
	    var monsterDistance = utils.getPositionDifference(monsterPosition, this.position);
	
	   if (monsterDistance <= this.range) {
	       return true;
	   } else {
	       return false;
	   }
	}
	
	Tower.prototype.draw = function() {
	    dynamicContext.beginPath();
	    dynamicContext.fillStyle = "green";
	    dynamicContext.fillRect(this.position.x,
	                            this.position.y,
	                            50,
	                            50);
	    dynamicContext.closePath();
	}
	
	module.exports = Tower;


/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = {
	    basic: {
	        damage: 10,
	        speed: 10,
	        range: 100,
	        goldCost: 10,
	        type: "basic",
	        effect: "none"
	    }
	};


/***/ },
/* 6 */
/***/ function(module, exports) {

	// Make this file great again!
	// This file needs tests and needs to be cleaned up (with comments and other useful stuff - cant be bothered at the moment)
	// probably can move the game specific grid generation things to the game file
	
	/* ================== Private functions ================*/
	/* =====================================================*/
	// TODO - add tests
	
	/* ================== Public functions =================*/
	/* =====================================================*/
	// Takes in a position object with coordinates{x, y}
	// returns a block object {x, y} with block numbers
	// Handles edge cases of the block being defined at the edge (36 and 24 which are invalid in the )
	function convertToBlock(position) {
	    if (position.x > (36*25) || position.y > (24*25)) {
	        console.log(position)
	        throw new Error("Position out of grid range");
	    }
	
	    var block = {
	        x: Math.floor(position.x / 25),
	        y: Math.floor(position.y / 25)
	    };
	    // Adjusts if mouse is at end of container
	    // 36 blocks width and 24 blocks height
	    if (block.x >= 35) {
	        block.x--;
	    }
	
	    if (block.y >= 23) {
	        block.y--;
	    }
	
	    return block;
	}
	
	function addClass(element, cssClass) {
	    if (element.className === "") {
	        element.className = cssClass;
	    } else {
	        element.className += " " + cssClass;
	    }
	}
	
	function removeClass(element, cssClass) {
	    var arrayOfClasses = element.className.split(" ");
	    for (var i = 0, j = arrayOfClasses.length; i < j; i++) {
	        if (arrayOfClasses[i] === cssClass) {
	            arrayOfClasses.splice(i, 1);
	            i--; j--;
	        }
	    }
	    element.className = arrayOfClasses.join(" ");
	}
	
	/*
	Takes in a position object (x and y coordinates)
	Returns the top left block position and topleft coordinate of the tower
	Grid blocks are in 25x25 block increments
	*/
	function convertPositionToTower(position) {
	    var towerPosition = {
	        grid: {},
	        coordinates: {},
	        side: 50
	    };
	
	    towerPosition.grid = convertToBlock(position);
	
	    // Container width and height 900 and 600 px respectively
	    towerPosition.coordinates.x = (towerPosition.grid.x / 36) * 900;
	    towerPosition.coordinates.y = (towerPosition.grid.y / 24) * 600;
	    return towerPosition;
	}
	
	/*
	checkIfInSquare checks whether a point is in a square (which is a monster or a tower)
	
	Takes in three arguments
	point - a object with x and y coordinates
	topLeftPoint - an object with x and y coordinates of the top left corner of the square
	sideLength - the length of the square
	
	Returns a boolean - true if the click overlaps with an element and false
	                    if it does not
	*/
	function checkIfInSquare(point, topLeftPoint, sideLength) {
	    if (point.x >= topLeftPoint.x
	    && point.x <= topLeftPoint.x + sideLength
	    && point.y >= topLeftPoint.y
	    && point.y <= topLeftPoint.y + sideLength) {
	        return true;
	    } else {
	        return false;
	    }
	}
	
	function getPositionDifference(position1, position2) {
	    return Math.sqrt(
	            Math.pow(position1.x-position2.x, 2) +
	            Math.pow(position1.y-position2.y, 2)
	    );
	}
	
	/*
	Takes in a distance (int) and pathLines(array of path objects) and converts it to coordinates for a monster
	
	Returns a coordinate object
	*/
	function convertDistanceToCoordinates(distance, pathLines) {
	    var coordinates,
	        end = false; // Boolean to represent whether the monster is at the end
	
	
	    for (var i = 0; i < pathLines.length; i ++) {
	        if (distance - pathLines[i].distance <= 0) {
	            break;
	        } else {
	            distance -= pathLines[i].distance;
	        }
	    }
	
	    if (i === pathLines.length) {
	        i--; // Set the counter value to be the last value in the pathlines array
	        distance =  pathLines[i].distance;
	        end = true;
	    }
	
	    // Create a new object to return (instead of modifiying startPoint object)
	    coordinates = Object.create(pathLines[i].startPoint);
	    coordinates.end = end;
	
	    // Case for when monster is at the end of the thingy - there is a better way to write this but not right now
	    if (!end) {
	        switch (pathLines[i].direction) {
	            // 15 is a half of the monster width
	            // values used to offset the positioning based on the monster direciton movement
	            case "up":
	            coordinates.x -= 15;
	            coordinates.y -= distance + 15;
	            break;
	            case "down":
	            coordinates.x -= 15;
	            coordinates.y += distance - 15;
	            break;
	            case "left":
	            coordinates.x -= distance + 15;
	            coordinates.y -= 15;
	            break;
	            case "right":
	            coordinates.x += distance - 15;
	            coordinates.y -= 15;
	            break;
	            default:
	            throw new Error("Invalid direction provided in pathLines");
	        }
	    } else {
	        switch (pathLines[i].direction) {
	            case "up":
	                coordinates.y -= pathLines[i].distance;
	                break;
	            case "down":
	                coordinates.y += pathLines[i].distance;
	                break;
	            case "left":
	                coordinates.x -= pathLines[i].distance;
	                break;
	            case "right":
	                coordinates.x += pathLines[i].distance;
	                break;
	            default:
	                throw new Error("Invalid direction provided in pathLines");
	        }
	
	    }
	
	    return coordinates
	}
	
	// Moved out to be able to test code
	module.exports = {
	    addClass: addClass,
	    removeClass: removeClass,
	    convertPositionToTower: convertPositionToTower,
	    checkIfInSquare: checkIfInSquare,
	    getPositionDifference: getPositionDifference,
	    convertToBlock: convertToBlock,
	    convertDistanceToCoordinates: convertDistanceToCoordinates
	}


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	//  require Monster to gain access
	var Monster = __webpack_require__(8),
	    Tower = __webpack_require__(4),
	    towerData = __webpack_require__(5),
	    utils = __webpack_require__(6),
	    pathCoordinates = __webpack_require__(10);
	
	var GameEngine = function() {
	    this.userGold = 10;
	    this.level = 1;
	    this.userLives = 30;
	    this.activeMonsters = []; // List of active monsters in the
	    this.towers = []; // object of tower objects
	    this.timer = 1;
	    this.gamePath = _convertPathToLines(pathCoordinates.path);
	    console.log(this.gamePath);
	    this.gameGrid = _initiateGrid(this.gamePath);
	    console.table(this.gameGrid)
	}
	
	GameEngine.prototype.addMonster = function(name) {
	    // add monster (specified by name) to game
	    var monster = new Monster("monster1");
	    this.activeMonsters.push(monster);
	}
	
	GameEngine.prototype.addTower = function(id, position, goldCost) {
	    this.userGold -= goldCost;
	    var tower = new Tower(position, id);
	    this.towers.push(tower);
	
	}
	
	/*
	Takes in a position object (location of the click)
	Returns an object with information about what is at that position
	{type: null} if nothing found
	*/
	GameEngine.prototype.checkClickLocation = function(position) {
	    var element = {};
	    // Loops through activeMonsters
	    for (var i = 0; i < this.activeMonsters.length; i++) {
	        if (utils.checkIfInSquare(position, this.activeMonsters[i].position, this.activeMonsters[i].sideLength)) {
	            element.type = "monster";
	            element.id = this.activeMonsters[i].id;
	            element.index = i;
	            break;
	        }
	    }
	
	    // If nothing was found, loop through towers
	    if (element.type === undefined) {
	        for (var i = 0; i < this.towers.length; i++) {
	            if (utils.checkIfInSquare(position, this.towers[i].position, this.towers[i].position.sideLength)) {
	                element.type = "tower";
	                element.id = this.towers[i].id;
	                element.index = i;
	                break;
	            }
	        }
	    }
	
	    // If no towers or monsters found return a type of null
	    if (element.type === undefined) {
	        element.type = null;
	    }
	
	    return element;
	}
	
	// method to check gold before place tower or upgrade
	GameEngine.prototype.checkGold = function(goldCost) {
	    if (goldCost <= this.userGold) {
	        return true;
	    } else {
	        return false;
	    }
	};
	
	GameEngine.prototype.checkMonsterDeath = function() {
	    for (var i = 0, j = this.activeMonsters.length; i < j; i ++) {
	        if (this.activeMonsters[i].checkDeath()) {
	            this.activeMonsters.splice(i, 1);
	            i--;
	            j--;
	        }
	    }
	}
	
	GameEngine.prototype.gameOver = function() {
	
	}
	
	GameEngine.prototype.gameWon = function() {
	
	}
	
	// New level method
	GameEngine.prototype.nextLevel = function() {
	
	}
	
	/*
	placeTower handles the validation of the tower placement (position and sufficient gold)
	Takes in 3 arguments:
	towerName - string specifying what tower is being placed
	gridPosition - top left grid block of where the tower would be placed
	towerCoordinates - top left coordinate of a tower
	Returns an object with a boolean to represent whether the tower is placed and an error message if the tower was not placed
	*/
	GameEngine.prototype.placeTower = function(towerName, gridPosition, towerCoordinates) {
	    var goldCost = towerData[towerName].goldCost;
	    // Validate tower placement
	    if (this.validateTowerPlacement(gridPosition)
	    && this.checkGold(goldCost)) {
	
	        this.addTower(towerName, towerCoordinates, goldCost);
	        return {
	            placed: true
	        };
	    } else {
	
	        if (!this.validateTowerPlacement(gridPosition)) {
	            return {
	                placed: false,
	                message: "Invalid Tower Placement"
	            }
	        } else {
	            return {
	                placed: false,
	                message: "Not Enough Gold"
	            }
	        }
	    }
	
	}
	
	GameEngine.prototype.render = function() {
	    // send state to the display object to render
	    dynamicContext.beginPath();
	    dynamicContext.clearRect(0, 0, dynamicCanvas.width, dynamicCanvas.height);
	
	    // Render towers first so that if monsters are larger they show above towers
	    for (var i = 0, j = this.towers.length; i < j; i ++) {
	        this.towers[i].draw();
	    }
	
	    //  loop through list of active monsters and render them
	    //  TODO probably need to find a better way to rend them apart from random rectangle
	    for (var i = 0, j = this.activeMonsters.length; i < j; i ++) {
	        this.activeMonsters[i].draw();
	    }
	
	    dynamicContext.closePath();
	
	    // dynamicContext.
	};
	
	GameEngine.prototype.runCycle = function() {
	    //  beginning of cycle check if any monsters have died if so remove from active monsters
	    this.checkMonsterDeath();
	    // loop through active monsters and towers and run the cycle
	    // Each runCycle method returns information for the gameEngine to
	    // process (e.g. the monster died, tower changed)
	
	    //  timer to add monsters
	    this.timer--;
	    if (this.timer < 1) {
	        this.addMonster('blah');
	        this.timer = 10;
	    }
	    for (var i = 0, j = this.activeMonsters.length; i < j; i ++) {
	        this.activeMonsters[i].move(this.gamePath);
	
	        // The monster is destroyed in the next cycle of runCycle in the monster.checkDeath value
	        if (this.activeMonsters[i].position.end) {
	            this.userLives--;
	        }
	    }
	    // Send information to render
	}
	
	// method to upgrade tower
	
	/*
	Takes in a gridPosition object (points to the top left corner of the tower)
	Towers take up a 2x2 grid - this function checks all positions
	Returns true if the position is a valid placement for a tower
	Returns false if the position is invalid
	*/
	GameEngine.prototype.validateTowerPlacement = function(gridPosition) {
	    // Checks all 4 positions
	    var positionValid = this.gameGrid[gridPosition.x][gridPosition.y].empty
	    && this.gameGrid[gridPosition.x + 1][gridPosition.y].empty
	    && this.gameGrid[gridPosition.x][gridPosition.y + 1].empty
	    && this.gameGrid[gridPosition.x + 1][gridPosition.y + 1].empty;
	    return positionValid;
	}
	
	/*
	Input: Path - an array of objects containing coordinates where the path will run to
	Output: pathLines - an array of objects containing the startPoint (coordinates),
	        distance of the line and direction (left, right, up, down)
	*/
	function _convertPathToLines(path) {
	    var pathLines = [];
	    for (var i = 0; i < path.length - 1; i++) {
	        var line = {};
	
	        // Assume that the direction is only 4 ways
	        if (path[i+1].x - path[i].x === 0) {
	
	            if (path[i+1].y - path[i].y > 0) {
	                line.direction = "down";
	            } else {
	                line.direction = "up";
	            }
	        } else {
	            if (path[i+1].x - path[i].x === 0 > 0) {
	
	                line.direction = "left";
	            } else {
	                line.direction = "right";
	            }
	        }
	        line.startPoint = path[i];
	        line.distance = utils.getPositionDifference(path[i], path[i+1]);
	        pathLines.push(line);
	    }
	
	    return pathLines;
	}
	
	/*
	Converts a pathLines array (an array of objects with a startPoint,
	direction and a distance) into an array of grid blocks ()
	Note that there will be some overlap with blocks, however,
	as they are only used to set grid positions to not empty, overlap is not an issue
	*/
	function _createPathBlocks(pathLines) {
	    var blocks = [];
	    // Loops through all the pathLines and creates blocks based on that
	    for (var i = 0; i < pathLines.length; i++) {
	        // blockAmount refers to the amount of blocks that follow the path
	        var blockAmount = Math.floor(pathLines[i].distance / 25) + 1,
	            pathDirection;
	        /* Set direction
	        x: 1 = right
	        x: -1 = left
	        y: 1 = down
	        y: -1 = up
	        Offset values help center the grid blocks (i.e. inline with the direction)
	        Side values are used to define which side the blocks are on relative to
	        the path direction (i.e. horizontally or vertically)
	        */
	        switch (pathLines[i].direction) {
	            case "up":
	                pathDirection = {
	                    x: 0,
	                    y: -1,
	                    xSide: 12.5,
	                    ySide: 0
	                }
	                break;
	            case "down":
	                pathDirection = {
	                    x: 0,
	                    y: 1,
	                    xSide: 12.5,
	                    ySide: 0
	                }
	                break;
	            case "left":
	                pathDirection = {
	                    x: -1,
	                    y: 0,
	                    xSide: 0,
	                    ySide: 12.5
	                }
	                break;
	            case "right":
	                pathDirection = {
	                    x: 1,
	                    y: 0,
	                    xSide: 0,
	                    ySide: 12.5
	                }
	                break;
	            default:
	                throw new Error("Invalid direction provided in pathLines");
	        }
	
	        /*
	        Creates block equal to double the amount of the blockAmount (the equivalent amount of blocks to the path distance)
	        blockBefore refers to blocks either to the left or top of the path
	        blockAfter refers to blocks either to the right or below of the path
	        Creates block locations and gives them offsets to their center positions (for clarity in converting to blocks)
	        */
	        for (var j = 0; j < blockAmount; j++) {
	
	            var blockBefore = {
	
	                x: pathLines[i].startPoint.x +
	                    pathDirection.xSide +
	                    (pathDirection.x * 25 * j),
	
	                y: pathLines[i].startPoint.y +
	                    pathDirection.ySide +
	                    (pathDirection.y * 25 * j )
	
	            },
	                blockAfter = {
	                    x: pathLines[i].startPoint.x +
	                        pathDirection.xSide +
	                        (pathDirection.x * 25 * j),
	
	                    y: pathLines[i].startPoint.y  +
	                        pathDirection.ySide +
	                        (pathDirection.y * 25 * j)
	            };
	            blocks.push(utils.convertToBlock(blockBefore));
	            blocks.push(utils.convertToBlock(blockAfter));
	        }
	
	
	    }
	
	    return blocks
	}
	
	// Grid is 36 by 24
	// can be initiated by [x][y] - each block has a boolean to represent whether something is there
	function _initiateGrid(pathLines) {
	    var grid = [],
	        blocks = _createPathBlocks(pathLines);
	    // Create the grid
	    for (var x = 0; x < 36; x++) {
	        grid[x] = [];
	        for (var y = 0; y < 24; y++) {
	            grid[x][y] = {
	                empty: true
	            };
	        }
	    }
	    // Loop through the blocks (which are on the path) and
	    blocks.map(function(block, i) {
	        grid[block.x][block.y] = {
	            empty: false
	        };
	    });
	
	    return grid;
	};
	
	module.exports = GameEngine;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var monsterData = __webpack_require__(9),
	    utils = __webpack_require__(6);
	
	var Monster = function(id) {
	    this.id = id;
	    this.currentHp = monsterData[id].maxHp;
	    this.maxHp = monsterData[id].maxHp;
	    this.baseMs = monsterData[id].baseMs; // Movement speed - "units" per second
	    this.type = monsterData[id].type;
	    this.distanceTravelled = 0;
	    this.position = {}; // Initial position is defined by the path
	    this.sideLength = 30;
	};
	// Method the game object uses to move monsters
	Monster.prototype.runCycle = function() {
	
	}
	
	Monster.prototype.draw = function() {
	    dynamicContext.beginPath();
	    dynamicContext.rect(this.position.x, this.position.y, 30, 30);
	    dynamicContext.stroke();
	    dynamicContext.fillStyle = "red";
	    dynamicContext.fillRect(this.position.x,
	                            this.position.y + 30/3,
	                            30 * this.currentHp/this.maxHp,
	                            30/3);
	    dynamicContext.closePath();
	
	}
	
	Monster.prototype.destroy = function() {
	
	};
	
	Monster.prototype.checkDeath = function() {
	    return this.currentHp <= 0 || this.position.end;
	};
	
	Monster.prototype.move = function(pathLines) {
	    this.distanceTravelled += this.baseMs;
	    this.position = utils.convertDistanceToCoordinates(this.distanceTravelled, pathLines);
	};
	
	// Can take in a positive or negative number
	Monster.prototype.updateHp = function(hpChange) {
	    this.currentHp += hpChange;
	
	    if (this.currentHp > this.maxHp) {
	        this.currentHp = this.maxHp;
	    }
	};
	
	module.exports = Monster;


/***/ },
/* 9 */
/***/ function(module, exports) {

	module.exports = {
	    monster1: {
	        maxHp: 30,
	        baseMs: 10,
	        type: 1 // Change this type later
	    }
	};


/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = {
	    path: [
	        {x: 0, y: 500},
	        {x: 75, y: 500},
	        {x: 75, y: 100},
	        {x: 225, y: 100},
	        {x: 225, y: 500},
	        {x: 375, y: 500},
	        {x: 375, y: 100},
	        {x: 525, y: 100},
	        {x: 525, y: 500},
	        {x: 675, y: 500},
	        {x: 675, y: 100},
	        {x: 825, y: 100},
	        {x: 825, y: 500},
	        {x: 900, y: 500}
	    ]
	}


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYjQ3OWE3YjRiMjYxMjE1MmI3ZjMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2VudHJ5LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9iYWNrZ3JvdW5kLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NsYXNzZXMvVG93ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2dhbWVEYXRhL3Rvd2VyZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NsYXNzZXMvR2FtZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY2xhc3Nlcy9Nb25zdGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9nYW1lRGF0YS9tb25zdGVyZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZ2FtZURhdGEvcGF0aGRhdGEuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQSxvQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUEyQixXQUFXO0FBQ3RDO0FBQ0Esc0JBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBNkIsZUFBZTtBQUM1QyxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0VBQThFO0FBQzlFO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBLDBFQUF5RTs7QUFFekU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDeFVB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eEIsVUFBUztBQUNUO0FBQ0EiLCJmaWxlIjoibWFpbi5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvc3JjL2pzL1wiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgYjQ3OWE3YjRiMjYxMjE1MmI3ZjNcbiAqKi8iLCIvLyBDYW52YXNcbnJlcXVpcmUoXCIuL2JhY2tncm91bmQuanNcIik7XG5cbi8vIFVzZXIgaW50ZXJhY3Rpb24gZWxlbWVudHNcbnJlcXVpcmUoXCIuL2ludGVyZmFjZS5qc1wiKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvZW50cnkuanNcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBiYWNrZ3JvdW5kIGNvbnRhaW5zIHRoZSBzdGF0aWMgY2FudmFzIGVsZW1lbnRzXG52YXIgYmFja2dyb3VuZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RhdGljXCIpO1xudmFyIGJhY2tncm91bmRDb250ZXh0ID0gYmFja2dyb3VuZC5nZXRDb250ZXh0KFwiMmRcIik7XG5cbi8vIFNldHRpbmdzIGZvciB0aGUgYmFja2dyb3VuZCAtIG1vdmUgb3V0IHRvIGEgc2VwYXJhdGUgZmlsZVxudmFyIHNldHRpbmdzID0ge1xuICAgIGJhY2tncm91bmRDb2xvcjogXCIjOENEMUU2XCIsXG4gICAgcGF0aENvbG9yOiBcImdyYXlcIlxufVxuXG4vLyBEcmF3aW5nIHRoZSBiYWNrZ3JvdW5kXG5iYWNrZ3JvdW5kQ29udGV4dC5maWxsU3R5bGUgPSBzZXR0aW5ncy5iYWNrZ3JvdW5kQ29sb3I7XG5iYWNrZ3JvdW5kQ29udGV4dC5maWxsUmVjdCgwLCAwLCBiYWNrZ3JvdW5kLndpZHRoLCBiYWNrZ3JvdW5kLmhlaWdodCk7XG5cbi8qIE1haW4gcGF0aCB3aWxsIGdvIGZyb20gWzAsIDUwMF0sIFs3NSwgNTAwXSwgWzc1LCAxMDBdLCBbMjI1LCAxMDBdLCBbMjI1LCA1MDBdLCBbMzc1LCA1MDBdLCBbMzc1LCAxMDBdLCBbNTI1LCAxMDBdLCBbNTI1LCA1MDBdLCBbNjc1LCA1MDBdLCBbNjc1LCAxMDBdLCBbODI1LCAxMDBdLCBbODI1LCA1MDBdLCBbOTAwLCA1MDBdICovXG5cbi8vIERyYXdpbmcgdGhlIHBhdGggLSB3aWR0aCBvZiB0aGUgcGF0aCBpcyA1MHB4XG5iYWNrZ3JvdW5kQ29udGV4dC5maWxsU3R5bGUgPSBzZXR0aW5ncy5wYXRoQ29sb3I7XG5cbmJhY2tncm91bmRDb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4vLyBGb3IgdGhlIGJvdHRvbSBwYXJ0IG9mIHRoZSBwYXRoXG5iYWNrZ3JvdW5kQ29udGV4dC5tb3ZlVG8oMCwgNTI1KTtcblxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDEwMCwgNTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygxMDAsIDEyNSk7IC8vIFRvcFxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDIwMCwgMTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygyMDAsIDUyNSk7IC8vIEJvdHRvbVxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDQwMCwgNTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg0MDAsIDEyNSk7IC8vIFRvcFxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDUwMCwgMTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg1MDAsIDUyNSk7IC8vIEJvdHRvbVxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDcwMCwgNTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg3MDAsIDEyNSk7IC8vIFRvcFxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDgwMCwgMTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg4MDAsIDUyNSk7IC8vIEJvdHRvbVxuXG4vL01pZGRsZSBzZWN0aW9uIHRvIHRoZSBzaWRlXG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oOTAwLCA1MjUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDkwMCwgNDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg4NTAsIDQ3NSk7XG5cbi8vIEZvciB0aGUgdG9wIHBhcnQgb2YgdGhlIHBhdGhcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg4NTAsIDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg2NTAsIDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg2NTAsIDQ3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNTUwLCA0NzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDU1MCwgNzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDM1MCwgNzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDM1MCwgNDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygyNTAsIDQ3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oMjUwLCA3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNTAsIDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg1MCwgNDc1KTtcblxuLy8gRW5kIHNlY3Rpb25cbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygwLCA0NzUpO1xuXG5iYWNrZ3JvdW5kQ29udGV4dC5maWxsKCk7XG4vLyBiYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oKTtcblxuLy8gZHJhdyBhIGdyaWQgKGZvciBkZXZlbG9wbWVudCBwdXJwb3NlcylcbnZhciB3aWR0aCA9IDkwMCwgaGVpZ2h0ID0gNjAwO1xuLy8gZHJhdyB2ZXJ0aWNhbCBsaW5lc1xuZm9yICh2YXIgaSA9IDA7IGkgPCB3aWR0aDsgaSArPSAyNSkge1xuICAgIGJhY2tncm91bmRDb250ZXh0Lm1vdmVUbyhpLCAwKTtcbiAgICBiYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oaSwgaGVpZ2h0KTtcbiAgICBiYWNrZ3JvdW5kQ29udGV4dC5zdHJva2UoKTtcbn1cbi8vIGRyYXcgaG9yaXpvbnRhbCBsaW5lc1xuZm9yICh2YXIgaSA9IDA7IGkgPCBoZWlnaHQ7IGkgKz0gMjUpIHtcbiAgICBiYWNrZ3JvdW5kQ29udGV4dC5tb3ZlVG8oMCwgaSk7XG4gICAgYmFja2dyb3VuZENvbnRleHQubGluZVRvKHdpZHRoLCBpKTtcbiAgICBiYWNrZ3JvdW5kQ29udGV4dC5zdHJva2UoKTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvYmFja2dyb3VuZC5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIEluaXRpYXRlIGFsbCB0aGUgY29tcG9uZW50c1xudmFyIFRvd2VyID0gcmVxdWlyZShcIi4vY2xhc3Nlcy9Ub3dlci5qc1wiKSxcbiAgICBHYW1lRW5naW5lID0gcmVxdWlyZShcIi4vY2xhc3Nlcy9HYW1lLmpzXCIpO1xuXG4vLyBJbXBvcnQgYW5kIGRlY2xhcmUgdXRpbGl0eSBmdW5jdGlvbnNcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuXG4vLyBDYWNoZSByZXVzZWQgRE9NIGVsZW1lbnRzXG52YXIgaW5mb05hbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImluZm8tbmFtZVwiKSxcbiAgICBpbmZvSWNvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5mby1pY29uXCIpLFxuICAgIGluZm9Cb3gxID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbmZvLWJveC0xXCIpLFxuICAgIGluZm9Cb3gyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbmZvLWJveC0yXCIpLFxuICAgIGluZm9Cb3gzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbmZvLWJveC0zXCIpLFxuICAgIGluZm9Cb3g0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbmZvLWJveC00XCIpLFxuICAgIGxldmVsSW5mbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibGV2ZWxcIiksXG4gICAgZ29sZEluZm8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImdvbGRcIiksXG4gICAgbGl2ZXNJbmZvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsaXZlc1wiKTtcblxudmFyIHRvd2VyQ2FyZHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwidG93ZXItY2FyZFwiKSxcbiAgICB0b3dlckNhcmRMaXN0ID0gW107XG4vLyBDb252ZXJ0IGZyb20gbm9kZWxpc3QgdG8gYXJyYXlcbnRvd2VyQ2FyZHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0b3dlckNhcmRzKTtcblxuLypcbkNyZWF0ZSBzdGF0ZSB2YXJpYWJsZXMgLSBUaGVzZSBhcmUgbW9kaWZpZWQgb24gdXNlciBpbnRlcmFjdGlvbiBldmVudHNcblN0YXRlIHZhcmlhYmxlc1xuYWN0aXZlQ2FudmFzRWxlbWVudCAtIENoYW5nZWQgb24gYSBtb3VzZSBjbGljayBldmVudCBvbiBhIG1vbnN0ZXIsIHRvd2VyIG9yIG5vdGhpbmdcbmFjdGl2ZVRvd2VyU2VsZWN0ZWQgLSBUaGUgbmFtZSBvZiB0aGUgdG93ZXIgdGhhdCBpcyBiZWluZyBwbGFjZWQgYnkgdGhlIHVzZXJcbmFjdGl2ZU1lc3NhZ2UgLSBNZXNzYWdlIGRpc3BsYXllZCBpbiB0aGUgY2FudmFzIChjYW4gYmUgdXNlZCBmb3IgbmV3IGxldmVscywgaW52YWxpZCB0b3dlciBwbGFjZW1lbnRzLCBldGMpXG5jYW52YXNNb3VzZVBvc2l0aW9uIC1cbiAgICBvbkNhbnZhcyAtIGJvb2xlYW4gdG8gcmVwcmVzZW50IHdoZXRoZXIgdGhlIG1vdXNlIGlzIGN1cnJlbnRseSBvbiB0aGUgY2FudmFzXG4gICAgdG93ZXJQb3NpdGlvbiAtIG9iamVjdCB3aXRoIGEgZ3JpZCB2YWx1ZSBhbmQgY29vcmRpbmF0ZSB2YWx1ZSBhbmQgc2lkZXNcbiAgICAgICAgZ3JpZCAtIHRoZSB0b3AgbGVmdCBibG9jayBvZiB0aGUgdG93ZXIgYmVpbmcgcGxhY2VkIC0gdG93ZXJzIGFyZSBhIDJ4MiBncmlkXG4gICAgICAgIGNvb3JkaW5hdGUgLSB0aGUgdG9wIGxlZnQgY29ybmVyIGNvb3JkaW5hdGVcbiAgICAgICAgc2lkZXMgLSA1MCBweFxuICAgIG1vdXNlUG9zaXRpb24gLSB0aGUgY3VycmVudCBtb3VzZSBjb29yZGluYXRlc1xuKi9cblxudmFyIGFjdGl2ZUNhbnZhc0VsZW1lbnQgPSB7dHlwZTogbnVsbH0sXG4gICAgYWN0aXZlVG93ZXJTZWxlY3RlZCA9IG51bGwsXG4gICAgYWN0aXZlTWVzc2FnZSA9IHttZXNzYWdlOiBudWxsfSxcbiAgICBjYW52YXNNb3VzZVBvc2l0aW9uID0ge1xuICAgICAgICBvbkNhbnZhczogZmFsc2UsXG4gICAgICAgIHRvd2VyUG9zaXRpb246IHt9LFxuICAgICAgICBtb3VzZVBvc2l0aW9uOiB7fVxuICAgIH07XG5cbi8vICBjcmVhdGVzIGdsb2JhbCB2YXJpYWJsZXNcbmdhbWUgPSBuZXcgR2FtZUVuZ2luZTtcbmR5bmFtaWNDYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZHluYW1pYycpO1xuZHluYW1pY0NvbnRleHQgPSBkeW5hbWljQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbnJ1bkN5Y2xlID0gZnVuY3Rpb24oKSB7XG4gICAgZ2FtZS5ydW5DeWNsZSgpO1xuICAgIHVwZGF0ZUdhbWVJbmZvcm1hdGlvbigpO1xuICAgIC8vIEkgYXNzdW1lIHRoZSBnYW1lIGlzIGdvaW5nIHRvIHJ1biBmYXN0IHRoYW4gdGhpcyBhZnRlcj8gaWYgbm90IG5lZWQgdG8gYWRkIHVwZGF0ZUdhbWVJbmZvcm1hdGlvbiB0byBhIGZldyBvdGhlciBwbGFjZXNcbiAgICBzZXRUaW1lb3V0KHJ1bkN5Y2xlLCAxMDApO1xufVxuXG5yZW5kZXJDeWNsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGdhbWUucmVuZGVyKCk7XG4gICAgLy8gUmVuZGVycyB0aGUgaW5mb3JtYXRpb24gYW5kIGVycm9yIG1lc3NhZ2VzIGJhc2VkIG9uIHRoZSBzdGF0ZSB2YXJpYWJsZXNcbiAgICByZW5kZXJUb3dlclBsYWNlbWVudCgpO1xuICAgIHJlbmRlck1lc3NhZ2UoKTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyQ3ljbGUpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT0gUmVuZGVyIGZ1bmN0aW9ucyA9PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vLyBSZW5kZXIgZnVuY3Rpb25zIHJ1biBldmVyeSBnYW1lIGN5Y2xlIChvbiB0aGUgcmVuZGVyQ3ljbGUgZnVuY3Rpb24gY2FsbClcbi8vIFJlbmRlcnMgYmFzZWQgb24gdGhlIHN0YXRlIHZhcmlhYmxlc1xuXG5mdW5jdGlvbiB1cGRhdGVHYW1lSW5mb3JtYXRpb24oKSB7XG4gICAgbGl2ZXNJbmZvLmlubmVySFRNTCA9IGdhbWUudXNlckxpdmVzO1xuICAgIGdvbGRJbmZvLmlubmVySFRNTCA9IGdhbWUudXNlckdvbGQ7XG4gICAgbGV2ZWxJbmZvLmlubmVySFRNTCA9IGdhbWUubGV2ZWw7XG5cbiAgICBpZiAoYWN0aXZlQ2FudmFzRWxlbWVudC50eXBlID09PSBcIm1vbnN0ZXJcIikge1xuICAgICAgICByZW5kZXJNb25zdGVySW5mb3JtYXRpb24oYWN0aXZlQ2FudmFzRWxlbWVudC5pZCwgYWN0aXZlQ2FudmFzRWxlbWVudC5pbmRleCk7XG4gICAgfSBlbHNlIGlmIChhY3RpdmVDYW52YXNFbGVtZW50LnR5cGUgPT09IFwidG93ZXJcIikge1xuICAgICAgICByZW5kZXJUb3dlckluZm9ybWF0aW9uKGFjdGl2ZUNhbnZhc0VsZW1lbnQuaWQsIGFjdGl2ZUNhbnZhc0VsZW1lbnQuaW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbmRlckRlZmF1bHRJbmZvcm1hdGlvbigpO1xuICAgIH1cbn1cblxuLy8gSUQgcmVmZXJzIHRvIHRoZSB0eXBlIG9mIG1vbnN0ZXIgYW5kIGluZGV4IGlzIHRoZSBpbmRleCBvZiB0aGUgYWN0aXZlIG1vbnN0ZXIgaW4gdGhlIGFjdGl2ZSBtb25zdGVyJ3MgYXJyYXlcbmZ1bmN0aW9uIHJlbmRlck1vbnN0ZXJJbmZvcm1hdGlvbihpZCwgaW5kZXgpIHtcbiAgICAvLyBUaGVyZSB3aWxsIHByb2JhYmx5IGJlIGEgYnVnIHdpdGggdGhlIGluZGV4IHNvbWV3aGVyZSB3aGVuIGEgbW9zbnRlciBpcyByZW1vdmVkIGJlZm9yZSB0aGlzXG4gICAgdmFyIGN1cnJlbnRIcCA9IGdhbWUuYWN0aXZlTW9uc3RlcnNbaW5kZXhdLmN1cnJlbnRIcCxcbiAgICAgICAgbWF4SHAgPSBnYW1lLmFjdGl2ZU1vbnN0ZXJzW2luZGV4XS5tYXhIcCxcbiAgICAgICAgdHlwZSA9IGdhbWUuYWN0aXZlTW9uc3RlcnNbaW5kZXhdLnR5cGU7XG4gICAgaW5mb05hbWUuaW5uZXJIVE1MID0gaWQ7XG4gICAgLy8gQ2hhbmdlIGljb24gdG8gYWN0aXZlIG1vbnN0ZXIgLSB1c2UgYSBzcHJpdGVcbiAgICBpbmZvQm94MS5pbm5lckhUTUwgPSBcIkhQOiBcIiArIGN1cnJlbnRIcCArIFwiIC8gXCIgKyBtYXhIcDtcbiAgICBpbmZvQm94Mi5pbm5lckhUTUwgPSBcIlR5cGU6IFwiICsgdHlwZTtcbiAgICBpbmZvQm94My5pbm5lckhUTUwgPSBcIlN0cmVuZ3RoczogQWxsIHNvcnRzIG1hdGVcIiA7XG4gICAgaW5mb0JveDQuaW5uZXJIVE1MID0gXCJXZWFrbmVzc2VzOiBEdWNrc1wiIDtcbn1cblxuLy8gSUQgcmVmZXJzIHRvIHRoZSB0eXBlIG9mIHRvd2VyIGFuZCBpbmRleCBpcyB0aGUgaW5kZXggb2YgdGhlIGFjdGl2ZSB0b3dlciBpbiB0aGUgYWN0aXZlIHRvd2VyJ3MgYXJyYXlcbmZ1bmN0aW9uIHJlbmRlclRvd2VySW5mb3JtYXRpb24oaWQsIGluZGV4KSB7XG4gICAgaW5mb05hbWUuaW5uZXJIVE1MID0gaWQ7XG4gICAgLy8gQ2hhbmdlIGljb24gdG8gYWN0aXZlIG1vbnN0ZXIgLSB1c2UgYSBzcHJpdGVcbiAgICBpbmZvQm94MS5pbm5lckhUTUwgPSBcIkRhbWFnZTogPGJyPiBSYW5nZTogPGJyPiBFZmZlY3Q6IFwiO1xuICAgIGluZm9Cb3gyLmlubmVySFRNTCA9IFwiQXR0YWNrIFNwZWVkOiA8YnI+IFR5cGU6IFwiIDtcbiAgICBpbmZvQm94My5pbm5lckhUTUwgPSBcIjxhIGNsYXNzPSd3YXZlcy1lZmZlY3Qgd2F2ZXMtbGlnaHQgYnRuIHJlZCc+VXBncmFkZTwvYT5cIiA7XG4gICAgaW5mb0JveDQuaW5uZXJIVE1MID0gXCI8YSBjbGFzcz0nd2F2ZXMtZWZmZWN0IHdhdmVzLWxpZ2h0IGJ0biByZWQnPlNlbGw8L2E+XCIgO1xuICAgIC8vIENoYW5nZSBpY29uIHRvIHRvd2VyIG1vbnN0ZXIgLSB1c2UgYSBzcHJpdGVcblxufVxuXG5mdW5jdGlvbiByZW5kZXJEZWZhdWx0SW5mb3JtYXRpb24oKSB7XG4gICAgaW5mb05hbWUuaW5uZXJIVE1MID0gXCJBd2Vzb21lIFREXCI7XG4gICAgLy8gQ2hhbmdlIGljb24gdG8gZGVmYXVsdCBpbWFnZSAtIHVzZSBhIHNwcml0ZVxuICAgIGluZm9Cb3gxLmlubmVySFRNTCA9IFwiVGhpcyBpcyBzb21lIHRleHRcIjtcbiAgICBpbmZvQm94Mi5pbm5lckhUTUwgPSBcIlRoaXMgaXMgZGlmZmVyZW50IHRleHRcIjtcbiAgICBpbmZvQm94My5pbm5lckhUTUwgPSBcIlRoaXMgaXMgPz8/IHRleHRcIiA7XG4gICAgaW5mb0JveDQuaW5uZXJIVE1MID0gXCJUaGlzIDEyMzEyNDEyMzVcIiA7XG59XG5cbi8vIE1heWJlIGNoYW5nZSB0aGlzIHRvIFwicmVuZGVyTWVzc2FnZVwiXG5mdW5jdGlvbiByZW5kZXJNZXNzYWdlKCkge1xuICAgIGlmIChhY3RpdmVNZXNzYWdlLm1lc3NhZ2UgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGR5bmFtaWNDb250ZXh0Lmdsb2JhbEFscGhhID0gYWN0aXZlTWVzc2FnZS50aW1lciAvIDUwO1xuICAgICAgICBkeW5hbWljQ29udGV4dC5mb250ID0gJzQwcHQgRHJvaWQgU2Fucyc7XG4gICAgICAgIGR5bmFtaWNDb250ZXh0LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIGR5bmFtaWNDb250ZXh0LmZpbGxTdHlsZSA9IFwicmVkXCI7XG4gICAgICAgIGR5bmFtaWNDb250ZXh0LmZpbGxUZXh0KGFjdGl2ZU1lc3NhZ2UubWVzc2FnZSwgNDUwLCA1MCk7XG4gICAgICAgIGR5bmFtaWNDb250ZXh0Lmdsb2JhbEFscGhhID0gMTtcblxuICAgICAgICBpZiAoYWN0aXZlTWVzc2FnZS50aW1lciA9PT0gMCkge1xuICAgICAgICAgICAgYWN0aXZlTWVzc2FnZSA9IHttZXNzYWdlOiBudWxsfTsgLy8gUmVzZXQgZXJyb3IgbWVzc2FnZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWN0aXZlTWVzc2FnZS50aW1lci0tO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJUb3dlclBsYWNlbWVudCgpIHtcbiAgICBpZiAoYWN0aXZlVG93ZXJTZWxlY3RlZCA9PT0gbnVsbCB8fFxuICAgICAgICAhY2FudmFzTW91c2VQb3NpdGlvbi5vbkNhbnZhcykge1xuICAgICAgICByZXR1cm5cbiAgICB9O1xuXG4gICAgdmFyIGNvb3JkaW5hdGVzID0gY2FudmFzTW91c2VQb3NpdGlvbi50b3dlclBvc2l0aW9uLmNvb3JkaW5hdGVzO1xuICAgIGR5bmFtaWNDb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGR5bmFtaWNDb250ZXh0Lmdsb2JhbEFscGhhID0gMC41O1xuXG4gICAgaWYgKGdhbWUudmFsaWRhdGVUb3dlclBsYWNlbWVudChjYW52YXNNb3VzZVBvc2l0aW9uLnRvd2VyUG9zaXRpb24uZ3JpZCkpIHsgLy8gY2hlY2sgZm9yIHZhbGlkIHRvd2VyIHBsYWNlbWVudFxuICAgICAgICBkeW5hbWljQ29udGV4dC5maWxsU3R5bGUgPSBcImdyZWVuXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZHluYW1pY0NvbnRleHQuZmlsbFN0eWxlID0gXCJyZWRcIjtcbiAgICAgICAgLy8gZG8gc29tZSBzb3J0IG9mIGxvZ2ljIHRvIGhpZ2hsaWdodCB0aGUgdGlsZXMgdGhhdCB0aGUgdG93ZXIgd291bGQgYmUgcGxhY2VkIG9uIGFuZCBzaG93IHRoZSB0b3dlciBvbiB0aG9zZSBwb3NpdGlvbnNcbiAgICAgICAgLy8gdGhpcyB3b3VsZCBydW4gd2hlbiB0b3dlciBwbGFjZW1lbnQgaXMgaW52YWxpZFxuICAgIH1cbiAgICBkeW5hbWljQ29udGV4dC5maWxsUmVjdChjb29yZGluYXRlcy54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNTBcbiAgICAgKTtcblxuICAgIGR5bmFtaWNDb250ZXh0Lmdsb2JhbEFscGhhID0gMC43O1xuICAgIGR5bmFtaWNDb250ZXh0LmFyYyhjb29yZGluYXRlcy54ICsgMjUsXG4gICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzLnkgKyAyNSxcbiAgICAgICAgICAgICAgICAgICAgICAgMzAsXG4gICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgIDIgKiBNYXRoLlBJLFxuICAgICAgICAgICAgICAgICAgICAgICBmYWxzZVxuICAgICApO1xuICAgIGR5bmFtaWNDb250ZXh0LmZpbGxTdHlsZSA9ICdncmF5JztcbiAgICBkeW5hbWljQ29udGV4dC5maWxsKCk7XG5cbiAgICBkeW5hbWljQ29udGV4dC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgZHluYW1pY0NvbnRleHQuY2xvc2VQYXRoKCk7XG59XG5cbi8qID09PT09PT09PT09PT09PT0gVUkgRXZlbnQgTGlzdGVuZXJzID09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RhcnQtYnRuXCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAvLyBIaWRlcyB0aGUgbW9kYWwgbGlnaHRib3hcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwibW9kYWwtY29udGVudFwiKVswXS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIm1vZGFsLWJhY2tncm91bmRcIilbMF0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXG4gICAgLy8gcnVuIHJlcGVhdGluZyBmdW5jdGlvbiB0aGF0IHJ1bnMgZ2FtZSBlbmdpbmUgcnVuIGN5Y2xlIGFuZCByZW5kZXJpbmdcbiAgICBzZXRUaW1lb3V0KHJ1bkN5Y2xlLCAxMDAwKTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyQ3ljbGUpO1xufSk7XG5cbi8vIE9uIGNsaWNraW5nIHRoZSBpbmZvcm1hdGlvbiBidXR0b24sIHNob3cgdGhlIGluZm9ybWF0aW9uIHBhbmVsXG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImluZm9ybWF0aW9uLWJ0blwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgLy8gVE9ETyAtIGFkZCBpbmZvcm1hdGlvbiBtb2RhbCBpbmZvcm1hdGlvbiB0aGluZ3lcbiAgICBjb25zb2xlLmxvZyhcInNob3cgaW5mb3JtYXRpb24gY29udGFpbmVyIGhlcmVcIik7XG59KTtcblxuLypcblRoZXNlIGV2ZW50IGxpc3RlbmVycyBjb250cm9sIHRoZSBhcHBsaWNhdGlvbiBieSBpbnRlcmFjdGluZyB3aXRoIHRoZSBnYW1lXG5vYmplY3QgYW5kIGJ5IGNoYW5naW5nIHRoZSBzdGF0ZSB2YXJpYWJsZXMgKHdoaWNoIHRoZSByZW5kZXIgZnVuY3Rpb25zIHVzZVxudG8gcmVhZClcbiovXG50b3dlckNhcmRzLm1hcChmdW5jdGlvbih0b3dlckNhcmQsIGkpIHtcbiAgICB0b3dlckNhcmRMaXN0LnB1c2godG93ZXJDYXJkLmdldEF0dHJpYnV0ZShcImRhdGEtdG93ZXJcIikpO1xuICAgIHRvd2VyQ2FyZC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdG93ZXJDYXJkQ2xpY2spO1xufSk7XG5cbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZHluYW1pY1wiKS5vbm1vdXNlbW92ZSA9IG9uQ2FudmFzTW91c2VNb3ZlbWVudDtcbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZHluYW1pY1wiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgY2FudmFzQ2xpY2spO1xuXG5kb2N1bWVudC5vbmtleWRvd24gPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgICAgY2FuY2VsVG93ZXJQbGFjZW1lbnQoKTtcbiAgICB9XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT0gVUkgRnVuY3Rpb25zID09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qIENsaWNrIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSB0b3dlciBjYXJkc1xuVXNlZCB0byBjb250cm9sIHdoYXQgdG93ZXIgaXMgYmVpbmcgYWN0aXZlbHkgcGxhY2VkIG9uIHRoZSBjYW52YXNcbjQgcG9zc2libGUgZmxvd3MgYmFzZWQgb24gdGhlIHN0YXRlIG9mIHRoZSBpbnRlcmZhY2VcbjEpIFRoZSB0b3dlciB0aGF0IHdhcyBjbGlja2VkIGlzIGN1cnJlbnRseSBkaXNhYmxlZDpcbiAgICAtPiBmdW5jdGlvbiByZXR1cm5zXG4yKSBObyB0b3dlcnMgYXJlIGFjdGl2ZWx5IGJlaW5nIHBsYWNlZFxuICAgIC0+IHRoZSBjbGlja2VkIHRvd2VyIGNhcmQgbm93IGJlY29tZXMgdGhlIGFjdGl2ZSB0b3dlciBiZWluZyBwbGFjZWRcbjMpIFRoZSBjbGlja2VkIHRvd2VyIGlzIHRoZSBzYW1lIGFzIHRoZSB0b3dlciBhY3RpdmVseSBiZWluZyBwbGFjZWRcbiAgICAtPiB0aGUgc3RhdGUgaXMgcmVzZXQgc28gdGhhdCBubyB0b3dlcnMgYXJlIGFjdGl2ZWx5IGJlaW5nIHBsYWNlZFxuNCkgVGhlIGNsaWNrZWQgdG93ZXIgaXMgZGlmZmVyZW50IGZyb20gdGhlIHRvd2VyIGFjdGl2ZWx5IGJlaW5nIHBsYWNlZFxuICAgIC0+IHRoZSBzdGF0ZSBpcyBjaGFuZ2VkIHRvIHRoZSBjbGlja2VkIHRvd2VyIGJlY29taW5nIHRoZSBhY3RpdmUgdG93ZXJcbiovXG5mdW5jdGlvbiB0b3dlckNhcmRDbGljaygpIHtcblxuICAgIHZhciB0b3dlck5hbWUgPSB0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtdG93ZXJcIiksXG4gICAgICAgIG9sZFRvd2VySW5kZXggPSB0b3dlckNhcmRMaXN0LmluZGV4T2YoYWN0aXZlVG93ZXJTZWxlY3RlZCksXG4gICAgICAgIG5ld1Rvd2VySW5kZXggPSB0b3dlckNhcmRMaXN0LmluZGV4T2YodG93ZXJOYW1lKTtcblxuICAgIGlmICgvZGlzYWJsZWQvaS50ZXN0KHRoaXMuY2xhc3NOYW1lKSkge1xuICAgICAgICByZXR1cm47XG5cbiAgICB9IGVsc2UgaWYgKGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPT09IG51bGwpIHtcbiAgICAgICAgYWN0aXZlVG93ZXJTZWxlY3RlZCA9IHRvd2VyTmFtZTtcbiAgICAgICAgdXRpbHMuYWRkQ2xhc3ModG93ZXJDYXJkc1tuZXdUb3dlckluZGV4XSwgXCJhY3RpdmVcIik7XG4gICAgICAgIGNhbnZhc01vdXNlUG9zaXRpb24ub25DYW52YXMgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPT09IHRvd2VyTmFtZSkge1xuICAgICAgICBjYW5jZWxUb3dlclBsYWNlbWVudCgpO1xuICAgICAgICBjYW52YXNNb3VzZVBvc2l0aW9uLm9uQ2FudmFzID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdXRpbHMucmVtb3ZlQ2xhc3ModG93ZXJDYXJkc1tvbGRUb3dlckluZGV4XSwgXCJhY3RpdmVcIik7XG4gICAgICAgIGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPSB0b3dlck5hbWU7XG4gICAgICAgIHV0aWxzLmFkZENsYXNzKHRvd2VyQ2FyZHNbbmV3VG93ZXJJbmRleF0sIFwiYWN0aXZlXCIpO1xuICAgICAgICBjYW52YXNNb3VzZVBvc2l0aW9uLm9uQ2FudmFzID0gZmFsc2U7XG5cbiAgICB9XG59XG5cbi8qXG5DYWxsZWQgZnJvbSB0b3dlckNhcmRDbGljayAod2hlbiBjbGlja2luZyB0aGUgYWN0aXZlIHRvd2VyIGNhcmQpIGFuZCBvbiBhbiBlc2NhcGUga2V5IHByZXNzXG5SZXNldHMgdGhlIGFjdGl2ZSB0b3dlciBwbGFjZW1lbnQgc3RhdGUgdG8gbnVsbFxuKi9cbmZ1bmN0aW9uIGNhbmNlbFRvd2VyUGxhY2VtZW50KCkge1xuICAgIHV0aWxzLnJlbW92ZUNsYXNzKHRvd2VyQ2FyZHNbdG93ZXJDYXJkTGlzdC5pbmRleE9mKGFjdGl2ZVRvd2VyU2VsZWN0ZWQpXSwgXCJhY3RpdmVcIik7XG4gICAgYWN0aXZlVG93ZXJTZWxlY3RlZCA9IG51bGw7XG59XG5cbi8qIE1vdXNlIG1vdmUgZXZlbnQgbGlzdGVuZXIgb24gdGhlIGNhbnZhc1xuSWYgdGhlIGFjdGl2ZSB0b3dlciBzZWxlY3RlZCBzdGF0ZSAoYSB0b3dlciBpcyBiZWluZyBwbGFjZWQgYnkgdGhlIHVzZXIpOlxuICAgIC0+IHVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIG1vdXNlIG9uIHRoZSBjYW52YXMgKHVzZWQgYnkgdGhlIHJlbmRlclRvd2VyUGxhY2VtZW50IGZ1bmN0aW9uKVxub3RoZXJ3aXNlOlxuICAgIC0+IGRvIG5vdGhpbmdcbiovXG5mdW5jdGlvbiBvbkNhbnZhc01vdXNlTW92ZW1lbnQoZSkge1xuICAgIGlmIChhY3RpdmVUb3dlclNlbGVjdGVkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVyblxuICAgIH07XG5cbiAgICB2YXIgY2FudmFzQ29udGFpbmVyID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgcG9zaXRpb24gPSB7fTtcblxuICAgIHBvc2l0aW9uLnggPSBlLmNsaWVudFggLSBjYW52YXNDb250YWluZXIubGVmdDtcbiAgICBwb3NpdGlvbi55ID0gZS5jbGllbnRZIC0gY2FudmFzQ29udGFpbmVyLnRvcDtcbiAgICBjYW52YXNNb3VzZVBvc2l0aW9uLm1vdXNlUG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICBjYW52YXNNb3VzZVBvc2l0aW9uLnRvd2VyUG9zaXRpb24gPSB1dGlscy5jb252ZXJ0UG9zaXRpb25Ub1Rvd2VyKHBvc2l0aW9uKTtcbiAgICBjYW52YXNNb3VzZVBvc2l0aW9uLm9uQ2FudmFzID0gdHJ1ZTtcbn07XG5cblxuLyogQ2xpY2sgZXZlbnQgbGlzdGVuZXIgb24gdGhlIGNhbnZhc1xuSGFuZGxlcyB0d28gcG9zc2libGUgY2FudmFzIGNsaWNrIHNjZW5hcmlvc1xuMSkgQSB0b3dlciBpcyBzZWxlY3RlZCBhbmQgaXMgYWN0aXZlbHkgYmVpbmcgcGxhY2VkXG4gICAgLT4gQ2xpY2tpbmcgd2lsbCB2YWxpZGF0ZSB0aGUgdG93ZXIgcGxhY2VtZW50IGFuZCBjaGVjayB0aGUgdXNlcidzIGdvbGRcbiAgICBpZiBib3RoIGFyZSB2YWxpZCwgd2lsbCB0b3dlciB3aWxsIGJlIHBsYWNlZCAoYnkgZ2FtZSBvYmplY3QpXG4gICAgb3RoZXJ3aXNlLCBhbiBlcnJvciBtZXNzYWdlIHdpbGwgc2hvdyB1cFxuMikgQSB0b3dlciBpcyBub3Qgc2VsZWN0ZWQgYW5kIGlzIG5vdCBiZWluZyBwbGFjZWRcbiAgICAtPiBXaWxsIGNoZWNrIHdoZXRoZXIgdGhlIGNsaWNrIHBvc2l0aW9uIG92ZXJsYXBzIHdpdGggdGhlIGJvdW5kaW5nXG4gICAgcmVjdGFuZ2xlIG9mIG1vbnN0ZXIgb3IgdG93ZXIgLSBpZiBzbywgaXQgd2lsbCByZXR1cm4gdGhlIGluZm9ybWF0aW9uXG4gICAgaW4gdGhlIGluZm9ybWF0aW9uIGNvbnRhaW5lclxuKi9cbmZ1bmN0aW9uIGNhbnZhc0NsaWNrKGUpIHtcbiAgICAvLyBHZXQgY2xpY2sgbG9jYXRpb24gcmVsYXRpdmUgdG8gdGhlIGNhbnZhcyBlbGVtZW50XG4gICAgdmFyIGNhbnZhc0NvbnRhaW5lciA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIHBvc2l0aW9uID0ge30sXG4gICAgICAgIHRvd2VyR3JpZFBvc2l0aW9uID0gY2FudmFzTW91c2VQb3NpdGlvbi50b3dlclBvc2l0aW9uLmdyaWQsXG4gICAgICAgIHRvd2VyQ29vcmRpbmF0ZXMgPSBjYW52YXNNb3VzZVBvc2l0aW9uLnRvd2VyUG9zaXRpb24uY29vcmRpbmF0ZXM7IC8vIFBhc3NlcyBpbiBncmlkIGJsb2NrcyAtIHRoaXMgaXMgdGhlIHRvcExlZnQgYmxvY2tcblxuICAgIHBvc2l0aW9uLnggPSBlLmNsaWVudFggLSBjYW52YXNDb250YWluZXIubGVmdDtcbiAgICBwb3NpdGlvbi55ID0gZS5jbGllbnRZIC0gY2FudmFzQ29udGFpbmVyLnRvcDtcblxuICAgIC8vIFJ1bnMgaWYgdGhlIHVzZXIgaXMgcGxhY2luZyBhIHRvd2VyXG4gICAgaWYgKGFjdGl2ZVRvd2VyU2VsZWN0ZWQgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHRvd2VyTmFtZSA9IGFjdGl2ZVRvd2VyU2VsZWN0ZWQsXG4gICAgICAgICAgICB0b3dlclBsYWNlZCA9IGdhbWUucGxhY2VUb3dlcih0b3dlck5hbWUsIHRvd2VyR3JpZFBvc2l0aW9uLCB0b3dlckNvb3JkaW5hdGVzKTtcblxuICAgICAgICAvLyBJZiB0aGUgdG93ZXIgd2FzIG5vdCBwbGFjZWQsIHNob3cgYW4gZXJyb3IgbWVzc2FnZVxuICAgICAgICBpZiAoIXRvd2VyUGxhY2VkLnBsYWNlZCkge1xuICAgICAgICAgICAgYWN0aXZlTWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB0b3dlclBsYWNlZC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIHRpbWVyOiA1MCAvLyBmcmFtZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHV0aWxzLnJlbW92ZUNsYXNzKHRvd2VyQ2FyZHNbdG93ZXJDYXJkTGlzdC5pbmRleE9mKGFjdGl2ZVRvd2VyU2VsZWN0ZWQpXSwgXCJhY3RpdmVcIik7XG4gICAgICAgIGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFVzZXIgaXMgbm90IHJ1bm5pbmcgYSB0b3dlciBwbGFjZW1lbnRcbiAgICAgICAgYWN0aXZlQ2FudmFzRWxlbWVudCA9IGdhbWUuY2hlY2tDbGlja0xvY2F0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgdXBkYXRlR2FtZUluZm9ybWF0aW9uKCk7XG4gICAgfVxuXG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2pzL2ludGVyZmFjZS5qc1xuICoqIG1vZHVsZSBpZCA9IDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB0b3dlckRhdGEgPSByZXF1aXJlKFwiLi4vZ2FtZURhdGEvdG93ZXJkYXRhLmpzXCIpLFxuICAgIHV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzLmpzXCIpO1xuXG4vLyBQb3NpdGlvbiByZWZlcnMgdG8gdGhlIHVwcGVyIGxlZnQgY29ybmVyIG9mIHRoZSBlbGVtZW50c1xuLy8gVG93ZXIgd2lkdGggLSA1MCB4IDUwXG52YXIgVG93ZXIgPSBmdW5jdGlvbihwb3NpdGlvbiwgaWQpIHtcbiAgICBpZiAodG93ZXJEYXRhW2lkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdG93ZXIgbmFtZSwgY2hlY2sgaHRtbCBkYXRhYXR0cmlidXRlIG9yIHRvd2VyZGF0YVwiKVxuICAgIH1cbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5kYW1hZ2UgPSB0b3dlckRhdGFbaWRdLmRhbWFnZTtcbiAgICB0aGlzLnNwZWVkID0gdG93ZXJEYXRhW2lkXS5zcGVlZDsgLy8gQXR0YWNrIHNwZWVkXG4gICAgdGhpcy5yYW5nZSA9IHRvd2VyRGF0YVtpZF0ucmFuZ2U7IC8vIFJhbmdlIG9mIHRoZSB0b3dlclxuICAgIHRoaXMudHlwZSA9IHRvd2VyRGF0YVtpZF0udHlwZTsgLy8gVHlwZSBvZiBkYW1hZ2VcbiAgICB0aGlzLmVmZmVjdCA9IHRvd2VyRGF0YVtpZF0uZWZmZWN0OyAvLyBTcGVjaWFsIGVmZmVjdCAoZS5nLiBzbG93LCBzcGxhc2gsIGV0YylcbiAgICB0aGlzLmdvbGRDb3N0ID0gdG93ZXJEYXRhW2lkXS5nb2xkQ29zdDtcbiAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247IC8vIG9iamVjdCB3aXRoIHggYW5kIHkgY29vcmRpbmF0ZXMgLSByZWZlcmVuY2VzIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHRvd2VyXG4gICAgdGhpcy5wb3NpdGlvbi5zaWRlTGVuZ3RoID0gNTA7XG59XG4vLyBNZXRob2QgdGhlIGdhbWUgb2JqZWN0IHVzZXMgdG8gcnVuIHRvd2Vyc1xuVG93ZXIucHJvdG90eXBlLnJ1bkN5Y2xlID0gZnVuY3Rpb24oKSB7XG5cbn1cbi8vIGNoYW5nZSB0aGlzIHRvIHJlZmVyZW5jZSBhIGxpc3Qgb3Igc29tZXRoaW5nIHdoZXJlIGEgbmFtZSBjYW4gYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHByb3BlcnRpZXNcbi8vIFRha2VzIGluIGEgbW9uc3RlcidzIHBvc2l0aW9uIGFuZCBjaGVja3Mgd2hldGhlciB0aGF0IGlzIGluIHJhbmdlIGJhc2VkIG9uIHRoZSByYW5nZSAtIHJldHVybnMgdHJ1ZSBvciBmYWxzZSBpZiBpbiByYW5nZSB3aGljaCBjYW4gYmUgdXNlZCB0b1xuVG93ZXIucHJvdG90eXBlLmNoZWNrSW5SYW5nZSA9IGZ1bmN0aW9uKG1vbnN0ZXJQb3NpdGlvbikge1xuICAgIC8vIHVzaW5nIHNxcnQoKHgyLXgxKV4yIC0gKHkyLXkxKV4yKVxuICAgIHZhciBtb25zdGVyRGlzdGFuY2UgPSB1dGlscy5nZXRQb3NpdGlvbkRpZmZlcmVuY2UobW9uc3RlclBvc2l0aW9uLCB0aGlzLnBvc2l0aW9uKTtcblxuICAgaWYgKG1vbnN0ZXJEaXN0YW5jZSA8PSB0aGlzLnJhbmdlKSB7XG4gICAgICAgcmV0dXJuIHRydWU7XG4gICB9IGVsc2Uge1xuICAgICAgIHJldHVybiBmYWxzZTtcbiAgIH1cbn1cblxuVG93ZXIucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbigpIHtcbiAgICBkeW5hbWljQ29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBkeW5hbWljQ29udGV4dC5maWxsU3R5bGUgPSBcImdyZWVuXCI7XG4gICAgZHluYW1pY0NvbnRleHQuZmlsbFJlY3QodGhpcy5wb3NpdGlvbi54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24ueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA1MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA1MCk7XG4gICAgZHluYW1pY0NvbnRleHQuY2xvc2VQYXRoKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVG93ZXI7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2pzL2NsYXNzZXMvVG93ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBiYXNpYzoge1xuICAgICAgICBkYW1hZ2U6IDEwLFxuICAgICAgICBzcGVlZDogMTAsXG4gICAgICAgIHJhbmdlOiAxMDAsXG4gICAgICAgIGdvbGRDb3N0OiAxMCxcbiAgICAgICAgdHlwZTogXCJiYXNpY1wiLFxuICAgICAgICBlZmZlY3Q6IFwibm9uZVwiXG4gICAgfVxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvZ2FtZURhdGEvdG93ZXJkYXRhLmpzXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gTWFrZSB0aGlzIGZpbGUgZ3JlYXQgYWdhaW4hXG4vLyBUaGlzIGZpbGUgbmVlZHMgdGVzdHMgYW5kIG5lZWRzIHRvIGJlIGNsZWFuZWQgdXAgKHdpdGggY29tbWVudHMgYW5kIG90aGVyIHVzZWZ1bCBzdHVmZiAtIGNhbnQgYmUgYm90aGVyZWQgYXQgdGhlIG1vbWVudClcbi8vIHByb2JhYmx5IGNhbiBtb3ZlIHRoZSBnYW1lIHNwZWNpZmljIGdyaWQgZ2VuZXJhdGlvbiB0aGluZ3MgdG8gdGhlIGdhbWUgZmlsZVxuXG4vKiA9PT09PT09PT09PT09PT09PT0gUHJpdmF0ZSBmdW5jdGlvbnMgPT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vLyBUT0RPIC0gYWRkIHRlc3RzXG5cbi8qID09PT09PT09PT09PT09PT09PSBQdWJsaWMgZnVuY3Rpb25zID09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8vIFRha2VzIGluIGEgcG9zaXRpb24gb2JqZWN0IHdpdGggY29vcmRpbmF0ZXN7eCwgeX1cbi8vIHJldHVybnMgYSBibG9jayBvYmplY3Qge3gsIHl9IHdpdGggYmxvY2sgbnVtYmVyc1xuLy8gSGFuZGxlcyBlZGdlIGNhc2VzIG9mIHRoZSBibG9jayBiZWluZyBkZWZpbmVkIGF0IHRoZSBlZGdlICgzNiBhbmQgMjQgd2hpY2ggYXJlIGludmFsaWQgaW4gdGhlIClcbmZ1bmN0aW9uIGNvbnZlcnRUb0Jsb2NrKHBvc2l0aW9uKSB7XG4gICAgaWYgKHBvc2l0aW9uLnggPiAoMzYqMjUpIHx8IHBvc2l0aW9uLnkgPiAoMjQqMjUpKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKHBvc2l0aW9uKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQb3NpdGlvbiBvdXQgb2YgZ3JpZCByYW5nZVwiKTtcbiAgICB9XG5cbiAgICB2YXIgYmxvY2sgPSB7XG4gICAgICAgIHg6IE1hdGguZmxvb3IocG9zaXRpb24ueCAvIDI1KSxcbiAgICAgICAgeTogTWF0aC5mbG9vcihwb3NpdGlvbi55IC8gMjUpXG4gICAgfTtcbiAgICAvLyBBZGp1c3RzIGlmIG1vdXNlIGlzIGF0IGVuZCBvZiBjb250YWluZXJcbiAgICAvLyAzNiBibG9ja3Mgd2lkdGggYW5kIDI0IGJsb2NrcyBoZWlnaHRcbiAgICBpZiAoYmxvY2sueCA+PSAzNSkge1xuICAgICAgICBibG9jay54LS07XG4gICAgfVxuXG4gICAgaWYgKGJsb2NrLnkgPj0gMjMpIHtcbiAgICAgICAgYmxvY2sueS0tO1xuICAgIH1cblxuICAgIHJldHVybiBibG9jaztcbn1cblxuZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgY3NzQ2xhc3MpIHtcbiAgICBpZiAoZWxlbWVudC5jbGFzc05hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBjc3NDbGFzcztcbiAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSArPSBcIiBcIiArIGNzc0NsYXNzO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY3NzQ2xhc3MpIHtcbiAgICB2YXIgYXJyYXlPZkNsYXNzZXMgPSBlbGVtZW50LmNsYXNzTmFtZS5zcGxpdChcIiBcIik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBhcnJheU9mQ2xhc3Nlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgaWYgKGFycmF5T2ZDbGFzc2VzW2ldID09PSBjc3NDbGFzcykge1xuICAgICAgICAgICAgYXJyYXlPZkNsYXNzZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgaS0tOyBqLS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBhcnJheU9mQ2xhc3Nlcy5qb2luKFwiIFwiKTtcbn1cblxuLypcblRha2VzIGluIGEgcG9zaXRpb24gb2JqZWN0ICh4IGFuZCB5IGNvb3JkaW5hdGVzKVxuUmV0dXJucyB0aGUgdG9wIGxlZnQgYmxvY2sgcG9zaXRpb24gYW5kIHRvcGxlZnQgY29vcmRpbmF0ZSBvZiB0aGUgdG93ZXJcbkdyaWQgYmxvY2tzIGFyZSBpbiAyNXgyNSBibG9jayBpbmNyZW1lbnRzXG4qL1xuZnVuY3Rpb24gY29udmVydFBvc2l0aW9uVG9Ub3dlcihwb3NpdGlvbikge1xuICAgIHZhciB0b3dlclBvc2l0aW9uID0ge1xuICAgICAgICBncmlkOiB7fSxcbiAgICAgICAgY29vcmRpbmF0ZXM6IHt9LFxuICAgICAgICBzaWRlOiA1MFxuICAgIH07XG5cbiAgICB0b3dlclBvc2l0aW9uLmdyaWQgPSBjb252ZXJ0VG9CbG9jayhwb3NpdGlvbik7XG5cbiAgICAvLyBDb250YWluZXIgd2lkdGggYW5kIGhlaWdodCA5MDAgYW5kIDYwMCBweCByZXNwZWN0aXZlbHlcbiAgICB0b3dlclBvc2l0aW9uLmNvb3JkaW5hdGVzLnggPSAodG93ZXJQb3NpdGlvbi5ncmlkLnggLyAzNikgKiA5MDA7XG4gICAgdG93ZXJQb3NpdGlvbi5jb29yZGluYXRlcy55ID0gKHRvd2VyUG9zaXRpb24uZ3JpZC55IC8gMjQpICogNjAwO1xuICAgIHJldHVybiB0b3dlclBvc2l0aW9uO1xufVxuXG4vKlxuY2hlY2tJZkluU3F1YXJlIGNoZWNrcyB3aGV0aGVyIGEgcG9pbnQgaXMgaW4gYSBzcXVhcmUgKHdoaWNoIGlzIGEgbW9uc3RlciBvciBhIHRvd2VyKVxuXG5UYWtlcyBpbiB0aHJlZSBhcmd1bWVudHNcbnBvaW50IC0gYSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvb3JkaW5hdGVzXG50b3BMZWZ0UG9pbnQgLSBhbiBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHNxdWFyZVxuc2lkZUxlbmd0aCAtIHRoZSBsZW5ndGggb2YgdGhlIHNxdWFyZVxuXG5SZXR1cm5zIGEgYm9vbGVhbiAtIHRydWUgaWYgdGhlIGNsaWNrIG92ZXJsYXBzIHdpdGggYW4gZWxlbWVudCBhbmQgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgaWYgaXQgZG9lcyBub3RcbiovXG5mdW5jdGlvbiBjaGVja0lmSW5TcXVhcmUocG9pbnQsIHRvcExlZnRQb2ludCwgc2lkZUxlbmd0aCkge1xuICAgIGlmIChwb2ludC54ID49IHRvcExlZnRQb2ludC54XG4gICAgJiYgcG9pbnQueCA8PSB0b3BMZWZ0UG9pbnQueCArIHNpZGVMZW5ndGhcbiAgICAmJiBwb2ludC55ID49IHRvcExlZnRQb2ludC55XG4gICAgJiYgcG9pbnQueSA8PSB0b3BMZWZ0UG9pbnQueSArIHNpZGVMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0UG9zaXRpb25EaWZmZXJlbmNlKHBvc2l0aW9uMSwgcG9zaXRpb24yKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydChcbiAgICAgICAgICAgIE1hdGgucG93KHBvc2l0aW9uMS54LXBvc2l0aW9uMi54LCAyKSArXG4gICAgICAgICAgICBNYXRoLnBvdyhwb3NpdGlvbjEueS1wb3NpdGlvbjIueSwgMilcbiAgICApO1xufVxuXG4vKlxuVGFrZXMgaW4gYSBkaXN0YW5jZSAoaW50KSBhbmQgcGF0aExpbmVzKGFycmF5IG9mIHBhdGggb2JqZWN0cykgYW5kIGNvbnZlcnRzIGl0IHRvIGNvb3JkaW5hdGVzIGZvciBhIG1vbnN0ZXJcblxuUmV0dXJucyBhIGNvb3JkaW5hdGUgb2JqZWN0XG4qL1xuZnVuY3Rpb24gY29udmVydERpc3RhbmNlVG9Db29yZGluYXRlcyhkaXN0YW5jZSwgcGF0aExpbmVzKSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzLFxuICAgICAgICBlbmQgPSBmYWxzZTsgLy8gQm9vbGVhbiB0byByZXByZXNlbnQgd2hldGhlciB0aGUgbW9uc3RlciBpcyBhdCB0aGUgZW5kXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aExpbmVzLmxlbmd0aDsgaSArKykge1xuICAgICAgICBpZiAoZGlzdGFuY2UgLSBwYXRoTGluZXNbaV0uZGlzdGFuY2UgPD0gMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXN0YW5jZSAtPSBwYXRoTGluZXNbaV0uZGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaSA9PT0gcGF0aExpbmVzLmxlbmd0aCkge1xuICAgICAgICBpLS07IC8vIFNldCB0aGUgY291bnRlciB2YWx1ZSB0byBiZSB0aGUgbGFzdCB2YWx1ZSBpbiB0aGUgcGF0aGxpbmVzIGFycmF5XG4gICAgICAgIGRpc3RhbmNlID0gIHBhdGhMaW5lc1tpXS5kaXN0YW5jZTtcbiAgICAgICAgZW5kID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgb2JqZWN0IHRvIHJldHVybiAoaW5zdGVhZCBvZiBtb2RpZml5aW5nIHN0YXJ0UG9pbnQgb2JqZWN0KVxuICAgIGNvb3JkaW5hdGVzID0gT2JqZWN0LmNyZWF0ZShwYXRoTGluZXNbaV0uc3RhcnRQb2ludCk7XG4gICAgY29vcmRpbmF0ZXMuZW5kID0gZW5kO1xuXG4gICAgLy8gQ2FzZSBmb3Igd2hlbiBtb25zdGVyIGlzIGF0IHRoZSBlbmQgb2YgdGhlIHRoaW5neSAtIHRoZXJlIGlzIGEgYmV0dGVyIHdheSB0byB3cml0ZSB0aGlzIGJ1dCBub3QgcmlnaHQgbm93XG4gICAgaWYgKCFlbmQpIHtcbiAgICAgICAgc3dpdGNoIChwYXRoTGluZXNbaV0uZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAvLyAxNSBpcyBhIGhhbGYgb2YgdGhlIG1vbnN0ZXIgd2lkdGhcbiAgICAgICAgICAgIC8vIHZhbHVlcyB1c2VkIHRvIG9mZnNldCB0aGUgcG9zaXRpb25pbmcgYmFzZWQgb24gdGhlIG1vbnN0ZXIgZGlyZWNpdG9uIG1vdmVtZW50XG4gICAgICAgICAgICBjYXNlIFwidXBcIjpcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzLnggLT0gMTU7XG4gICAgICAgICAgICBjb29yZGluYXRlcy55IC09IGRpc3RhbmNlICsgMTU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkb3duXCI6XG4gICAgICAgICAgICBjb29yZGluYXRlcy54IC09IDE1O1xuICAgICAgICAgICAgY29vcmRpbmF0ZXMueSArPSBkaXN0YW5jZSAtIDE1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgICAgY29vcmRpbmF0ZXMueCAtPSBkaXN0YW5jZSArIDE1O1xuICAgICAgICAgICAgY29vcmRpbmF0ZXMueSAtPSAxNTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICBjb29yZGluYXRlcy54ICs9IGRpc3RhbmNlIC0gMTU7XG4gICAgICAgICAgICBjb29yZGluYXRlcy55IC09IDE1O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkaXJlY3Rpb24gcHJvdmlkZWQgaW4gcGF0aExpbmVzXCIpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChwYXRoTGluZXNbaV0uZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIFwidXBcIjpcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlcy55IC09IHBhdGhMaW5lc1tpXS5kaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkb3duXCI6XG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXMueSArPSBwYXRoTGluZXNbaV0uZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzLnggLT0gcGF0aExpbmVzW2ldLmRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXMueCArPSBwYXRoTGluZXNbaV0uZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGlyZWN0aW9uIHByb3ZpZGVkIGluIHBhdGhMaW5lc1wiKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzXG59XG5cbi8vIE1vdmVkIG91dCB0byBiZSBhYmxlIHRvIHRlc3QgY29kZVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYWRkQ2xhc3M6IGFkZENsYXNzLFxuICAgIHJlbW92ZUNsYXNzOiByZW1vdmVDbGFzcyxcbiAgICBjb252ZXJ0UG9zaXRpb25Ub1Rvd2VyOiBjb252ZXJ0UG9zaXRpb25Ub1Rvd2VyLFxuICAgIGNoZWNrSWZJblNxdWFyZTogY2hlY2tJZkluU3F1YXJlLFxuICAgIGdldFBvc2l0aW9uRGlmZmVyZW5jZTogZ2V0UG9zaXRpb25EaWZmZXJlbmNlLFxuICAgIGNvbnZlcnRUb0Jsb2NrOiBjb252ZXJ0VG9CbG9jayxcbiAgICBjb252ZXJ0RGlzdGFuY2VUb0Nvb3JkaW5hdGVzOiBjb252ZXJ0RGlzdGFuY2VUb0Nvb3JkaW5hdGVzXG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2pzL3V0aWxzLmpzXG4gKiogbW9kdWxlIGlkID0gNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gIHJlcXVpcmUgTW9uc3RlciB0byBnYWluIGFjY2Vzc1xudmFyIE1vbnN0ZXIgPSByZXF1aXJlKFwiLi9Nb25zdGVyLmpzXCIpLFxuICAgIFRvd2VyID0gcmVxdWlyZShcIi4vVG93ZXIuanNcIiksXG4gICAgdG93ZXJEYXRhID0gcmVxdWlyZShcIi4uL2dhbWVEYXRhL3Rvd2VyZGF0YS5qc1wiKSxcbiAgICB1dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy5qc1wiKSxcbiAgICBwYXRoQ29vcmRpbmF0ZXMgPSByZXF1aXJlKFwiLi4vZ2FtZURhdGEvcGF0aGRhdGEuanNcIik7XG5cbnZhciBHYW1lRW5naW5lID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy51c2VyR29sZCA9IDEwO1xuICAgIHRoaXMubGV2ZWwgPSAxO1xuICAgIHRoaXMudXNlckxpdmVzID0gMzA7XG4gICAgdGhpcy5hY3RpdmVNb25zdGVycyA9IFtdOyAvLyBMaXN0IG9mIGFjdGl2ZSBtb25zdGVycyBpbiB0aGVcbiAgICB0aGlzLnRvd2VycyA9IFtdOyAvLyBvYmplY3Qgb2YgdG93ZXIgb2JqZWN0c1xuICAgIHRoaXMudGltZXIgPSAxO1xuICAgIHRoaXMuZ2FtZVBhdGggPSBfY29udmVydFBhdGhUb0xpbmVzKHBhdGhDb29yZGluYXRlcy5wYXRoKTtcbiAgICBjb25zb2xlLmxvZyh0aGlzLmdhbWVQYXRoKTtcbiAgICB0aGlzLmdhbWVHcmlkID0gX2luaXRpYXRlR3JpZCh0aGlzLmdhbWVQYXRoKTtcbiAgICBjb25zb2xlLnRhYmxlKHRoaXMuZ2FtZUdyaWQpXG59XG5cbkdhbWVFbmdpbmUucHJvdG90eXBlLmFkZE1vbnN0ZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgLy8gYWRkIG1vbnN0ZXIgKHNwZWNpZmllZCBieSBuYW1lKSB0byBnYW1lXG4gICAgdmFyIG1vbnN0ZXIgPSBuZXcgTW9uc3RlcihcIm1vbnN0ZXIxXCIpO1xuICAgIHRoaXMuYWN0aXZlTW9uc3RlcnMucHVzaChtb25zdGVyKTtcbn1cblxuR2FtZUVuZ2luZS5wcm90b3R5cGUuYWRkVG93ZXIgPSBmdW5jdGlvbihpZCwgcG9zaXRpb24sIGdvbGRDb3N0KSB7XG4gICAgdGhpcy51c2VyR29sZCAtPSBnb2xkQ29zdDtcbiAgICB2YXIgdG93ZXIgPSBuZXcgVG93ZXIocG9zaXRpb24sIGlkKTtcbiAgICB0aGlzLnRvd2Vycy5wdXNoKHRvd2VyKTtcblxufVxuXG4vKlxuVGFrZXMgaW4gYSBwb3NpdGlvbiBvYmplY3QgKGxvY2F0aW9uIG9mIHRoZSBjbGljaylcblJldHVybnMgYW4gb2JqZWN0IHdpdGggaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBpcyBhdCB0aGF0IHBvc2l0aW9uXG57dHlwZTogbnVsbH0gaWYgbm90aGluZyBmb3VuZFxuKi9cbkdhbWVFbmdpbmUucHJvdG90eXBlLmNoZWNrQ2xpY2tMb2NhdGlvbiA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB7fTtcbiAgICAvLyBMb29wcyB0aHJvdWdoIGFjdGl2ZU1vbnN0ZXJzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdGl2ZU1vbnN0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh1dGlscy5jaGVja0lmSW5TcXVhcmUocG9zaXRpb24sIHRoaXMuYWN0aXZlTW9uc3RlcnNbaV0ucG9zaXRpb24sIHRoaXMuYWN0aXZlTW9uc3RlcnNbaV0uc2lkZUxlbmd0aCkpIHtcbiAgICAgICAgICAgIGVsZW1lbnQudHlwZSA9IFwibW9uc3RlclwiO1xuICAgICAgICAgICAgZWxlbWVudC5pZCA9IHRoaXMuYWN0aXZlTW9uc3RlcnNbaV0uaWQ7XG4gICAgICAgICAgICBlbGVtZW50LmluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbm90aGluZyB3YXMgZm91bmQsIGxvb3AgdGhyb3VnaCB0b3dlcnNcbiAgICBpZiAoZWxlbWVudC50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRvd2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHV0aWxzLmNoZWNrSWZJblNxdWFyZShwb3NpdGlvbiwgdGhpcy50b3dlcnNbaV0ucG9zaXRpb24sIHRoaXMudG93ZXJzW2ldLnBvc2l0aW9uLnNpZGVMZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC50eXBlID0gXCJ0b3dlclwiO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuaWQgPSB0aGlzLnRvd2Vyc1tpXS5pZDtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vIHRvd2VycyBvciBtb25zdGVycyBmb3VuZCByZXR1cm4gYSB0eXBlIG9mIG51bGxcbiAgICBpZiAoZWxlbWVudC50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWxlbWVudC50eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbn1cblxuLy8gbWV0aG9kIHRvIGNoZWNrIGdvbGQgYmVmb3JlIHBsYWNlIHRvd2VyIG9yIHVwZ3JhZGVcbkdhbWVFbmdpbmUucHJvdG90eXBlLmNoZWNrR29sZCA9IGZ1bmN0aW9uKGdvbGRDb3N0KSB7XG4gICAgaWYgKGdvbGRDb3N0IDw9IHRoaXMudXNlckdvbGQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cbkdhbWVFbmdpbmUucHJvdG90eXBlLmNoZWNrTW9uc3RlckRlYXRoID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSB0aGlzLmFjdGl2ZU1vbnN0ZXJzLmxlbmd0aDsgaSA8IGo7IGkgKyspIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlTW9uc3RlcnNbaV0uY2hlY2tEZWF0aCgpKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZU1vbnN0ZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuR2FtZUVuZ2luZS5wcm90b3R5cGUuZ2FtZU92ZXIgPSBmdW5jdGlvbigpIHtcblxufVxuXG5HYW1lRW5naW5lLnByb3RvdHlwZS5nYW1lV29uID0gZnVuY3Rpb24oKSB7XG5cbn1cblxuLy8gTmV3IGxldmVsIG1ldGhvZFxuR2FtZUVuZ2luZS5wcm90b3R5cGUubmV4dExldmVsID0gZnVuY3Rpb24oKSB7XG5cbn1cblxuLypcbnBsYWNlVG93ZXIgaGFuZGxlcyB0aGUgdmFsaWRhdGlvbiBvZiB0aGUgdG93ZXIgcGxhY2VtZW50IChwb3NpdGlvbiBhbmQgc3VmZmljaWVudCBnb2xkKVxuVGFrZXMgaW4gMyBhcmd1bWVudHM6XG50b3dlck5hbWUgLSBzdHJpbmcgc3BlY2lmeWluZyB3aGF0IHRvd2VyIGlzIGJlaW5nIHBsYWNlZFxuZ3JpZFBvc2l0aW9uIC0gdG9wIGxlZnQgZ3JpZCBibG9jayBvZiB3aGVyZSB0aGUgdG93ZXIgd291bGQgYmUgcGxhY2VkXG50b3dlckNvb3JkaW5hdGVzIC0gdG9wIGxlZnQgY29vcmRpbmF0ZSBvZiBhIHRvd2VyXG5SZXR1cm5zIGFuIG9iamVjdCB3aXRoIGEgYm9vbGVhbiB0byByZXByZXNlbnQgd2hldGhlciB0aGUgdG93ZXIgaXMgcGxhY2VkIGFuZCBhbiBlcnJvciBtZXNzYWdlIGlmIHRoZSB0b3dlciB3YXMgbm90IHBsYWNlZFxuKi9cbkdhbWVFbmdpbmUucHJvdG90eXBlLnBsYWNlVG93ZXIgPSBmdW5jdGlvbih0b3dlck5hbWUsIGdyaWRQb3NpdGlvbiwgdG93ZXJDb29yZGluYXRlcykge1xuICAgIHZhciBnb2xkQ29zdCA9IHRvd2VyRGF0YVt0b3dlck5hbWVdLmdvbGRDb3N0O1xuICAgIC8vIFZhbGlkYXRlIHRvd2VyIHBsYWNlbWVudFxuICAgIGlmICh0aGlzLnZhbGlkYXRlVG93ZXJQbGFjZW1lbnQoZ3JpZFBvc2l0aW9uKVxuICAgICYmIHRoaXMuY2hlY2tHb2xkKGdvbGRDb3N0KSkge1xuXG4gICAgICAgIHRoaXMuYWRkVG93ZXIodG93ZXJOYW1lLCB0b3dlckNvb3JkaW5hdGVzLCBnb2xkQ29zdCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwbGFjZWQ6IHRydWVcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIGlmICghdGhpcy52YWxpZGF0ZVRvd2VyUGxhY2VtZW50KGdyaWRQb3NpdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGxhY2VkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQgVG93ZXIgUGxhY2VtZW50XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGxhY2VkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIk5vdCBFbm91Z2ggR29sZFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuR2FtZUVuZ2luZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gc2VuZCBzdGF0ZSB0byB0aGUgZGlzcGxheSBvYmplY3QgdG8gcmVuZGVyXG4gICAgZHluYW1pY0NvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgZHluYW1pY0NvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGR5bmFtaWNDYW52YXMud2lkdGgsIGR5bmFtaWNDYW52YXMuaGVpZ2h0KTtcblxuICAgIC8vIFJlbmRlciB0b3dlcnMgZmlyc3Qgc28gdGhhdCBpZiBtb25zdGVycyBhcmUgbGFyZ2VyIHRoZXkgc2hvdyBhYm92ZSB0b3dlcnNcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMudG93ZXJzLmxlbmd0aDsgaSA8IGo7IGkgKyspIHtcbiAgICAgICAgdGhpcy50b3dlcnNbaV0uZHJhdygpO1xuICAgIH1cblxuICAgIC8vICBsb29wIHRocm91Z2ggbGlzdCBvZiBhY3RpdmUgbW9uc3RlcnMgYW5kIHJlbmRlciB0aGVtXG4gICAgLy8gIFRPRE8gcHJvYmFibHkgbmVlZCB0byBmaW5kIGEgYmV0dGVyIHdheSB0byByZW5kIHRoZW0gYXBhcnQgZnJvbSByYW5kb20gcmVjdGFuZ2xlXG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSB0aGlzLmFjdGl2ZU1vbnN0ZXJzLmxlbmd0aDsgaSA8IGo7IGkgKyspIHtcbiAgICAgICAgdGhpcy5hY3RpdmVNb25zdGVyc1tpXS5kcmF3KCk7XG4gICAgfVxuXG4gICAgZHluYW1pY0NvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICAvLyBkeW5hbWljQ29udGV4dC5cbn07XG5cbkdhbWVFbmdpbmUucHJvdG90eXBlLnJ1bkN5Y2xlID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gIGJlZ2lubmluZyBvZiBjeWNsZSBjaGVjayBpZiBhbnkgbW9uc3RlcnMgaGF2ZSBkaWVkIGlmIHNvIHJlbW92ZSBmcm9tIGFjdGl2ZSBtb25zdGVyc1xuICAgIHRoaXMuY2hlY2tNb25zdGVyRGVhdGgoKTtcbiAgICAvLyBsb29wIHRocm91Z2ggYWN0aXZlIG1vbnN0ZXJzIGFuZCB0b3dlcnMgYW5kIHJ1biB0aGUgY3ljbGVcbiAgICAvLyBFYWNoIHJ1bkN5Y2xlIG1ldGhvZCByZXR1cm5zIGluZm9ybWF0aW9uIGZvciB0aGUgZ2FtZUVuZ2luZSB0b1xuICAgIC8vIHByb2Nlc3MgKGUuZy4gdGhlIG1vbnN0ZXIgZGllZCwgdG93ZXIgY2hhbmdlZClcblxuICAgIC8vICB0aW1lciB0byBhZGQgbW9uc3RlcnNcbiAgICB0aGlzLnRpbWVyLS07XG4gICAgaWYgKHRoaXMudGltZXIgPCAxKSB7XG4gICAgICAgIHRoaXMuYWRkTW9uc3RlcignYmxhaCcpO1xuICAgICAgICB0aGlzLnRpbWVyID0gMTA7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBqID0gdGhpcy5hY3RpdmVNb25zdGVycy5sZW5ndGg7IGkgPCBqOyBpICsrKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlTW9uc3RlcnNbaV0ubW92ZSh0aGlzLmdhbWVQYXRoKTtcblxuICAgICAgICAvLyBUaGUgbW9uc3RlciBpcyBkZXN0cm95ZWQgaW4gdGhlIG5leHQgY3ljbGUgb2YgcnVuQ3ljbGUgaW4gdGhlIG1vbnN0ZXIuY2hlY2tEZWF0aCB2YWx1ZVxuICAgICAgICBpZiAodGhpcy5hY3RpdmVNb25zdGVyc1tpXS5wb3NpdGlvbi5lbmQpIHtcbiAgICAgICAgICAgIHRoaXMudXNlckxpdmVzLS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU2VuZCBpbmZvcm1hdGlvbiB0byByZW5kZXJcbn1cblxuLy8gbWV0aG9kIHRvIHVwZ3JhZGUgdG93ZXJcblxuLypcblRha2VzIGluIGEgZ3JpZFBvc2l0aW9uIG9iamVjdCAocG9pbnRzIHRvIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHRvd2VyKVxuVG93ZXJzIHRha2UgdXAgYSAyeDIgZ3JpZCAtIHRoaXMgZnVuY3Rpb24gY2hlY2tzIGFsbCBwb3NpdGlvbnNcblJldHVybnMgdHJ1ZSBpZiB0aGUgcG9zaXRpb24gaXMgYSB2YWxpZCBwbGFjZW1lbnQgZm9yIGEgdG93ZXJcblJldHVybnMgZmFsc2UgaWYgdGhlIHBvc2l0aW9uIGlzIGludmFsaWRcbiovXG5HYW1lRW5naW5lLnByb3RvdHlwZS52YWxpZGF0ZVRvd2VyUGxhY2VtZW50ID0gZnVuY3Rpb24oZ3JpZFBvc2l0aW9uKSB7XG4gICAgLy8gQ2hlY2tzIGFsbCA0IHBvc2l0aW9uc1xuICAgIHZhciBwb3NpdGlvblZhbGlkID0gdGhpcy5nYW1lR3JpZFtncmlkUG9zaXRpb24ueF1bZ3JpZFBvc2l0aW9uLnldLmVtcHR5XG4gICAgJiYgdGhpcy5nYW1lR3JpZFtncmlkUG9zaXRpb24ueCArIDFdW2dyaWRQb3NpdGlvbi55XS5lbXB0eVxuICAgICYmIHRoaXMuZ2FtZUdyaWRbZ3JpZFBvc2l0aW9uLnhdW2dyaWRQb3NpdGlvbi55ICsgMV0uZW1wdHlcbiAgICAmJiB0aGlzLmdhbWVHcmlkW2dyaWRQb3NpdGlvbi54ICsgMV1bZ3JpZFBvc2l0aW9uLnkgKyAxXS5lbXB0eTtcbiAgICByZXR1cm4gcG9zaXRpb25WYWxpZDtcbn1cblxuLypcbklucHV0OiBQYXRoIC0gYW4gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIGNvb3JkaW5hdGVzIHdoZXJlIHRoZSBwYXRoIHdpbGwgcnVuIHRvXG5PdXRwdXQ6IHBhdGhMaW5lcyAtIGFuIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyB0aGUgc3RhcnRQb2ludCAoY29vcmRpbmF0ZXMpLFxuICAgICAgICBkaXN0YW5jZSBvZiB0aGUgbGluZSBhbmQgZGlyZWN0aW9uIChsZWZ0LCByaWdodCwgdXAsIGRvd24pXG4qL1xuZnVuY3Rpb24gX2NvbnZlcnRQYXRoVG9MaW5lcyhwYXRoKSB7XG4gICAgdmFyIHBhdGhMaW5lcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgdmFyIGxpbmUgPSB7fTtcblxuICAgICAgICAvLyBBc3N1bWUgdGhhdCB0aGUgZGlyZWN0aW9uIGlzIG9ubHkgNCB3YXlzXG4gICAgICAgIGlmIChwYXRoW2krMV0ueCAtIHBhdGhbaV0ueCA9PT0gMCkge1xuXG4gICAgICAgICAgICBpZiAocGF0aFtpKzFdLnkgLSBwYXRoW2ldLnkgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGluZS5kaXJlY3Rpb24gPSBcImRvd25cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGluZS5kaXJlY3Rpb24gPSBcInVwXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocGF0aFtpKzFdLnggLSBwYXRoW2ldLnggPT09IDAgPiAwKSB7XG5cbiAgICAgICAgICAgICAgICBsaW5lLmRpcmVjdGlvbiA9IFwibGVmdFwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaW5lLmRpcmVjdGlvbiA9IFwicmlnaHRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsaW5lLnN0YXJ0UG9pbnQgPSBwYXRoW2ldO1xuICAgICAgICBsaW5lLmRpc3RhbmNlID0gdXRpbHMuZ2V0UG9zaXRpb25EaWZmZXJlbmNlKHBhdGhbaV0sIHBhdGhbaSsxXSk7XG4gICAgICAgIHBhdGhMaW5lcy5wdXNoKGxpbmUpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoTGluZXM7XG59XG5cbi8qXG5Db252ZXJ0cyBhIHBhdGhMaW5lcyBhcnJheSAoYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIGEgc3RhcnRQb2ludCxcbmRpcmVjdGlvbiBhbmQgYSBkaXN0YW5jZSkgaW50byBhbiBhcnJheSBvZiBncmlkIGJsb2NrcyAoKVxuTm90ZSB0aGF0IHRoZXJlIHdpbGwgYmUgc29tZSBvdmVybGFwIHdpdGggYmxvY2tzLCBob3dldmVyLFxuYXMgdGhleSBhcmUgb25seSB1c2VkIHRvIHNldCBncmlkIHBvc2l0aW9ucyB0byBub3QgZW1wdHksIG92ZXJsYXAgaXMgbm90IGFuIGlzc3VlXG4qL1xuZnVuY3Rpb24gX2NyZWF0ZVBhdGhCbG9ja3MocGF0aExpbmVzKSB7XG4gICAgdmFyIGJsb2NrcyA9IFtdO1xuICAgIC8vIExvb3BzIHRocm91Z2ggYWxsIHRoZSBwYXRoTGluZXMgYW5kIGNyZWF0ZXMgYmxvY2tzIGJhc2VkIG9uIHRoYXRcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhMaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBibG9ja0Ftb3VudCByZWZlcnMgdG8gdGhlIGFtb3VudCBvZiBibG9ja3MgdGhhdCBmb2xsb3cgdGhlIHBhdGhcbiAgICAgICAgdmFyIGJsb2NrQW1vdW50ID0gTWF0aC5mbG9vcihwYXRoTGluZXNbaV0uZGlzdGFuY2UgLyAyNSkgKyAxLFxuICAgICAgICAgICAgcGF0aERpcmVjdGlvbjtcbiAgICAgICAgLyogU2V0IGRpcmVjdGlvblxuICAgICAgICB4OiAxID0gcmlnaHRcbiAgICAgICAgeDogLTEgPSBsZWZ0XG4gICAgICAgIHk6IDEgPSBkb3duXG4gICAgICAgIHk6IC0xID0gdXBcbiAgICAgICAgT2Zmc2V0IHZhbHVlcyBoZWxwIGNlbnRlciB0aGUgZ3JpZCBibG9ja3MgKGkuZS4gaW5saW5lIHdpdGggdGhlIGRpcmVjdGlvbilcbiAgICAgICAgU2lkZSB2YWx1ZXMgYXJlIHVzZWQgdG8gZGVmaW5lIHdoaWNoIHNpZGUgdGhlIGJsb2NrcyBhcmUgb24gcmVsYXRpdmUgdG9cbiAgICAgICAgdGhlIHBhdGggZGlyZWN0aW9uIChpLmUuIGhvcml6b250YWxseSBvciB2ZXJ0aWNhbGx5KVxuICAgICAgICAqL1xuICAgICAgICBzd2l0Y2ggKHBhdGhMaW5lc1tpXS5kaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgXCJ1cFwiOlxuICAgICAgICAgICAgICAgIHBhdGhEaXJlY3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgIHk6IC0xLFxuICAgICAgICAgICAgICAgICAgICB4U2lkZTogMTIuNSxcbiAgICAgICAgICAgICAgICAgICAgeVNpZGU6IDBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZG93blwiOlxuICAgICAgICAgICAgICAgIHBhdGhEaXJlY3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgIHk6IDEsXG4gICAgICAgICAgICAgICAgICAgIHhTaWRlOiAxMi41LFxuICAgICAgICAgICAgICAgICAgICB5U2lkZTogMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgICAgICAgcGF0aERpcmVjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogLTEsXG4gICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIHhTaWRlOiAwLFxuICAgICAgICAgICAgICAgICAgICB5U2lkZTogMTIuNVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgICAgICAgIHBhdGhEaXJlY3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IDEsXG4gICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIHhTaWRlOiAwLFxuICAgICAgICAgICAgICAgICAgICB5U2lkZTogMTIuNVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkaXJlY3Rpb24gcHJvdmlkZWQgaW4gcGF0aExpbmVzXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAgQ3JlYXRlcyBibG9jayBlcXVhbCB0byBkb3VibGUgdGhlIGFtb3VudCBvZiB0aGUgYmxvY2tBbW91bnQgKHRoZSBlcXVpdmFsZW50IGFtb3VudCBvZiBibG9ja3MgdG8gdGhlIHBhdGggZGlzdGFuY2UpXG4gICAgICAgIGJsb2NrQmVmb3JlIHJlZmVycyB0byBibG9ja3MgZWl0aGVyIHRvIHRoZSBsZWZ0IG9yIHRvcCBvZiB0aGUgcGF0aFxuICAgICAgICBibG9ja0FmdGVyIHJlZmVycyB0byBibG9ja3MgZWl0aGVyIHRvIHRoZSByaWdodCBvciBiZWxvdyBvZiB0aGUgcGF0aFxuICAgICAgICBDcmVhdGVzIGJsb2NrIGxvY2F0aW9ucyBhbmQgZ2l2ZXMgdGhlbSBvZmZzZXRzIHRvIHRoZWlyIGNlbnRlciBwb3NpdGlvbnMgKGZvciBjbGFyaXR5IGluIGNvbnZlcnRpbmcgdG8gYmxvY2tzKVxuICAgICAgICAqL1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJsb2NrQW1vdW50OyBqKyspIHtcblxuICAgICAgICAgICAgdmFyIGJsb2NrQmVmb3JlID0ge1xuXG4gICAgICAgICAgICAgICAgeDogcGF0aExpbmVzW2ldLnN0YXJ0UG9pbnQueCArXG4gICAgICAgICAgICAgICAgICAgIHBhdGhEaXJlY3Rpb24ueFNpZGUgK1xuICAgICAgICAgICAgICAgICAgICAocGF0aERpcmVjdGlvbi54ICogMjUgKiBqKSxcblxuICAgICAgICAgICAgICAgIHk6IHBhdGhMaW5lc1tpXS5zdGFydFBvaW50LnkgK1xuICAgICAgICAgICAgICAgICAgICBwYXRoRGlyZWN0aW9uLnlTaWRlICtcbiAgICAgICAgICAgICAgICAgICAgKHBhdGhEaXJlY3Rpb24ueSAqIDI1ICogaiApXG5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYmxvY2tBZnRlciA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogcGF0aExpbmVzW2ldLnN0YXJ0UG9pbnQueCArXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoRGlyZWN0aW9uLnhTaWRlICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChwYXRoRGlyZWN0aW9uLnggKiAyNSAqIGopLFxuXG4gICAgICAgICAgICAgICAgICAgIHk6IHBhdGhMaW5lc1tpXS5zdGFydFBvaW50LnkgICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhEaXJlY3Rpb24ueVNpZGUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHBhdGhEaXJlY3Rpb24ueSAqIDI1ICogailcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBibG9ja3MucHVzaCh1dGlscy5jb252ZXJ0VG9CbG9jayhibG9ja0JlZm9yZSkpO1xuICAgICAgICAgICAgYmxvY2tzLnB1c2godXRpbHMuY29udmVydFRvQmxvY2soYmxvY2tBZnRlcikpO1xuICAgICAgICB9XG5cblxuICAgIH1cblxuICAgIHJldHVybiBibG9ja3Ncbn1cblxuLy8gR3JpZCBpcyAzNiBieSAyNFxuLy8gY2FuIGJlIGluaXRpYXRlZCBieSBbeF1beV0gLSBlYWNoIGJsb2NrIGhhcyBhIGJvb2xlYW4gdG8gcmVwcmVzZW50IHdoZXRoZXIgc29tZXRoaW5nIGlzIHRoZXJlXG5mdW5jdGlvbiBfaW5pdGlhdGVHcmlkKHBhdGhMaW5lcykge1xuICAgIHZhciBncmlkID0gW10sXG4gICAgICAgIGJsb2NrcyA9IF9jcmVhdGVQYXRoQmxvY2tzKHBhdGhMaW5lcyk7XG4gICAgLy8gQ3JlYXRlIHRoZSBncmlkXG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCAzNjsgeCsrKSB7XG4gICAgICAgIGdyaWRbeF0gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCAyNDsgeSsrKSB7XG4gICAgICAgICAgICBncmlkW3hdW3ldID0ge1xuICAgICAgICAgICAgICAgIGVtcHR5OiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIExvb3AgdGhyb3VnaCB0aGUgYmxvY2tzICh3aGljaCBhcmUgb24gdGhlIHBhdGgpIGFuZFxuICAgIGJsb2Nrcy5tYXAoZnVuY3Rpb24oYmxvY2ssIGkpIHtcbiAgICAgICAgZ3JpZFtibG9jay54XVtibG9jay55XSA9IHtcbiAgICAgICAgICAgIGVtcHR5OiBmYWxzZVxuICAgICAgICB9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGdyaWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdhbWVFbmdpbmU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2pzL2NsYXNzZXMvR2FtZS5qc1xuICoqIG1vZHVsZSBpZCA9IDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBtb25zdGVyRGF0YSA9IHJlcXVpcmUoXCIuLi9nYW1lRGF0YS9tb25zdGVyZGF0YS5qc1wiKSxcbiAgICB1dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy5qc1wiKTtcblxudmFyIE1vbnN0ZXIgPSBmdW5jdGlvbihpZCkge1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmN1cnJlbnRIcCA9IG1vbnN0ZXJEYXRhW2lkXS5tYXhIcDtcbiAgICB0aGlzLm1heEhwID0gbW9uc3RlckRhdGFbaWRdLm1heEhwO1xuICAgIHRoaXMuYmFzZU1zID0gbW9uc3RlckRhdGFbaWRdLmJhc2VNczsgLy8gTW92ZW1lbnQgc3BlZWQgLSBcInVuaXRzXCIgcGVyIHNlY29uZFxuICAgIHRoaXMudHlwZSA9IG1vbnN0ZXJEYXRhW2lkXS50eXBlO1xuICAgIHRoaXMuZGlzdGFuY2VUcmF2ZWxsZWQgPSAwO1xuICAgIHRoaXMucG9zaXRpb24gPSB7fTsgLy8gSW5pdGlhbCBwb3NpdGlvbiBpcyBkZWZpbmVkIGJ5IHRoZSBwYXRoXG4gICAgdGhpcy5zaWRlTGVuZ3RoID0gMzA7XG59O1xuLy8gTWV0aG9kIHRoZSBnYW1lIG9iamVjdCB1c2VzIHRvIG1vdmUgbW9uc3RlcnNcbk1vbnN0ZXIucHJvdG90eXBlLnJ1bkN5Y2xlID0gZnVuY3Rpb24oKSB7XG5cbn1cblxuTW9uc3Rlci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKCkge1xuICAgIGR5bmFtaWNDb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGR5bmFtaWNDb250ZXh0LnJlY3QodGhpcy5wb3NpdGlvbi54LCB0aGlzLnBvc2l0aW9uLnksIDMwLCAzMCk7XG4gICAgZHluYW1pY0NvbnRleHQuc3Ryb2tlKCk7XG4gICAgZHluYW1pY0NvbnRleHQuZmlsbFN0eWxlID0gXCJyZWRcIjtcbiAgICBkeW5hbWljQ29udGV4dC5maWxsUmVjdCh0aGlzLnBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi55ICsgMzAvMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzMCAqIHRoaXMuY3VycmVudEhwL3RoaXMubWF4SHAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMzAvMyk7XG4gICAgZHluYW1pY0NvbnRleHQuY2xvc2VQYXRoKCk7XG5cbn1cblxuTW9uc3Rlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXG59O1xuXG5Nb25zdGVyLnByb3RvdHlwZS5jaGVja0RlYXRoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudEhwIDw9IDAgfHwgdGhpcy5wb3NpdGlvbi5lbmQ7XG59O1xuXG5Nb25zdGVyLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24ocGF0aExpbmVzKSB7XG4gICAgdGhpcy5kaXN0YW5jZVRyYXZlbGxlZCArPSB0aGlzLmJhc2VNcztcbiAgICB0aGlzLnBvc2l0aW9uID0gdXRpbHMuY29udmVydERpc3RhbmNlVG9Db29yZGluYXRlcyh0aGlzLmRpc3RhbmNlVHJhdmVsbGVkLCBwYXRoTGluZXMpO1xufTtcblxuLy8gQ2FuIHRha2UgaW4gYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBudW1iZXJcbk1vbnN0ZXIucHJvdG90eXBlLnVwZGF0ZUhwID0gZnVuY3Rpb24oaHBDaGFuZ2UpIHtcbiAgICB0aGlzLmN1cnJlbnRIcCArPSBocENoYW5nZTtcblxuICAgIGlmICh0aGlzLmN1cnJlbnRIcCA+IHRoaXMubWF4SHApIHtcbiAgICAgICAgdGhpcy5jdXJyZW50SHAgPSB0aGlzLm1heEhwO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTW9uc3RlcjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvY2xhc3Nlcy9Nb25zdGVyLmpzXG4gKiogbW9kdWxlIGlkID0gOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbW9uc3RlcjE6IHtcbiAgICAgICAgbWF4SHA6IDMwLFxuICAgICAgICBiYXNlTXM6IDEwLFxuICAgICAgICB0eXBlOiAxIC8vIENoYW5nZSB0aGlzIHR5cGUgbGF0ZXJcbiAgICB9XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9qcy9nYW1lRGF0YS9tb25zdGVyZGF0YS5qc1xuICoqIG1vZHVsZSBpZCA9IDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHBhdGg6IFtcbiAgICAgICAge3g6IDAsIHk6IDUwMH0sXG4gICAgICAgIHt4OiA3NSwgeTogNTAwfSxcbiAgICAgICAge3g6IDc1LCB5OiAxMDB9LFxuICAgICAgICB7eDogMjI1LCB5OiAxMDB9LFxuICAgICAgICB7eDogMjI1LCB5OiA1MDB9LFxuICAgICAgICB7eDogMzc1LCB5OiA1MDB9LFxuICAgICAgICB7eDogMzc1LCB5OiAxMDB9LFxuICAgICAgICB7eDogNTI1LCB5OiAxMDB9LFxuICAgICAgICB7eDogNTI1LCB5OiA1MDB9LFxuICAgICAgICB7eDogNjc1LCB5OiA1MDB9LFxuICAgICAgICB7eDogNjc1LCB5OiAxMDB9LFxuICAgICAgICB7eDogODI1LCB5OiAxMDB9LFxuICAgICAgICB7eDogODI1LCB5OiA1MDB9LFxuICAgICAgICB7eDogOTAwLCB5OiA1MDB9XG4gICAgXVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9qcy9nYW1lRGF0YS9wYXRoZGF0YS5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9