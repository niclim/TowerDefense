/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/src/js/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	// Canvas
	__webpack_require__(2);
	
	// User interaction elements
	__webpack_require__(3);


/***/ },
/* 2 */
/***/ function(module, exports) {

	// background contains the static canvas elements
	var background = document.getElementById("static");
	var backgroundContext = background.getContext("2d");
	
	// Settings for the background - move out to a separate file
	var settings = {
	    backgroundColor: "#8CD1E6",
	    pathColor: "gray"
	}
	
	// Drawing the background
	backgroundContext.fillStyle = settings.backgroundColor;
	backgroundContext.fillRect(0, 0, background.width, background.height);
	
	/* Main path will go from [0, 500], [75, 500], [75, 100], [225, 100], [225, 500], [375, 500], [375, 100], [525, 100], [525, 500], [675, 500], [675, 100], [825, 100], [825, 500], [900, 500] */
	
	// Drawing the path - width of the path is 50px
	backgroundContext.fillStyle = settings.pathColor;
	
	backgroundContext.beginPath();
	
	// For the bottom part of the path
	backgroundContext.moveTo(0, 525);
	
	backgroundContext.lineTo(100, 525);
	backgroundContext.lineTo(100, 125); // Top
	backgroundContext.lineTo(200, 125);
	backgroundContext.lineTo(200, 525); // Bottom
	backgroundContext.lineTo(400, 525);
	backgroundContext.lineTo(400, 125); // Top
	backgroundContext.lineTo(500, 125);
	backgroundContext.lineTo(500, 525); // Bottom
	backgroundContext.lineTo(700, 525);
	backgroundContext.lineTo(700, 125); // Top
	backgroundContext.lineTo(800, 125);
	backgroundContext.lineTo(800, 525); // Bottom
	
	//Middle section to the side
	backgroundContext.lineTo(900, 525);
	backgroundContext.lineTo(900, 475);
	backgroundContext.lineTo(850, 475);
	
	// For the top part of the path
	backgroundContext.lineTo(850, 75);
	backgroundContext.lineTo(650, 75);
	backgroundContext.lineTo(650, 475);
	backgroundContext.lineTo(550, 475);
	backgroundContext.lineTo(550, 75);
	backgroundContext.lineTo(350, 75);
	backgroundContext.lineTo(350, 475);
	backgroundContext.lineTo(250, 475);
	backgroundContext.lineTo(250, 75);
	backgroundContext.lineTo(50, 75);
	backgroundContext.lineTo(50, 475);
	
	// End section
	backgroundContext.lineTo(0, 475);
	
	backgroundContext.fill();
	// backgroundContext.lineTo();
	
	// draw a grid (for development purposes)
	var width = 900, height = 600;
	// draw vertical lines
	for (var i = 0; i < width; i += 25) {
	    backgroundContext.moveTo(i, 0);
	    backgroundContext.lineTo(i, height);
	    backgroundContext.stroke();
	}
	// draw horizontal lines
	for (var i = 0; i < height; i += 25) {
	    backgroundContext.moveTo(0, i);
	    backgroundContext.lineTo(width, i);
	    backgroundContext.stroke();
	}


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	// Initiate all the components
	var Tower = __webpack_require__(4),
	    GameEngine = __webpack_require__(7);
	
	// Import and declare utility functions
	var utils = __webpack_require__(6);
	
	// Cache reused DOM elements
	var infoName = document.getElementById("info-name"),
	    infoIcon = document.getElementById("info-icon"),
	    infoBox1 = document.getElementById("info-box-1"),
	    infoBox2 = document.getElementById("info-box-2"),
	    infoBox3 = document.getElementById("info-box-3"),
	    infoBox4 = document.getElementById("info-box-4"),
	    levelInfo = document.getElementById("level"),
	    goldInfo = document.getElementById("gold"),
	    livesInfo = document.getElementById("lives");
	
	var towerCards = document.getElementsByClassName("tower-card"),
	    towerCardList = [];
	// Convert from nodelist to array
	towerCards = Array.prototype.slice.call(towerCards);
	
	/*
	Create state variables - These are modified on user interaction events
	State variables
	activeCanvasElement - Changed on a mouse click event on a monster, tower or nothing
	activeTowerSelected - The name of the tower that is being placed by the user
	activeMessage - Message displayed in the canvas (can be used for new levels, invalid tower placements, etc)
	canvasMousePosition -
	    onCanvas - boolean to represent whether the mouse is currently on the canvas
	    towerPosition - object with a grid value and coordinate value and sides
	        grid - the top left block of the tower being placed - towers are a 2x2 grid
	        coordinate - the top left corner coordinate
	        sides - 50 px
	    mousePosition - the current mouse coordinates
	*/
	
	var activeCanvasElement = {type: null},
	    activeTowerSelected = null,
	    activeMessage = {message: null},
	    canvasMousePosition = {
	        onCanvas: false,
	        towerPosition: {},
	        mousePosition: {}
	    };
	
	//  creates global variables
	game = new GameEngine;
	dynamicCanvas = document.getElementById('dynamic');
	dynamicContext = dynamicCanvas.getContext('2d');
	
	runCycle = function() {
	    game.runCycle();
	    updateGameInformation();
	    // I assume the game is going to run fast than this after? if not need to add updateGameInformation to a few other places
	    setTimeout(runCycle, 1000);
	}
	
	renderCycle = function() {
	    game.render();
	    // Renders the information and error messages based on the state variables
	    renderTowerPlacement();
	    renderMessage();
	    requestAnimationFrame(renderCycle);
	}
	
	/* ================== Render functions =================*/
	/* =====================================================*/
	// Render functions run every game cycle (on the renderCycle function call)
	// Renders based on the state variables
	
	function updateGameInformation() {
	    livesInfo.innerHTML = game.userLives;
	    goldInfo.innerHTML = game.userGold;
	    levelInfo.innerHTML = game.level;
	
	    if (activeCanvasElement.type === "monster") {
	        renderMonsterInformation(activeCanvasElement.id, activeCanvasElement.index);
	    } else if (activeCanvasElement.type === "tower") {
	        renderTowerInformation(activeCanvasElement.id, activeCanvasElement.index);
	    } else {
	        renderDefaultInformation();
	    }
	}
	
	// ID refers to the type of monster and index is the index of the active monster in the active monster's array
	function renderMonsterInformation(id, index) {
	    var currentHp = game.activeMonsters[index].currentHp,
	        maxHp = game.activeMonsters[index].maxHp,
	        type = game.activeMonsters[index].type;
	    infoName.innerHTML = id;
	    // Change icon to active monster - use a sprite
	    infoBox1.innerHTML = "HP: " + currentHp + " / " + maxHp;
	    infoBox2.innerHTML = "Type: " + type;
	    infoBox3.innerHTML = "Strengths: All sorts mate" ;
	    infoBox4.innerHTML = "Weaknesses: Ducks" ;
	}
	
	// ID refers to the type of tower and index is the index of the active tower in the active tower's array
	function renderTowerInformation(id, index) {
	    infoName.innerHTML = id;
	    // Change icon to active monster - use a sprite
	    infoBox1.innerHTML = "Damage: <br> Range: <br> Effect: ";
	    infoBox2.innerHTML = "Attack Speed: <br> Type: " ;
	    infoBox3.innerHTML = "<a class='waves-effect waves-light btn red'>Upgrade</a>" ;
	    infoBox4.innerHTML = "<a class='waves-effect waves-light btn red'>Sell</a>" ;
	    // Change icon to tower monster - use a sprite
	
	}
	
	function renderDefaultInformation() {
	    infoName.innerHTML = "Awesome TD";
	    // Change icon to default image - use a sprite
	    infoBox1.innerHTML = "This is some text";
	    infoBox2.innerHTML = "This is different text";
	    infoBox3.innerHTML = "This is ??? text" ;
	    infoBox4.innerHTML = "This 1231241235" ;
	}
	
	// Maybe change this to "renderMessage"
	function renderMessage() {
	    if (activeMessage.message === null) {
	        return;
	    } else {
	        dynamicContext.globalAlpha = activeMessage.timer / 50;
	        dynamicContext.font = '40pt Droid Sans';
	        dynamicContext.textAlign = "center";
	        dynamicContext.fillStyle = "red";
	        dynamicContext.fillText(activeMessage.message, 450, 50);
	        dynamicContext.globalAlpha = 1;
	
	        if (activeMessage.timer === 0) {
	            activeMessage = {message: null}; // Reset error message
	        } else {
	            activeMessage.timer--;
	        }
	    }
	}
	
	function renderTowerPlacement() {
	    if (activeTowerSelected === null ||
	        !canvasMousePosition.onCanvas) {
	        return
	    };
	
	    var coordinates = canvasMousePosition.towerPosition.coordinates;
	    dynamicContext.beginPath();
	    dynamicContext.globalAlpha = 0.5;
	
	    if (true) { // check for valid tower placement
	        dynamicContext.fillStyle = "green";
	        dynamicContext.fillRect(coordinates.x,
	                                coordinates.y,
	                                50,
	                                50
	         );
	
	        dynamicContext.globalAlpha = 0.7;
	        dynamicContext.arc(coordinates.x + 25,
	                           coordinates.y + 25,
	                           30,
	                           0,
	                           2 * Math.PI,
	                           false
	         );
	        dynamicContext.fillStyle = 'gray';
	        dynamicContext.fill();
	
	    } else {
	        // do some sort of logic to highlight the tiles that the tower would be placed on and show the tower on those positions
	        // this would run when tower placement is invalid
	    }
	    dynamicContext.globalAlpha = 1;
	    dynamicContext.closePath();
	}
	
	/* ================ UI Event Listeners =================*/
	/* =====================================================*/
	document.getElementById("start-btn").addEventListener("click", function() {
	    // Hides the modal lightbox
	    document.getElementsByClassName("modal-content")[0].style.display = "none";
	    document.getElementsByClassName("modal-background")[0].style.display = "none";
	
	    // run repeating function that runs game engine run cycle and rendering
	    setTimeout(runCycle, 1000);
	    requestAnimationFrame(renderCycle);
	});
	
	// On clicking the information button, show the information panel
	document.getElementById("information-btn").addEventListener("click", function() {
	    // TODO - add information modal information thingy
	    console.log("show information container here");
	});
	
	/*
	These event listeners control the application by interacting with the game
	object and by changing the state variables (which the render functions use
	to read)
	*/
	towerCards.map(function(towerCard, i) {
	    towerCardList.push(towerCard.getAttribute("data-tower"));
	    towerCard.addEventListener("click", towerCardClick);
	});
	
	document.getElementById("dynamic").onmousemove = onCanvasMouseMovement;
	document.getElementById("dynamic").addEventListener("click", canvasClick);
	
	document.onkeydown = function(e) {
	    if (e.keyCode === 27) {
	        cancelTowerPlacement();
	    }
	}
	
	/* =================== UI Functions ====================*/
	/* =====================================================*/
	/* Click event listener on the tower cards
	Used to control what tower is being actively placed on the canvas
	4 possible flows based on the state of the interface
	1) The tower that was clicked is currently disabled:
	    -> function returns
	2) No towers are actively being placed
	    -> the clicked tower card now becomes the active tower being placed
	3) The clicked tower is the same as the tower actively being placed
	    -> the state is reset so that no towers are actively being placed
	4) The clicked tower is different from the tower actively being placed
	    -> the state is changed to the clicked tower becoming the active tower
	*/
	function towerCardClick() {
	
	    var towerName = this.getAttribute("data-tower"),
	        oldTowerIndex = utils.getTowerCardIndex(towerCardList, activeTowerSelected),
	        newTowerIndex = utils.getTowerCardIndex(towerCardList, towerName);
	
	    if (/disabled/i.test(this.className)) {
	        return;
	
	    } else if (activeTowerSelected === null) {
	        activeTowerSelected = towerName;
	        utils.addClass(towerCards[newTowerIndex], "active");
	        canvasMousePosition.onCanvas = false;
	    } else if (activeTowerSelected === towerName) {
	        cancelTowerPlacement();
	        canvasMousePosition.onCanvas = false;
	    } else {
	        utils.removeClass(towerCards[oldTowerIndex], "active");
	        activeTowerSelected = towerName;
	        utils.addClass(towerCards[newTowerIndex], "active");
	        canvasMousePosition.onCanvas = false;
	
	    }
	}
	
	/*
	Called from towerCardClick (when clicking the active tower card) and on an escape key press
	Resets the active tower placement state to null
	*/
	function cancelTowerPlacement() {
	    utils.removeClass(towerCards[utils.getTowerCardIndex(towerCardList, activeTowerSelected)], "active");
	    activeTowerSelected = null;
	}
	
	/* Mouse move event listener on the canvas
	If the active tower selected state (a tower is being placed by the user):
	    -> update the position of the mouse on the canvas (used by the renderTowerPlacement function)
	otherwise:
	    -> do nothing
	*/
	function onCanvasMouseMovement(e) {
	    if (activeTowerSelected === null) {
	        return
	    };
	
	    var canvasContainer = this.getBoundingClientRect(),
	        position = {};
	
	    position.x = e.clientX - canvasContainer.left;
	    position.y = e.clientY - canvasContainer.top;
	    canvasMousePosition.mousePosition = position;
	    canvasMousePosition.towerPosition = utils.convertPositionToTower(position);
	    canvasMousePosition.onCanvas = true;
	};
	
	
	/* Click event listener on the canvas
	Handles two possible canvas click scenarios
	1) A tower is selected and is actively being placed
	    -> Clicking will validate the tower placement and check the user's gold
	    if both are valid, will tower will be placed (by game object)
	    otherwise, an error message will show up
	2) A tower is not selected and is not being placed
	    -> Will check whether the click position overlaps with the bounding
	    rectangle of monster or tower - if so, it will return the information
	    in the information container
	*/
	function canvasClick(e) {
	    // Get click location relative to the canvas element
	    var canvasContainer = this.getBoundingClientRect(),
	        position = {},
	        towerGridPosition = canvasMousePosition.towerPosition.grid,
	        towerCoordinates = canvasMousePosition.towerPosition.coordinates; // Passes in grid blocks - this is the topLeft block
	
	    position.x = e.clientX - canvasContainer.left;
	    position.y = e.clientY - canvasContainer.top;
	
	    // Runs if the user is placing a tower
	    if (activeTowerSelected !== null) {
	        var towerName = activeTowerSelected,
	            towerPlaced = game.placeTower(towerName, towerGridPosition, towerCoordinates);
	
	        // If the tower was not placed, show an error message
	        if (!towerPlaced.placed) {
	            activeMessage = {
	                message: towerPlaced.message,
	                timer: 50 // frames
	            }
	        }
	
	        utils.removeClass(towerCards[utils.getTowerCardIndex(towerCardList, activeTowerSelected)], "active");
	        activeTowerSelected = null;
	    } else {
	        // User is not running a tower placement
	        activeCanvasElement = game.checkClickLocation(position);
	        updateGameInformation();
	    }
	
	}


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var towerData = __webpack_require__(5),
	    utils = __webpack_require__(6);
	
	// Position refers to the upper left corner of the elements
	// Tower width - 50 x 50
	var Tower = function(position, id) {
	    if (towerData[id] === undefined) {
	        throw Error("Invalid tower name, check html dataattribute or towerdata")
	    }
	    this.id = id;
	    this.damage = towerData[id].damage;
	    this.speed = towerData[id].speed; // Attack speed
	    this.range = towerData[id].range; // Range of the tower
	    this.type = towerData[id].type; // Type of damage
	    this.effect = towerData[id].effect; // Special effect (e.g. slow, splash, etc)
	    this.goldCost = towerData[id].goldCost;
	    this.position = position; // object with x and y coordinates - references the top left corner of the tower
	    this.position.sideLength = 50;
	}
	// Method the game object uses to run towers
	Tower.prototype.runCycle = function() {
	
	}
	// change this to reference a list or something where a name can be used to determine the properties
	// Takes in a monster's position and checks whether that is in range based on the range - returns true or false if in range which can be used to
	Tower.prototype.checkInRange = function(monsterPosition) {
	    // using sqrt((x2-x1)^2 - (y2-y1)^2)
	    var monsterDistance = utils.getPositionDifference(monsterPosition, this.position);
	
	   if (monsterDistance <= this.range) {
	       return true;
	   } else {
	       return false;
	   }
	}
	
	Tower.prototype.draw = function() {
	    dynamicContext.beginPath();
	    dynamicContext.fillStyle = "green";
	    dynamicContext.fillRect(this.position.x,
	                            this.position.y,
	                            50,
	                            50);
	    dynamicContext.closePath();
	}
	
	module.exports = Tower;


/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = {
	    basic: {
	        damage: 10,
	        speed: 10,
	        range: 100,
	        goldCost: 10,
	        type: "basic",
	        effect: "none"
	    }
	};


/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = function() {
	/* ================== Private functions ================*/
	/* =====================================================*/
	// TODO - add tests
	    /*
	    Converts a pathLines array (an array of objects with a startPoint,
	    direction and a distance) into an array of grid blocks ()
	    Note that there will be some overlap with blocks, however,
	    as they are only used to set grid positions to not empty, overlap is not an issue
	    */
	    function _createPathBlocks(pathLines) {
	        var blocks = [];
	        // Loops through all the pathLines and creates blocks based on that
	        for (var i = 0; i < pathLines.length; i++) {
	            // blockAmount refers to the amount of blocks that follow the path
	            var blockAmount = Math.floor(pathLines[i].distance / 25) + 1,
	                pathDirection;
	            /* Set direction
	            x: 1 = right
	            x: -1 = left
	            y: 1 = down
	            y: -1 = up
	            Offset values help center the grid blocks (i.e. inline with the direction)
	            Side values are used to define which side the blocks are on relative to the path direction (i.e. horizontally or vertically)
	            */
	            switch (pathLines[i].direction) {
	                case "up":
	                    pathDirection = {
	                        x: 0,
	                        y: -1,
	                        xOffset: 0,
	                        yOffset: -12.5,
	                        xSide: 12.5,
	                        ySide: 0
	                    }
	                    break;
	                case "down":
	                    pathDirection = {
	                        x: 0,
	                        y: 1,
	                        xOffset: 0,
	                        yOffset: 12.5,
	                        xSide: 12.5,
	                        ySide: 0
	                    }
	                    break;
	                case "left":
	                    pathDirection = {
	                        x: -1,
	                        y: 0,
	                        xOffset: 12.5,
	                        yOffset: 0,
	                        xSide: 0,
	                        ySide: 12.5
	                    }
	                    break;
	                case "right":
	                    pathDirection = {
	                        x: 1,
	                        y: 0,
	                        xOffset: 12.5,
	                        yOffset: 0,
	                        xSide: 0,
	                        ySide: 12.5
	                    }
	                    break;
	                default:
	                    throw new Error("Invalid direction provided in pathLines");
	            }
	
	            // Creates block equal to double the amount of the blockAmount (the equivalent amount of blocks to the path distance)
	            // blockBefore refers to blocks either to the left or top of the path
	            // blockAfter refers to blocks either to the right or below of the path
	            // Creates block locations and gives them offsets to their center positions (for clarity in converting to blocks)
	            for (var j = 0; j < blockAmount; j++) {
	
	                var blockBefore = {
	
	                    x: pathLines[i].startPoint.x +
	                        pathDirection.xOffset -
	                        pathDirection.xSide +
	                        (pathDirection.x * 25 * j),
	
	                    y: pathLines[i].startPoint.y +
	                        pathDirection.yOffset -
	                        pathDirection.ySide +
	                        (pathDirection.y * 25 * j )
	
	                },
	                    blockAfter = {
	                        x: pathLines[i].startPoint.x +
	                            pathDirection.xOffset +
	                            pathDirection.xSide +
	                            (pathDirection.x * 25 * j),
	
	                        y: pathLines[i].startPoint.y  +
	                            pathDirection.yOffset +
	                            pathDirection.ySide +
	                            (pathDirection.y * 25 * j)
	                };
	                blocks.push(_convertToBlock(blockBefore));
	                blocks.push(_convertToBlock(blockAfter));
	            }
	
	
	        }
	
	        return blocks
	    }
	
	    // Takes in a position object with coordinates{x, y}
	    // returns a block object {x, y} with block numbers
	    // Handles edge cases of the block being defined at the edge (36 and 24 which are invalid in the )
	    function _convertToBlock(position) {
	        var block = {
	            x: Math.floor(position.x / 25),
	            y: Math.floor(position.y / 25)
	        };
	        // Adjusts if mouse is at end of container
	        // 36 blocks width and 24 blocks height
	        if (block.x >= 35) {
	            block.x--;
	        }
	
	        if (block.y >= 23) {
	            block.y--;
	        }
	
	        return block;
	    }
	
	    /*
	    Input: Path - an array of objects containing coordinates where the path will run to
	    Output: pathLines - an array of objects containing the startPoint (coordinates), distance of the line and direction (left, right, up, down)
	    */
	    function _convertPathToLines(path) {
	        var pathLines = [];
	        for (var i = 0; i < path.length - 1; i++) {
	            var line = {};
	
	            // Assume that the direction is only 4 ways
	            if (path[i+1].x - path[i].x === 0) {
	
	                if (path[i+1].y - path[i].y > 0) {
	                    line.direction = "down";
	                } else {
	                    line.direction = "up";
	                }
	            } else {
	                if (path[i+1].x - path[i].x === 0 > 0) {
	
	                    line.direction = "left";
	                } else {
	                    line.direction = "right";
	                }
	            }
	            line.startPoint = path[i];
	            line.distance = getPositionDifference(path[i], path[i+1]);
	            pathLines.push(line);
	        }
	
	        return pathLines;
	    }
	
	
	/* ================== Public functions =================*/
	/* =====================================================*/
	    function addClass(element, cssClass) {
	        if (element.className === "") {
	            element.className = cssClass;
	        } else {
	            element.className += " " + cssClass;
	        }
	    }
	
	    function removeClass(element, cssClass) {
	        var arrayOfClasses = element.className.split(" ");
	        for (var i = 0, j = arrayOfClasses.length; i < j; i++) {
	            if (arrayOfClasses[i] === cssClass) {
	                arrayOfClasses.splice(i, 1);
	                i--; j--;
	            }
	        }
	        element.className = arrayOfClasses.join(" ");
	    }
	
	    // Gets the index of the tower cards based on a tower's name
	    function getTowerCardIndex(towerCardList, towerName) {
	        return towerCardList.indexOf(towerName);
	    }
	
	    /*
	    Takes in a position object (x and y coordinates)
	    Returns the top left block position and topleft coordinate of the tower
	    Grid blocks are in 25x25 block increments
	    */
	    function convertPositionToTower(position) {
	        var towerPosition = {
	            grid: {},
	            coordinates: {},
	            side: 50
	        };
	
	        towerPosition.grid = _convertToBlock(position);
	
	        // Container width and height 900 and 600 px respectively
	        towerPosition.coordinates.x = (towerPosition.grid.x / 36) * 900;
	        towerPosition.coordinates.y = (towerPosition.grid.y / 24) * 600;
	        return towerPosition;
	    }
	
	    /*
	    checkIfInSquare checks whether a point is in a square (which is a monster or a tower)
	
	    Takes in three arguments
	    point - a object with x and y coordinates
	    topLeftPoint - an object with x and y coordinates of the top left corner of the square
	    sideLength - the length of the square
	
	    Returns a boolean - true if the click overlaps with an element and false
	    if it does not
	    */
	    function checkIfInSquare(point, topLeftPoint, sideLength) {
	        if (point.x >= topLeftPoint.x
	        && point.x <= topLeftPoint.x + sideLength
	        && point.y >= topLeftPoint.y
	        && point.y <= topLeftPoint.y + sideLength) {
	            return true;
	        } else {
	            return false;
	        }
	    }
	
	    // Grid is 36 by 24
	    // can be initiated by [x][y] - each block has a boolean to represent whether something is there
	    function initiateGrid(path) {
	        var grid = [],
	            pathLines = _convertPathToLines(path),
	            blocks = _createPathBlocks(pathLines);
	
	        // Create the grid
	        for (var x = 0; x < 36; x++) {
	            grid[x] = [];
	            for (var y = 0; y < 24; y++) {
	                grid[x][y] = true
	            }
	        }
	        blocks.map(function(block, i) {
	            grid[block.x][block.y] = false;
	        });
	        console.table(grid);
	
	        return grid;
	    };
	
	    function getPositionDifference(position1, position2) {
	        return Math.sqrt(
	                Math.pow(position1.x-position2.x, 2) +
	                Math.pow(position1.y-position2.y, 2)
	        );
	    }
	
	    return {
	        addClass: addClass,
	        removeClass: removeClass,
	        getTowerCardIndex: getTowerCardIndex,
	        convertPositionToTower: convertPositionToTower,
	        checkIfInSquare: checkIfInSquare,
	        initiateGrid: initiateGrid,
	        getPositionDifference: getPositionDifference
	    }
	}();


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	//  require Monster to gain access
	var Monster = __webpack_require__(8),
	    Tower = __webpack_require__(4),
	    towerData = __webpack_require__(5),
	    utils = __webpack_require__(6),
	    pathCoordinates = __webpack_require__(10);
	
	var GameEngine = function() {
	    this.userGold = 10;
	    this.level = 1;
	    this.userLives = 30;
	    this.activeMonsters = []; // List of active monsters in the
	    this.towers = []; // object of tower objects
	    this.timer = 1;
	    this.gameGrid = utils.initiateGrid(pathCoordinates.path);
	}
	
	GameEngine.prototype.addMonster = function(name) {
	    // add monster (specified by name) to game
	    var monster = new Monster("monster1");
	    this.activeMonsters.push(monster);
	}
	
	GameEngine.prototype.addTower = function(id, position, goldCost) {
	    this.userGold -= goldCost;
	    var tower = new Tower(position, id);
	    this.towers.push(tower);
	
	}
	
	// method to check gold before place tower or upgrade
	GameEngine.prototype.checkGold = function(goldCost) {
	    if (goldCost <= this.userGold) {
	        return true;
	    } else {
	        return false;
	    }
	};
	
	GameEngine.prototype.gameOver = function() {
	
	}
	
	GameEngine.prototype.gameWon = function() {
	
	}
	
	// New level method
	GameEngine.prototype.nextLevel = function() {
	
	}
	
	GameEngine.prototype.render = function() {
	    // send state to the display object to render
	    dynamicContext.beginPath();
	    dynamicContext.clearRect(0, 0, dynamicCanvas.width, dynamicCanvas.height);
	
	    // Render towers first so that if monsters are larger they show above towers
	    for (var i = 0, j = this.towers.length; i < j; i ++) {
	        this.towers[i].draw();
	    }
	
	    //  loop through list of active monsters and render them
	    //  TODO probably need to find a better way to rend them apart from random rectangle
	    for (var i = 0, j = this.activeMonsters.length; i < j; i ++) {
	        this.activeMonsters[i].draw();
	    }
	
	    dynamicContext.closePath();
	
	    // dynamicContext.
	};
	
	GameEngine.prototype.runCycle = function() {
	    //  beginning of cycle check if any monsters have died if so remove from active monsters
	    this.checkMonsterDeath();
	    // loop through active monsters and towers and run the cycle
	    // Each runCycle method returns information for the gameEngine to
	    // process (e.g. the monster died, tower changed)
	
	    //  timer to add monsters
	    this.timer--;
	    if (this.timer < 1) {
	        this.addMonster('blah');
	        this.timer = 10;
	    }
	    for (var i = 0, j = this.activeMonsters.length; i < j; i ++) {
	        this.activeMonsters[i].move();
	    }
	    // Send information to render
	}
	
	// method to upgrade tower
	
	// grid tower
	GameEngine.prototype.validateTowerPlacement = function(gridPosition) {
	    var positionValid = true;
	    // returns true or false whether tower placement is valid
	    return positionValid;
	}
	
	GameEngine.prototype.checkMonsterDeath = function() {
	    for (var i = 0, j = this.activeMonsters.length; i < j; i ++) {
	        if (this.activeMonsters[i].checkDeath()) {
	            this.activeMonsters.splice(i, 1);
	            i--;
	            j--;
	        }
	    }
	}
	
	/*
	Takes in a position object (location of the click)
	Returns an object with information about what is at that position
	{type: null} if nothing found
	*/
	GameEngine.prototype.checkClickLocation = function(position) {
	    var element = {};
	    // Loops through activeMonsters
	    for (var i = 0; i < this.activeMonsters.length; i++) {
	        if (utils.checkIfInSquare(position, this.activeMonsters[i].position, this.activeMonsters[i].position.sideLength)) {
	            element.type = "monster";
	            element.id = this.activeMonsters[i].id;
	            element.index = i;
	            break;
	        }
	    }
	
	    // If nothing was found, loop through towers
	    if (element.type === undefined) {
	        for (var i = 0; i < this.towers.length; i++) {
	            if (utils.checkIfInSquare(position, this.towers[i].position, this.towers[i].position.sideLength)) {
	                element.type = "tower";
	                element.id = this.towers[i].id;
	                element.index = i;
	                break;
	            }
	        }
	    }
	
	    // If no towers or monsters found return a type of null
	    if (element.type === undefined) {
	        element.type = null;
	    }
	
	    return element;
	}
	
	/*
	placeTower handles the validation of the tower placement (position and sufficient gold)
	Takes in 3 arguments:
	towerName - string specifying what tower is being placed
	gridPosition - top left grid block of where the tower would be placed
	towerCoordinates - top left coordinate of a tower
	Returns an object with a boolean to represent whether the tower is placed and an error message if the tower was not placed
	*/
	GameEngine.prototype.placeTower = function(towerName, gridPosition, towerCoordinates) {
	    var goldCost = towerData[towerName].goldCost;
	    // Validate tower placement
	    if (this.validateTowerPlacement(gridPosition)
	    && this.checkGold(goldCost)) {
	
	        this.addTower(towerName, towerCoordinates, goldCost);
	        return {
	            placed: true
	        };
	    } else {
	
	        if (!this.validateTowerPlacement(gridPosition)) {
	            return {
	                placed: false,
	                message: "Invalid Tower Placement"
	            }
	        } else {
	            return {
	                placed: false,
	                message: "Not Enough Gold"
	            }
	        }
	    }
	
	}
	
	
	module.exports = GameEngine;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var monsterData = __webpack_require__(9);
	
	var Monster = function(id) {
	    this.id = id;
	    this.currentHp = monsterData[id].maxHp;
	    this.maxHp = monsterData[id].maxHp;
	    this.baseMs = monsterData[id].baseMs; // Movement speed - "units" per second
	    this.type = monsterData[id].type;
	    this.position = { // All monsters are created in the same position - this position is referencing the topleft corner of the object
	        x: 0,
	        y: 485,
	        sideLength: 30
	    }
	};
	// Method the game object uses to move monsters
	Monster.prototype.runCycle = function() {
	
	}
	
	Monster.prototype.draw = function() {
	    dynamicContext.beginPath();
	    dynamicContext.rect(this.position.x, this.position.y, 30, 30);
	    dynamicContext.stroke();
	    dynamicContext.fillStyle = "red";
	    dynamicContext.fillRect(this.position.x,
	                            this.position.y + 30/3,
	                            30 * this.currentHp/this.maxHp,
	                            30/3);
	    dynamicContext.closePath();
	
	}
	
	Monster.prototype.destroy = function() {
	
	};
	
	Monster.prototype.checkDeath = function() {
	    return this.currentHp <= 0;
	};
	
	// Expects up, down, left or right
	Monster.prototype.move = function(direction) {
	    var speed = this.baseMs;
	
	    // some basic monster Movement
	    //  NOTE such a hassle to figure this out
	    //  TODO not finished, not even going to try and finish will figure out how this should work later
	    if (this.position.x <= 50 && this.position.y < 500) {
	        this.position.x += speed;
	    } else if (this.position.x >= 50 && this.position.y >= 90) {
	        this.position.y -= speed;
	    } else if (this.position.x <= 180 && this.position.y >= 80) {
	        this.position.x += speed;
	    }
	
	    //  may not be the best way to do this but ill keep it because not even sure how to do this movement part
	    // if (typeof direction !== "string") {
	    //     throw new TypeError("direction is not a string");
	    // }
	    // direction = direction.toLowerCase();
	    // switch (direction) {
	    //     case "up":
	    //     case "down":
	    //     case "left":
	    //     case "right":
	    //     default:
	    //         throw new Error("Invalid direction");
	    // }
	};
	
	// Can take in a positive or negative number
	Monster.prototype.updateHp = function(hpChange) {
	    this.currentHp += hpChange;
	
	    if (this.currentHp > this.maxHp) {
	        this.currentHp = this.maxHp;
	    }
	};
	
	module.exports = Monster;


/***/ },
/* 9 */
/***/ function(module, exports) {

	module.exports = {
	    monster1: {
	        maxHp: 30,
	        baseMs: 10,
	        type: 1 // Change this type later
	    }
	};


/***/ },
/* 10 */
/***/ function(module, exports) {

	module.exports = {
	    path: [
	        {x: 0, y: 500},
	        {x: 75, y: 500},
	        {x: 75, y: 100},
	        {x: 225, y: 100},
	        {x: 225, y: 500},
	        {x: 375, y: 500},
	        {x: 375, y: 100},
	        {x: 525, y: 100},
	        {x: 525, y: 500},
	        {x: 675, y: 500},
	        {x: 675, y: 100},
	        {x: 825, y: 100},
	        {x: 825, y: 500},
	        {x: 900, y: 500}
	    ]
	}


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYzM1ZjJiYmIwMGEzZDY0YTBiZjAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2VudHJ5LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9iYWNrZ3JvdW5kLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NsYXNzZXMvVG93ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2dhbWVEYXRhL3Rvd2VyZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NsYXNzZXMvR2FtZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY2xhc3Nlcy9Nb25zdGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9nYW1lRGF0YS9tb25zdGVyZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZ2FtZURhdGEvcGF0aGRhdGEuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQSxvQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUEyQixXQUFXO0FBQ3RDO0FBQ0Esc0JBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQTZCLGVBQWU7QUFDNUMsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFxQjtBQUNyQjtBQUNBLDBFQUF5RTs7QUFFekU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdFVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFxQztBQUNyQyxzQ0FBcUM7QUFDckMsb0NBQW1DO0FBQ25DLHdDQUF1QztBQUN2QztBQUNBLDhCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLGlCQUFpQjs7QUFFNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQSxvREFBbUQ7QUFDbkQsZ0NBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUIscUJBQXFCO0FBQzVDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsY0FBYTtBQUNiOztBQUVBO0FBQ0Esa0JBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtREFBa0QsT0FBTztBQUN6RDtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCLDRCQUEyQjtBQUMzQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF1QixRQUFRO0FBQy9CO0FBQ0EsNEJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOzs7Ozs7O0FDL1FEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE2QjtBQUM3QixzQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBMkMsT0FBTztBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBbUQsT0FBTztBQUMxRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFtRCxPQUFPO0FBQzFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9EQUFtRCxPQUFPO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUMsV0FBVztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLGdDQUFnQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7Ozs7OztBQ3hMQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUF5QztBQUN6QztBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ05BO0FBQ0E7QUFDQSxVQUFTLGFBQWE7QUFDdEIsVUFBUyxjQUFjO0FBQ3ZCLFVBQVMsY0FBYztBQUN2QixVQUFTLGVBQWU7QUFDeEIsVUFBUyxlQUFlO0FBQ3hCLFVBQVMsZUFBZTtBQUN4QixVQUFTLGVBQWU7QUFDeEIsVUFBUyxlQUFlO0FBQ3hCLFVBQVMsZUFBZTtBQUN4QixVQUFTLGVBQWU7QUFDeEIsVUFBUyxlQUFlO0FBQ3hCLFVBQVMsZUFBZTtBQUN4QixVQUFTLGVBQWU7QUFDeEIsVUFBUztBQUNUO0FBQ0EiLCJmaWxlIjoibWFpbi5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvc3JjL2pzL1wiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgYzM1ZjJiYmIwMGEzZDY0YTBiZjBcbiAqKi8iLCIvLyBDYW52YXNcbnJlcXVpcmUoXCIuL2JhY2tncm91bmQuanNcIik7XG5cbi8vIFVzZXIgaW50ZXJhY3Rpb24gZWxlbWVudHNcbnJlcXVpcmUoXCIuL2ludGVyZmFjZS5qc1wiKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvZW50cnkuanNcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBiYWNrZ3JvdW5kIGNvbnRhaW5zIHRoZSBzdGF0aWMgY2FudmFzIGVsZW1lbnRzXG52YXIgYmFja2dyb3VuZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RhdGljXCIpO1xudmFyIGJhY2tncm91bmRDb250ZXh0ID0gYmFja2dyb3VuZC5nZXRDb250ZXh0KFwiMmRcIik7XG5cbi8vIFNldHRpbmdzIGZvciB0aGUgYmFja2dyb3VuZCAtIG1vdmUgb3V0IHRvIGEgc2VwYXJhdGUgZmlsZVxudmFyIHNldHRpbmdzID0ge1xuICAgIGJhY2tncm91bmRDb2xvcjogXCIjOENEMUU2XCIsXG4gICAgcGF0aENvbG9yOiBcImdyYXlcIlxufVxuXG4vLyBEcmF3aW5nIHRoZSBiYWNrZ3JvdW5kXG5iYWNrZ3JvdW5kQ29udGV4dC5maWxsU3R5bGUgPSBzZXR0aW5ncy5iYWNrZ3JvdW5kQ29sb3I7XG5iYWNrZ3JvdW5kQ29udGV4dC5maWxsUmVjdCgwLCAwLCBiYWNrZ3JvdW5kLndpZHRoLCBiYWNrZ3JvdW5kLmhlaWdodCk7XG5cbi8qIE1haW4gcGF0aCB3aWxsIGdvIGZyb20gWzAsIDUwMF0sIFs3NSwgNTAwXSwgWzc1LCAxMDBdLCBbMjI1LCAxMDBdLCBbMjI1LCA1MDBdLCBbMzc1LCA1MDBdLCBbMzc1LCAxMDBdLCBbNTI1LCAxMDBdLCBbNTI1LCA1MDBdLCBbNjc1LCA1MDBdLCBbNjc1LCAxMDBdLCBbODI1LCAxMDBdLCBbODI1LCA1MDBdLCBbOTAwLCA1MDBdICovXG5cbi8vIERyYXdpbmcgdGhlIHBhdGggLSB3aWR0aCBvZiB0aGUgcGF0aCBpcyA1MHB4XG5iYWNrZ3JvdW5kQ29udGV4dC5maWxsU3R5bGUgPSBzZXR0aW5ncy5wYXRoQ29sb3I7XG5cbmJhY2tncm91bmRDb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4vLyBGb3IgdGhlIGJvdHRvbSBwYXJ0IG9mIHRoZSBwYXRoXG5iYWNrZ3JvdW5kQ29udGV4dC5tb3ZlVG8oMCwgNTI1KTtcblxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDEwMCwgNTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygxMDAsIDEyNSk7IC8vIFRvcFxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDIwMCwgMTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygyMDAsIDUyNSk7IC8vIEJvdHRvbVxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDQwMCwgNTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg0MDAsIDEyNSk7IC8vIFRvcFxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDUwMCwgMTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg1MDAsIDUyNSk7IC8vIEJvdHRvbVxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDcwMCwgNTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg3MDAsIDEyNSk7IC8vIFRvcFxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDgwMCwgMTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg4MDAsIDUyNSk7IC8vIEJvdHRvbVxuXG4vL01pZGRsZSBzZWN0aW9uIHRvIHRoZSBzaWRlXG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oOTAwLCA1MjUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDkwMCwgNDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg4NTAsIDQ3NSk7XG5cbi8vIEZvciB0aGUgdG9wIHBhcnQgb2YgdGhlIHBhdGhcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg4NTAsIDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg2NTAsIDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg2NTAsIDQ3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNTUwLCA0NzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDU1MCwgNzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDM1MCwgNzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDM1MCwgNDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygyNTAsIDQ3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oMjUwLCA3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNTAsIDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg1MCwgNDc1KTtcblxuLy8gRW5kIHNlY3Rpb25cbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygwLCA0NzUpO1xuXG5iYWNrZ3JvdW5kQ29udGV4dC5maWxsKCk7XG4vLyBiYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oKTtcblxuLy8gZHJhdyBhIGdyaWQgKGZvciBkZXZlbG9wbWVudCBwdXJwb3NlcylcbnZhciB3aWR0aCA9IDkwMCwgaGVpZ2h0ID0gNjAwO1xuLy8gZHJhdyB2ZXJ0aWNhbCBsaW5lc1xuZm9yICh2YXIgaSA9IDA7IGkgPCB3aWR0aDsgaSArPSAyNSkge1xuICAgIGJhY2tncm91bmRDb250ZXh0Lm1vdmVUbyhpLCAwKTtcbiAgICBiYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oaSwgaGVpZ2h0KTtcbiAgICBiYWNrZ3JvdW5kQ29udGV4dC5zdHJva2UoKTtcbn1cbi8vIGRyYXcgaG9yaXpvbnRhbCBsaW5lc1xuZm9yICh2YXIgaSA9IDA7IGkgPCBoZWlnaHQ7IGkgKz0gMjUpIHtcbiAgICBiYWNrZ3JvdW5kQ29udGV4dC5tb3ZlVG8oMCwgaSk7XG4gICAgYmFja2dyb3VuZENvbnRleHQubGluZVRvKHdpZHRoLCBpKTtcbiAgICBiYWNrZ3JvdW5kQ29udGV4dC5zdHJva2UoKTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvYmFja2dyb3VuZC5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIEluaXRpYXRlIGFsbCB0aGUgY29tcG9uZW50c1xudmFyIFRvd2VyID0gcmVxdWlyZShcIi4vY2xhc3Nlcy9Ub3dlci5qc1wiKSxcbiAgICBHYW1lRW5naW5lID0gcmVxdWlyZShcIi4vY2xhc3Nlcy9HYW1lLmpzXCIpO1xuXG4vLyBJbXBvcnQgYW5kIGRlY2xhcmUgdXRpbGl0eSBmdW5jdGlvbnNcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuXG4vLyBDYWNoZSByZXVzZWQgRE9NIGVsZW1lbnRzXG52YXIgaW5mb05hbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImluZm8tbmFtZVwiKSxcbiAgICBpbmZvSWNvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5mby1pY29uXCIpLFxuICAgIGluZm9Cb3gxID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbmZvLWJveC0xXCIpLFxuICAgIGluZm9Cb3gyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbmZvLWJveC0yXCIpLFxuICAgIGluZm9Cb3gzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbmZvLWJveC0zXCIpLFxuICAgIGluZm9Cb3g0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbmZvLWJveC00XCIpLFxuICAgIGxldmVsSW5mbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibGV2ZWxcIiksXG4gICAgZ29sZEluZm8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImdvbGRcIiksXG4gICAgbGl2ZXNJbmZvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsaXZlc1wiKTtcblxudmFyIHRvd2VyQ2FyZHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwidG93ZXItY2FyZFwiKSxcbiAgICB0b3dlckNhcmRMaXN0ID0gW107XG4vLyBDb252ZXJ0IGZyb20gbm9kZWxpc3QgdG8gYXJyYXlcbnRvd2VyQ2FyZHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0b3dlckNhcmRzKTtcblxuLypcbkNyZWF0ZSBzdGF0ZSB2YXJpYWJsZXMgLSBUaGVzZSBhcmUgbW9kaWZpZWQgb24gdXNlciBpbnRlcmFjdGlvbiBldmVudHNcblN0YXRlIHZhcmlhYmxlc1xuYWN0aXZlQ2FudmFzRWxlbWVudCAtIENoYW5nZWQgb24gYSBtb3VzZSBjbGljayBldmVudCBvbiBhIG1vbnN0ZXIsIHRvd2VyIG9yIG5vdGhpbmdcbmFjdGl2ZVRvd2VyU2VsZWN0ZWQgLSBUaGUgbmFtZSBvZiB0aGUgdG93ZXIgdGhhdCBpcyBiZWluZyBwbGFjZWQgYnkgdGhlIHVzZXJcbmFjdGl2ZU1lc3NhZ2UgLSBNZXNzYWdlIGRpc3BsYXllZCBpbiB0aGUgY2FudmFzIChjYW4gYmUgdXNlZCBmb3IgbmV3IGxldmVscywgaW52YWxpZCB0b3dlciBwbGFjZW1lbnRzLCBldGMpXG5jYW52YXNNb3VzZVBvc2l0aW9uIC1cbiAgICBvbkNhbnZhcyAtIGJvb2xlYW4gdG8gcmVwcmVzZW50IHdoZXRoZXIgdGhlIG1vdXNlIGlzIGN1cnJlbnRseSBvbiB0aGUgY2FudmFzXG4gICAgdG93ZXJQb3NpdGlvbiAtIG9iamVjdCB3aXRoIGEgZ3JpZCB2YWx1ZSBhbmQgY29vcmRpbmF0ZSB2YWx1ZSBhbmQgc2lkZXNcbiAgICAgICAgZ3JpZCAtIHRoZSB0b3AgbGVmdCBibG9jayBvZiB0aGUgdG93ZXIgYmVpbmcgcGxhY2VkIC0gdG93ZXJzIGFyZSBhIDJ4MiBncmlkXG4gICAgICAgIGNvb3JkaW5hdGUgLSB0aGUgdG9wIGxlZnQgY29ybmVyIGNvb3JkaW5hdGVcbiAgICAgICAgc2lkZXMgLSA1MCBweFxuICAgIG1vdXNlUG9zaXRpb24gLSB0aGUgY3VycmVudCBtb3VzZSBjb29yZGluYXRlc1xuKi9cblxudmFyIGFjdGl2ZUNhbnZhc0VsZW1lbnQgPSB7dHlwZTogbnVsbH0sXG4gICAgYWN0aXZlVG93ZXJTZWxlY3RlZCA9IG51bGwsXG4gICAgYWN0aXZlTWVzc2FnZSA9IHttZXNzYWdlOiBudWxsfSxcbiAgICBjYW52YXNNb3VzZVBvc2l0aW9uID0ge1xuICAgICAgICBvbkNhbnZhczogZmFsc2UsXG4gICAgICAgIHRvd2VyUG9zaXRpb246IHt9LFxuICAgICAgICBtb3VzZVBvc2l0aW9uOiB7fVxuICAgIH07XG5cbi8vICBjcmVhdGVzIGdsb2JhbCB2YXJpYWJsZXNcbmdhbWUgPSBuZXcgR2FtZUVuZ2luZTtcbmR5bmFtaWNDYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZHluYW1pYycpO1xuZHluYW1pY0NvbnRleHQgPSBkeW5hbWljQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbnJ1bkN5Y2xlID0gZnVuY3Rpb24oKSB7XG4gICAgZ2FtZS5ydW5DeWNsZSgpO1xuICAgIHVwZGF0ZUdhbWVJbmZvcm1hdGlvbigpO1xuICAgIC8vIEkgYXNzdW1lIHRoZSBnYW1lIGlzIGdvaW5nIHRvIHJ1biBmYXN0IHRoYW4gdGhpcyBhZnRlcj8gaWYgbm90IG5lZWQgdG8gYWRkIHVwZGF0ZUdhbWVJbmZvcm1hdGlvbiB0byBhIGZldyBvdGhlciBwbGFjZXNcbiAgICBzZXRUaW1lb3V0KHJ1bkN5Y2xlLCAxMDAwKTtcbn1cblxucmVuZGVyQ3ljbGUgPSBmdW5jdGlvbigpIHtcbiAgICBnYW1lLnJlbmRlcigpO1xuICAgIC8vIFJlbmRlcnMgdGhlIGluZm9ybWF0aW9uIGFuZCBlcnJvciBtZXNzYWdlcyBiYXNlZCBvbiB0aGUgc3RhdGUgdmFyaWFibGVzXG4gICAgcmVuZGVyVG93ZXJQbGFjZW1lbnQoKTtcbiAgICByZW5kZXJNZXNzYWdlKCk7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlckN5Y2xlKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09IFJlbmRlciBmdW5jdGlvbnMgPT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLy8gUmVuZGVyIGZ1bmN0aW9ucyBydW4gZXZlcnkgZ2FtZSBjeWNsZSAob24gdGhlIHJlbmRlckN5Y2xlIGZ1bmN0aW9uIGNhbGwpXG4vLyBSZW5kZXJzIGJhc2VkIG9uIHRoZSBzdGF0ZSB2YXJpYWJsZXNcblxuZnVuY3Rpb24gdXBkYXRlR2FtZUluZm9ybWF0aW9uKCkge1xuICAgIGxpdmVzSW5mby5pbm5lckhUTUwgPSBnYW1lLnVzZXJMaXZlcztcbiAgICBnb2xkSW5mby5pbm5lckhUTUwgPSBnYW1lLnVzZXJHb2xkO1xuICAgIGxldmVsSW5mby5pbm5lckhUTUwgPSBnYW1lLmxldmVsO1xuXG4gICAgaWYgKGFjdGl2ZUNhbnZhc0VsZW1lbnQudHlwZSA9PT0gXCJtb25zdGVyXCIpIHtcbiAgICAgICAgcmVuZGVyTW9uc3RlckluZm9ybWF0aW9uKGFjdGl2ZUNhbnZhc0VsZW1lbnQuaWQsIGFjdGl2ZUNhbnZhc0VsZW1lbnQuaW5kZXgpO1xuICAgIH0gZWxzZSBpZiAoYWN0aXZlQ2FudmFzRWxlbWVudC50eXBlID09PSBcInRvd2VyXCIpIHtcbiAgICAgICAgcmVuZGVyVG93ZXJJbmZvcm1hdGlvbihhY3RpdmVDYW52YXNFbGVtZW50LmlkLCBhY3RpdmVDYW52YXNFbGVtZW50LmluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZW5kZXJEZWZhdWx0SW5mb3JtYXRpb24oKTtcbiAgICB9XG59XG5cbi8vIElEIHJlZmVycyB0byB0aGUgdHlwZSBvZiBtb25zdGVyIGFuZCBpbmRleCBpcyB0aGUgaW5kZXggb2YgdGhlIGFjdGl2ZSBtb25zdGVyIGluIHRoZSBhY3RpdmUgbW9uc3RlcidzIGFycmF5XG5mdW5jdGlvbiByZW5kZXJNb25zdGVySW5mb3JtYXRpb24oaWQsIGluZGV4KSB7XG4gICAgdmFyIGN1cnJlbnRIcCA9IGdhbWUuYWN0aXZlTW9uc3RlcnNbaW5kZXhdLmN1cnJlbnRIcCxcbiAgICAgICAgbWF4SHAgPSBnYW1lLmFjdGl2ZU1vbnN0ZXJzW2luZGV4XS5tYXhIcCxcbiAgICAgICAgdHlwZSA9IGdhbWUuYWN0aXZlTW9uc3RlcnNbaW5kZXhdLnR5cGU7XG4gICAgaW5mb05hbWUuaW5uZXJIVE1MID0gaWQ7XG4gICAgLy8gQ2hhbmdlIGljb24gdG8gYWN0aXZlIG1vbnN0ZXIgLSB1c2UgYSBzcHJpdGVcbiAgICBpbmZvQm94MS5pbm5lckhUTUwgPSBcIkhQOiBcIiArIGN1cnJlbnRIcCArIFwiIC8gXCIgKyBtYXhIcDtcbiAgICBpbmZvQm94Mi5pbm5lckhUTUwgPSBcIlR5cGU6IFwiICsgdHlwZTtcbiAgICBpbmZvQm94My5pbm5lckhUTUwgPSBcIlN0cmVuZ3RoczogQWxsIHNvcnRzIG1hdGVcIiA7XG4gICAgaW5mb0JveDQuaW5uZXJIVE1MID0gXCJXZWFrbmVzc2VzOiBEdWNrc1wiIDtcbn1cblxuLy8gSUQgcmVmZXJzIHRvIHRoZSB0eXBlIG9mIHRvd2VyIGFuZCBpbmRleCBpcyB0aGUgaW5kZXggb2YgdGhlIGFjdGl2ZSB0b3dlciBpbiB0aGUgYWN0aXZlIHRvd2VyJ3MgYXJyYXlcbmZ1bmN0aW9uIHJlbmRlclRvd2VySW5mb3JtYXRpb24oaWQsIGluZGV4KSB7XG4gICAgaW5mb05hbWUuaW5uZXJIVE1MID0gaWQ7XG4gICAgLy8gQ2hhbmdlIGljb24gdG8gYWN0aXZlIG1vbnN0ZXIgLSB1c2UgYSBzcHJpdGVcbiAgICBpbmZvQm94MS5pbm5lckhUTUwgPSBcIkRhbWFnZTogPGJyPiBSYW5nZTogPGJyPiBFZmZlY3Q6IFwiO1xuICAgIGluZm9Cb3gyLmlubmVySFRNTCA9IFwiQXR0YWNrIFNwZWVkOiA8YnI+IFR5cGU6IFwiIDtcbiAgICBpbmZvQm94My5pbm5lckhUTUwgPSBcIjxhIGNsYXNzPSd3YXZlcy1lZmZlY3Qgd2F2ZXMtbGlnaHQgYnRuIHJlZCc+VXBncmFkZTwvYT5cIiA7XG4gICAgaW5mb0JveDQuaW5uZXJIVE1MID0gXCI8YSBjbGFzcz0nd2F2ZXMtZWZmZWN0IHdhdmVzLWxpZ2h0IGJ0biByZWQnPlNlbGw8L2E+XCIgO1xuICAgIC8vIENoYW5nZSBpY29uIHRvIHRvd2VyIG1vbnN0ZXIgLSB1c2UgYSBzcHJpdGVcblxufVxuXG5mdW5jdGlvbiByZW5kZXJEZWZhdWx0SW5mb3JtYXRpb24oKSB7XG4gICAgaW5mb05hbWUuaW5uZXJIVE1MID0gXCJBd2Vzb21lIFREXCI7XG4gICAgLy8gQ2hhbmdlIGljb24gdG8gZGVmYXVsdCBpbWFnZSAtIHVzZSBhIHNwcml0ZVxuICAgIGluZm9Cb3gxLmlubmVySFRNTCA9IFwiVGhpcyBpcyBzb21lIHRleHRcIjtcbiAgICBpbmZvQm94Mi5pbm5lckhUTUwgPSBcIlRoaXMgaXMgZGlmZmVyZW50IHRleHRcIjtcbiAgICBpbmZvQm94My5pbm5lckhUTUwgPSBcIlRoaXMgaXMgPz8/IHRleHRcIiA7XG4gICAgaW5mb0JveDQuaW5uZXJIVE1MID0gXCJUaGlzIDEyMzEyNDEyMzVcIiA7XG59XG5cbi8vIE1heWJlIGNoYW5nZSB0aGlzIHRvIFwicmVuZGVyTWVzc2FnZVwiXG5mdW5jdGlvbiByZW5kZXJNZXNzYWdlKCkge1xuICAgIGlmIChhY3RpdmVNZXNzYWdlLm1lc3NhZ2UgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGR5bmFtaWNDb250ZXh0Lmdsb2JhbEFscGhhID0gYWN0aXZlTWVzc2FnZS50aW1lciAvIDUwO1xuICAgICAgICBkeW5hbWljQ29udGV4dC5mb250ID0gJzQwcHQgRHJvaWQgU2Fucyc7XG4gICAgICAgIGR5bmFtaWNDb250ZXh0LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIGR5bmFtaWNDb250ZXh0LmZpbGxTdHlsZSA9IFwicmVkXCI7XG4gICAgICAgIGR5bmFtaWNDb250ZXh0LmZpbGxUZXh0KGFjdGl2ZU1lc3NhZ2UubWVzc2FnZSwgNDUwLCA1MCk7XG4gICAgICAgIGR5bmFtaWNDb250ZXh0Lmdsb2JhbEFscGhhID0gMTtcblxuICAgICAgICBpZiAoYWN0aXZlTWVzc2FnZS50aW1lciA9PT0gMCkge1xuICAgICAgICAgICAgYWN0aXZlTWVzc2FnZSA9IHttZXNzYWdlOiBudWxsfTsgLy8gUmVzZXQgZXJyb3IgbWVzc2FnZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWN0aXZlTWVzc2FnZS50aW1lci0tO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJUb3dlclBsYWNlbWVudCgpIHtcbiAgICBpZiAoYWN0aXZlVG93ZXJTZWxlY3RlZCA9PT0gbnVsbCB8fFxuICAgICAgICAhY2FudmFzTW91c2VQb3NpdGlvbi5vbkNhbnZhcykge1xuICAgICAgICByZXR1cm5cbiAgICB9O1xuXG4gICAgdmFyIGNvb3JkaW5hdGVzID0gY2FudmFzTW91c2VQb3NpdGlvbi50b3dlclBvc2l0aW9uLmNvb3JkaW5hdGVzO1xuICAgIGR5bmFtaWNDb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGR5bmFtaWNDb250ZXh0Lmdsb2JhbEFscGhhID0gMC41O1xuXG4gICAgaWYgKHRydWUpIHsgLy8gY2hlY2sgZm9yIHZhbGlkIHRvd2VyIHBsYWNlbWVudFxuICAgICAgICBkeW5hbWljQ29udGV4dC5maWxsU3R5bGUgPSBcImdyZWVuXCI7XG4gICAgICAgIGR5bmFtaWNDb250ZXh0LmZpbGxSZWN0KGNvb3JkaW5hdGVzLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDUwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA1MFxuICAgICAgICAgKTtcblxuICAgICAgICBkeW5hbWljQ29udGV4dC5nbG9iYWxBbHBoYSA9IDAuNztcbiAgICAgICAgZHluYW1pY0NvbnRleHQuYXJjKGNvb3JkaW5hdGVzLnggKyAyNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzLnkgKyAyNSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDMwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDIgKiBNYXRoLlBJLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICk7XG4gICAgICAgIGR5bmFtaWNDb250ZXh0LmZpbGxTdHlsZSA9ICdncmF5JztcbiAgICAgICAgZHluYW1pY0NvbnRleHQuZmlsbCgpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZG8gc29tZSBzb3J0IG9mIGxvZ2ljIHRvIGhpZ2hsaWdodCB0aGUgdGlsZXMgdGhhdCB0aGUgdG93ZXIgd291bGQgYmUgcGxhY2VkIG9uIGFuZCBzaG93IHRoZSB0b3dlciBvbiB0aG9zZSBwb3NpdGlvbnNcbiAgICAgICAgLy8gdGhpcyB3b3VsZCBydW4gd2hlbiB0b3dlciBwbGFjZW1lbnQgaXMgaW52YWxpZFxuICAgIH1cbiAgICBkeW5hbWljQ29udGV4dC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgZHluYW1pY0NvbnRleHQuY2xvc2VQYXRoKCk7XG59XG5cbi8qID09PT09PT09PT09PT09PT0gVUkgRXZlbnQgTGlzdGVuZXJzID09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RhcnQtYnRuXCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAvLyBIaWRlcyB0aGUgbW9kYWwgbGlnaHRib3hcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwibW9kYWwtY29udGVudFwiKVswXS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIm1vZGFsLWJhY2tncm91bmRcIilbMF0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXG4gICAgLy8gcnVuIHJlcGVhdGluZyBmdW5jdGlvbiB0aGF0IHJ1bnMgZ2FtZSBlbmdpbmUgcnVuIGN5Y2xlIGFuZCByZW5kZXJpbmdcbiAgICBzZXRUaW1lb3V0KHJ1bkN5Y2xlLCAxMDAwKTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyQ3ljbGUpO1xufSk7XG5cbi8vIE9uIGNsaWNraW5nIHRoZSBpbmZvcm1hdGlvbiBidXR0b24sIHNob3cgdGhlIGluZm9ybWF0aW9uIHBhbmVsXG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImluZm9ybWF0aW9uLWJ0blwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgLy8gVE9ETyAtIGFkZCBpbmZvcm1hdGlvbiBtb2RhbCBpbmZvcm1hdGlvbiB0aGluZ3lcbiAgICBjb25zb2xlLmxvZyhcInNob3cgaW5mb3JtYXRpb24gY29udGFpbmVyIGhlcmVcIik7XG59KTtcblxuLypcblRoZXNlIGV2ZW50IGxpc3RlbmVycyBjb250cm9sIHRoZSBhcHBsaWNhdGlvbiBieSBpbnRlcmFjdGluZyB3aXRoIHRoZSBnYW1lXG5vYmplY3QgYW5kIGJ5IGNoYW5naW5nIHRoZSBzdGF0ZSB2YXJpYWJsZXMgKHdoaWNoIHRoZSByZW5kZXIgZnVuY3Rpb25zIHVzZVxudG8gcmVhZClcbiovXG50b3dlckNhcmRzLm1hcChmdW5jdGlvbih0b3dlckNhcmQsIGkpIHtcbiAgICB0b3dlckNhcmRMaXN0LnB1c2godG93ZXJDYXJkLmdldEF0dHJpYnV0ZShcImRhdGEtdG93ZXJcIikpO1xuICAgIHRvd2VyQ2FyZC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdG93ZXJDYXJkQ2xpY2spO1xufSk7XG5cbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZHluYW1pY1wiKS5vbm1vdXNlbW92ZSA9IG9uQ2FudmFzTW91c2VNb3ZlbWVudDtcbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZHluYW1pY1wiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgY2FudmFzQ2xpY2spO1xuXG5kb2N1bWVudC5vbmtleWRvd24gPSBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgICAgY2FuY2VsVG93ZXJQbGFjZW1lbnQoKTtcbiAgICB9XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT0gVUkgRnVuY3Rpb25zID09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qIENsaWNrIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSB0b3dlciBjYXJkc1xuVXNlZCB0byBjb250cm9sIHdoYXQgdG93ZXIgaXMgYmVpbmcgYWN0aXZlbHkgcGxhY2VkIG9uIHRoZSBjYW52YXNcbjQgcG9zc2libGUgZmxvd3MgYmFzZWQgb24gdGhlIHN0YXRlIG9mIHRoZSBpbnRlcmZhY2VcbjEpIFRoZSB0b3dlciB0aGF0IHdhcyBjbGlja2VkIGlzIGN1cnJlbnRseSBkaXNhYmxlZDpcbiAgICAtPiBmdW5jdGlvbiByZXR1cm5zXG4yKSBObyB0b3dlcnMgYXJlIGFjdGl2ZWx5IGJlaW5nIHBsYWNlZFxuICAgIC0+IHRoZSBjbGlja2VkIHRvd2VyIGNhcmQgbm93IGJlY29tZXMgdGhlIGFjdGl2ZSB0b3dlciBiZWluZyBwbGFjZWRcbjMpIFRoZSBjbGlja2VkIHRvd2VyIGlzIHRoZSBzYW1lIGFzIHRoZSB0b3dlciBhY3RpdmVseSBiZWluZyBwbGFjZWRcbiAgICAtPiB0aGUgc3RhdGUgaXMgcmVzZXQgc28gdGhhdCBubyB0b3dlcnMgYXJlIGFjdGl2ZWx5IGJlaW5nIHBsYWNlZFxuNCkgVGhlIGNsaWNrZWQgdG93ZXIgaXMgZGlmZmVyZW50IGZyb20gdGhlIHRvd2VyIGFjdGl2ZWx5IGJlaW5nIHBsYWNlZFxuICAgIC0+IHRoZSBzdGF0ZSBpcyBjaGFuZ2VkIHRvIHRoZSBjbGlja2VkIHRvd2VyIGJlY29taW5nIHRoZSBhY3RpdmUgdG93ZXJcbiovXG5mdW5jdGlvbiB0b3dlckNhcmRDbGljaygpIHtcblxuICAgIHZhciB0b3dlck5hbWUgPSB0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtdG93ZXJcIiksXG4gICAgICAgIG9sZFRvd2VySW5kZXggPSB1dGlscy5nZXRUb3dlckNhcmRJbmRleCh0b3dlckNhcmRMaXN0LCBhY3RpdmVUb3dlclNlbGVjdGVkKSxcbiAgICAgICAgbmV3VG93ZXJJbmRleCA9IHV0aWxzLmdldFRvd2VyQ2FyZEluZGV4KHRvd2VyQ2FyZExpc3QsIHRvd2VyTmFtZSk7XG5cbiAgICBpZiAoL2Rpc2FibGVkL2kudGVzdCh0aGlzLmNsYXNzTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgfSBlbHNlIGlmIChhY3RpdmVUb3dlclNlbGVjdGVkID09PSBudWxsKSB7XG4gICAgICAgIGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPSB0b3dlck5hbWU7XG4gICAgICAgIHV0aWxzLmFkZENsYXNzKHRvd2VyQ2FyZHNbbmV3VG93ZXJJbmRleF0sIFwiYWN0aXZlXCIpO1xuICAgICAgICBjYW52YXNNb3VzZVBvc2l0aW9uLm9uQ2FudmFzID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChhY3RpdmVUb3dlclNlbGVjdGVkID09PSB0b3dlck5hbWUpIHtcbiAgICAgICAgY2FuY2VsVG93ZXJQbGFjZW1lbnQoKTtcbiAgICAgICAgY2FudmFzTW91c2VQb3NpdGlvbi5vbkNhbnZhcyA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWxzLnJlbW92ZUNsYXNzKHRvd2VyQ2FyZHNbb2xkVG93ZXJJbmRleF0sIFwiYWN0aXZlXCIpO1xuICAgICAgICBhY3RpdmVUb3dlclNlbGVjdGVkID0gdG93ZXJOYW1lO1xuICAgICAgICB1dGlscy5hZGRDbGFzcyh0b3dlckNhcmRzW25ld1Rvd2VySW5kZXhdLCBcImFjdGl2ZVwiKTtcbiAgICAgICAgY2FudmFzTW91c2VQb3NpdGlvbi5vbkNhbnZhcyA9IGZhbHNlO1xuXG4gICAgfVxufVxuXG4vKlxuQ2FsbGVkIGZyb20gdG93ZXJDYXJkQ2xpY2sgKHdoZW4gY2xpY2tpbmcgdGhlIGFjdGl2ZSB0b3dlciBjYXJkKSBhbmQgb24gYW4gZXNjYXBlIGtleSBwcmVzc1xuUmVzZXRzIHRoZSBhY3RpdmUgdG93ZXIgcGxhY2VtZW50IHN0YXRlIHRvIG51bGxcbiovXG5mdW5jdGlvbiBjYW5jZWxUb3dlclBsYWNlbWVudCgpIHtcbiAgICB1dGlscy5yZW1vdmVDbGFzcyh0b3dlckNhcmRzW3V0aWxzLmdldFRvd2VyQ2FyZEluZGV4KHRvd2VyQ2FyZExpc3QsIGFjdGl2ZVRvd2VyU2VsZWN0ZWQpXSwgXCJhY3RpdmVcIik7XG4gICAgYWN0aXZlVG93ZXJTZWxlY3RlZCA9IG51bGw7XG59XG5cbi8qIE1vdXNlIG1vdmUgZXZlbnQgbGlzdGVuZXIgb24gdGhlIGNhbnZhc1xuSWYgdGhlIGFjdGl2ZSB0b3dlciBzZWxlY3RlZCBzdGF0ZSAoYSB0b3dlciBpcyBiZWluZyBwbGFjZWQgYnkgdGhlIHVzZXIpOlxuICAgIC0+IHVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIG1vdXNlIG9uIHRoZSBjYW52YXMgKHVzZWQgYnkgdGhlIHJlbmRlclRvd2VyUGxhY2VtZW50IGZ1bmN0aW9uKVxub3RoZXJ3aXNlOlxuICAgIC0+IGRvIG5vdGhpbmdcbiovXG5mdW5jdGlvbiBvbkNhbnZhc01vdXNlTW92ZW1lbnQoZSkge1xuICAgIGlmIChhY3RpdmVUb3dlclNlbGVjdGVkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVyblxuICAgIH07XG5cbiAgICB2YXIgY2FudmFzQ29udGFpbmVyID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgcG9zaXRpb24gPSB7fTtcblxuICAgIHBvc2l0aW9uLnggPSBlLmNsaWVudFggLSBjYW52YXNDb250YWluZXIubGVmdDtcbiAgICBwb3NpdGlvbi55ID0gZS5jbGllbnRZIC0gY2FudmFzQ29udGFpbmVyLnRvcDtcbiAgICBjYW52YXNNb3VzZVBvc2l0aW9uLm1vdXNlUG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICBjYW52YXNNb3VzZVBvc2l0aW9uLnRvd2VyUG9zaXRpb24gPSB1dGlscy5jb252ZXJ0UG9zaXRpb25Ub1Rvd2VyKHBvc2l0aW9uKTtcbiAgICBjYW52YXNNb3VzZVBvc2l0aW9uLm9uQ2FudmFzID0gdHJ1ZTtcbn07XG5cblxuLyogQ2xpY2sgZXZlbnQgbGlzdGVuZXIgb24gdGhlIGNhbnZhc1xuSGFuZGxlcyB0d28gcG9zc2libGUgY2FudmFzIGNsaWNrIHNjZW5hcmlvc1xuMSkgQSB0b3dlciBpcyBzZWxlY3RlZCBhbmQgaXMgYWN0aXZlbHkgYmVpbmcgcGxhY2VkXG4gICAgLT4gQ2xpY2tpbmcgd2lsbCB2YWxpZGF0ZSB0aGUgdG93ZXIgcGxhY2VtZW50IGFuZCBjaGVjayB0aGUgdXNlcidzIGdvbGRcbiAgICBpZiBib3RoIGFyZSB2YWxpZCwgd2lsbCB0b3dlciB3aWxsIGJlIHBsYWNlZCAoYnkgZ2FtZSBvYmplY3QpXG4gICAgb3RoZXJ3aXNlLCBhbiBlcnJvciBtZXNzYWdlIHdpbGwgc2hvdyB1cFxuMikgQSB0b3dlciBpcyBub3Qgc2VsZWN0ZWQgYW5kIGlzIG5vdCBiZWluZyBwbGFjZWRcbiAgICAtPiBXaWxsIGNoZWNrIHdoZXRoZXIgdGhlIGNsaWNrIHBvc2l0aW9uIG92ZXJsYXBzIHdpdGggdGhlIGJvdW5kaW5nXG4gICAgcmVjdGFuZ2xlIG9mIG1vbnN0ZXIgb3IgdG93ZXIgLSBpZiBzbywgaXQgd2lsbCByZXR1cm4gdGhlIGluZm9ybWF0aW9uXG4gICAgaW4gdGhlIGluZm9ybWF0aW9uIGNvbnRhaW5lclxuKi9cbmZ1bmN0aW9uIGNhbnZhc0NsaWNrKGUpIHtcbiAgICAvLyBHZXQgY2xpY2sgbG9jYXRpb24gcmVsYXRpdmUgdG8gdGhlIGNhbnZhcyBlbGVtZW50XG4gICAgdmFyIGNhbnZhc0NvbnRhaW5lciA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIHBvc2l0aW9uID0ge30sXG4gICAgICAgIHRvd2VyR3JpZFBvc2l0aW9uID0gY2FudmFzTW91c2VQb3NpdGlvbi50b3dlclBvc2l0aW9uLmdyaWQsXG4gICAgICAgIHRvd2VyQ29vcmRpbmF0ZXMgPSBjYW52YXNNb3VzZVBvc2l0aW9uLnRvd2VyUG9zaXRpb24uY29vcmRpbmF0ZXM7IC8vIFBhc3NlcyBpbiBncmlkIGJsb2NrcyAtIHRoaXMgaXMgdGhlIHRvcExlZnQgYmxvY2tcblxuICAgIHBvc2l0aW9uLnggPSBlLmNsaWVudFggLSBjYW52YXNDb250YWluZXIubGVmdDtcbiAgICBwb3NpdGlvbi55ID0gZS5jbGllbnRZIC0gY2FudmFzQ29udGFpbmVyLnRvcDtcblxuICAgIC8vIFJ1bnMgaWYgdGhlIHVzZXIgaXMgcGxhY2luZyBhIHRvd2VyXG4gICAgaWYgKGFjdGl2ZVRvd2VyU2VsZWN0ZWQgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHRvd2VyTmFtZSA9IGFjdGl2ZVRvd2VyU2VsZWN0ZWQsXG4gICAgICAgICAgICB0b3dlclBsYWNlZCA9IGdhbWUucGxhY2VUb3dlcih0b3dlck5hbWUsIHRvd2VyR3JpZFBvc2l0aW9uLCB0b3dlckNvb3JkaW5hdGVzKTtcblxuICAgICAgICAvLyBJZiB0aGUgdG93ZXIgd2FzIG5vdCBwbGFjZWQsIHNob3cgYW4gZXJyb3IgbWVzc2FnZVxuICAgICAgICBpZiAoIXRvd2VyUGxhY2VkLnBsYWNlZCkge1xuICAgICAgICAgICAgYWN0aXZlTWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB0b3dlclBsYWNlZC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIHRpbWVyOiA1MCAvLyBmcmFtZXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHV0aWxzLnJlbW92ZUNsYXNzKHRvd2VyQ2FyZHNbdXRpbHMuZ2V0VG93ZXJDYXJkSW5kZXgodG93ZXJDYXJkTGlzdCwgYWN0aXZlVG93ZXJTZWxlY3RlZCldLCBcImFjdGl2ZVwiKTtcbiAgICAgICAgYWN0aXZlVG93ZXJTZWxlY3RlZCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXNlciBpcyBub3QgcnVubmluZyBhIHRvd2VyIHBsYWNlbWVudFxuICAgICAgICBhY3RpdmVDYW52YXNFbGVtZW50ID0gZ2FtZS5jaGVja0NsaWNrTG9jYXRpb24ocG9zaXRpb24pO1xuICAgICAgICB1cGRhdGVHYW1lSW5mb3JtYXRpb24oKTtcbiAgICB9XG5cbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvaW50ZXJmYWNlLmpzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvd2VyRGF0YSA9IHJlcXVpcmUoXCIuLi9nYW1lRGF0YS90b3dlcmRhdGEuanNcIiksXG4gICAgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMuanNcIik7XG5cbi8vIFBvc2l0aW9uIHJlZmVycyB0byB0aGUgdXBwZXIgbGVmdCBjb3JuZXIgb2YgdGhlIGVsZW1lbnRzXG4vLyBUb3dlciB3aWR0aCAtIDUwIHggNTBcbnZhciBUb3dlciA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBpZCkge1xuICAgIGlmICh0b3dlckRhdGFbaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIHRvd2VyIG5hbWUsIGNoZWNrIGh0bWwgZGF0YWF0dHJpYnV0ZSBvciB0b3dlcmRhdGFcIilcbiAgICB9XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuZGFtYWdlID0gdG93ZXJEYXRhW2lkXS5kYW1hZ2U7XG4gICAgdGhpcy5zcGVlZCA9IHRvd2VyRGF0YVtpZF0uc3BlZWQ7IC8vIEF0dGFjayBzcGVlZFxuICAgIHRoaXMucmFuZ2UgPSB0b3dlckRhdGFbaWRdLnJhbmdlOyAvLyBSYW5nZSBvZiB0aGUgdG93ZXJcbiAgICB0aGlzLnR5cGUgPSB0b3dlckRhdGFbaWRdLnR5cGU7IC8vIFR5cGUgb2YgZGFtYWdlXG4gICAgdGhpcy5lZmZlY3QgPSB0b3dlckRhdGFbaWRdLmVmZmVjdDsgLy8gU3BlY2lhbCBlZmZlY3QgKGUuZy4gc2xvdywgc3BsYXNoLCBldGMpXG4gICAgdGhpcy5nb2xkQ29zdCA9IHRvd2VyRGF0YVtpZF0uZ29sZENvc3Q7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uOyAvLyBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvb3JkaW5hdGVzIC0gcmVmZXJlbmNlcyB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB0b3dlclxuICAgIHRoaXMucG9zaXRpb24uc2lkZUxlbmd0aCA9IDUwO1xufVxuLy8gTWV0aG9kIHRoZSBnYW1lIG9iamVjdCB1c2VzIHRvIHJ1biB0b3dlcnNcblRvd2VyLnByb3RvdHlwZS5ydW5DeWNsZSA9IGZ1bmN0aW9uKCkge1xuXG59XG4vLyBjaGFuZ2UgdGhpcyB0byByZWZlcmVuY2UgYSBsaXN0IG9yIHNvbWV0aGluZyB3aGVyZSBhIG5hbWUgY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBwcm9wZXJ0aWVzXG4vLyBUYWtlcyBpbiBhIG1vbnN0ZXIncyBwb3NpdGlvbiBhbmQgY2hlY2tzIHdoZXRoZXIgdGhhdCBpcyBpbiByYW5nZSBiYXNlZCBvbiB0aGUgcmFuZ2UgLSByZXR1cm5zIHRydWUgb3IgZmFsc2UgaWYgaW4gcmFuZ2Ugd2hpY2ggY2FuIGJlIHVzZWQgdG9cblRvd2VyLnByb3RvdHlwZS5jaGVja0luUmFuZ2UgPSBmdW5jdGlvbihtb25zdGVyUG9zaXRpb24pIHtcbiAgICAvLyB1c2luZyBzcXJ0KCh4Mi14MSleMiAtICh5Mi15MSleMilcbiAgICB2YXIgbW9uc3RlckRpc3RhbmNlID0gdXRpbHMuZ2V0UG9zaXRpb25EaWZmZXJlbmNlKG1vbnN0ZXJQb3NpdGlvbiwgdGhpcy5wb3NpdGlvbik7XG5cbiAgIGlmIChtb25zdGVyRGlzdGFuY2UgPD0gdGhpcy5yYW5nZSkge1xuICAgICAgIHJldHVybiB0cnVlO1xuICAgfSBlbHNlIHtcbiAgICAgICByZXR1cm4gZmFsc2U7XG4gICB9XG59XG5cblRvd2VyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oKSB7XG4gICAgZHluYW1pY0NvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgZHluYW1pY0NvbnRleHQuZmlsbFN0eWxlID0gXCJncmVlblwiO1xuICAgIGR5bmFtaWNDb250ZXh0LmZpbGxSZWN0KHRoaXMucG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgNTApO1xuICAgIGR5bmFtaWNDb250ZXh0LmNsb3NlUGF0aCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRvd2VyO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9qcy9jbGFzc2VzL1Rvd2VyLmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYmFzaWM6IHtcbiAgICAgICAgZGFtYWdlOiAxMCxcbiAgICAgICAgc3BlZWQ6IDEwLFxuICAgICAgICByYW5nZTogMTAwLFxuICAgICAgICBnb2xkQ29zdDogMTAsXG4gICAgICAgIHR5cGU6IFwiYmFzaWNcIixcbiAgICAgICAgZWZmZWN0OiBcIm5vbmVcIlxuICAgIH1cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2pzL2dhbWVEYXRhL3Rvd2VyZGF0YS5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4vKiA9PT09PT09PT09PT09PT09PT0gUHJpdmF0ZSBmdW5jdGlvbnMgPT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vLyBUT0RPIC0gYWRkIHRlc3RzXG4gICAgLypcbiAgICBDb252ZXJ0cyBhIHBhdGhMaW5lcyBhcnJheSAoYW4gYXJyYXkgb2Ygb2JqZWN0cyB3aXRoIGEgc3RhcnRQb2ludCxcbiAgICBkaXJlY3Rpb24gYW5kIGEgZGlzdGFuY2UpIGludG8gYW4gYXJyYXkgb2YgZ3JpZCBibG9ja3MgKClcbiAgICBOb3RlIHRoYXQgdGhlcmUgd2lsbCBiZSBzb21lIG92ZXJsYXAgd2l0aCBibG9ja3MsIGhvd2V2ZXIsXG4gICAgYXMgdGhleSBhcmUgb25seSB1c2VkIHRvIHNldCBncmlkIHBvc2l0aW9ucyB0byBub3QgZW1wdHksIG92ZXJsYXAgaXMgbm90IGFuIGlzc3VlXG4gICAgKi9cbiAgICBmdW5jdGlvbiBfY3JlYXRlUGF0aEJsb2NrcyhwYXRoTGluZXMpIHtcbiAgICAgICAgdmFyIGJsb2NrcyA9IFtdO1xuICAgICAgICAvLyBMb29wcyB0aHJvdWdoIGFsbCB0aGUgcGF0aExpbmVzIGFuZCBjcmVhdGVzIGJsb2NrcyBiYXNlZCBvbiB0aGF0XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBibG9ja0Ftb3VudCByZWZlcnMgdG8gdGhlIGFtb3VudCBvZiBibG9ja3MgdGhhdCBmb2xsb3cgdGhlIHBhdGhcbiAgICAgICAgICAgIHZhciBibG9ja0Ftb3VudCA9IE1hdGguZmxvb3IocGF0aExpbmVzW2ldLmRpc3RhbmNlIC8gMjUpICsgMSxcbiAgICAgICAgICAgICAgICBwYXRoRGlyZWN0aW9uO1xuICAgICAgICAgICAgLyogU2V0IGRpcmVjdGlvblxuICAgICAgICAgICAgeDogMSA9IHJpZ2h0XG4gICAgICAgICAgICB4OiAtMSA9IGxlZnRcbiAgICAgICAgICAgIHk6IDEgPSBkb3duXG4gICAgICAgICAgICB5OiAtMSA9IHVwXG4gICAgICAgICAgICBPZmZzZXQgdmFsdWVzIGhlbHAgY2VudGVyIHRoZSBncmlkIGJsb2NrcyAoaS5lLiBpbmxpbmUgd2l0aCB0aGUgZGlyZWN0aW9uKVxuICAgICAgICAgICAgU2lkZSB2YWx1ZXMgYXJlIHVzZWQgdG8gZGVmaW5lIHdoaWNoIHNpZGUgdGhlIGJsb2NrcyBhcmUgb24gcmVsYXRpdmUgdG8gdGhlIHBhdGggZGlyZWN0aW9uIChpLmUuIGhvcml6b250YWxseSBvciB2ZXJ0aWNhbGx5KVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHN3aXRjaCAocGF0aExpbmVzW2ldLmRpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ1cFwiOlxuICAgICAgICAgICAgICAgICAgICBwYXRoRGlyZWN0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IC0xLFxuICAgICAgICAgICAgICAgICAgICAgICAgeE9mZnNldDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHlPZmZzZXQ6IC0xMi41LFxuICAgICAgICAgICAgICAgICAgICAgICAgeFNpZGU6IDEyLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICB5U2lkZTogMFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkb3duXCI6XG4gICAgICAgICAgICAgICAgICAgIHBhdGhEaXJlY3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhPZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB5T2Zmc2V0OiAxMi41LFxuICAgICAgICAgICAgICAgICAgICAgICAgeFNpZGU6IDEyLjUsXG4gICAgICAgICAgICAgICAgICAgICAgICB5U2lkZTogMFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgICAgICAgICAgIHBhdGhEaXJlY3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB4T2Zmc2V0OiAxMi41LFxuICAgICAgICAgICAgICAgICAgICAgICAgeU9mZnNldDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhTaWRlOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgeVNpZGU6IDEyLjVcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICAgICAgICAgICAgcGF0aERpcmVjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgeE9mZnNldDogMTIuNSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHlPZmZzZXQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB4U2lkZTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHlTaWRlOiAxMi41XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkaXJlY3Rpb24gcHJvdmlkZWQgaW4gcGF0aExpbmVzXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDcmVhdGVzIGJsb2NrIGVxdWFsIHRvIGRvdWJsZSB0aGUgYW1vdW50IG9mIHRoZSBibG9ja0Ftb3VudCAodGhlIGVxdWl2YWxlbnQgYW1vdW50IG9mIGJsb2NrcyB0byB0aGUgcGF0aCBkaXN0YW5jZSlcbiAgICAgICAgICAgIC8vIGJsb2NrQmVmb3JlIHJlZmVycyB0byBibG9ja3MgZWl0aGVyIHRvIHRoZSBsZWZ0IG9yIHRvcCBvZiB0aGUgcGF0aFxuICAgICAgICAgICAgLy8gYmxvY2tBZnRlciByZWZlcnMgdG8gYmxvY2tzIGVpdGhlciB0byB0aGUgcmlnaHQgb3IgYmVsb3cgb2YgdGhlIHBhdGhcbiAgICAgICAgICAgIC8vIENyZWF0ZXMgYmxvY2sgbG9jYXRpb25zIGFuZCBnaXZlcyB0aGVtIG9mZnNldHMgdG8gdGhlaXIgY2VudGVyIHBvc2l0aW9ucyAoZm9yIGNsYXJpdHkgaW4gY29udmVydGluZyB0byBibG9ja3MpXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJsb2NrQW1vdW50OyBqKyspIHtcblxuICAgICAgICAgICAgICAgIHZhciBibG9ja0JlZm9yZSA9IHtcblxuICAgICAgICAgICAgICAgICAgICB4OiBwYXRoTGluZXNbaV0uc3RhcnRQb2ludC54ICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhEaXJlY3Rpb24ueE9mZnNldCAtXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoRGlyZWN0aW9uLnhTaWRlICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChwYXRoRGlyZWN0aW9uLnggKiAyNSAqIGopLFxuXG4gICAgICAgICAgICAgICAgICAgIHk6IHBhdGhMaW5lc1tpXS5zdGFydFBvaW50LnkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aERpcmVjdGlvbi55T2Zmc2V0IC1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhEaXJlY3Rpb24ueVNpZGUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHBhdGhEaXJlY3Rpb24ueSAqIDI1ICogaiApXG5cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBibG9ja0FmdGVyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogcGF0aExpbmVzW2ldLnN0YXJ0UG9pbnQueCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aERpcmVjdGlvbi54T2Zmc2V0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoRGlyZWN0aW9uLnhTaWRlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocGF0aERpcmVjdGlvbi54ICogMjUgKiBqKSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgeTogcGF0aExpbmVzW2ldLnN0YXJ0UG9pbnQueSAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhEaXJlY3Rpb24ueU9mZnNldCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aERpcmVjdGlvbi55U2lkZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBhdGhEaXJlY3Rpb24ueSAqIDI1ICogailcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJsb2Nrcy5wdXNoKF9jb252ZXJ0VG9CbG9jayhibG9ja0JlZm9yZSkpO1xuICAgICAgICAgICAgICAgIGJsb2Nrcy5wdXNoKF9jb252ZXJ0VG9CbG9jayhibG9ja0FmdGVyKSk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJsb2Nrc1xuICAgIH1cblxuICAgIC8vIFRha2VzIGluIGEgcG9zaXRpb24gb2JqZWN0IHdpdGggY29vcmRpbmF0ZXN7eCwgeX1cbiAgICAvLyByZXR1cm5zIGEgYmxvY2sgb2JqZWN0IHt4LCB5fSB3aXRoIGJsb2NrIG51bWJlcnNcbiAgICAvLyBIYW5kbGVzIGVkZ2UgY2FzZXMgb2YgdGhlIGJsb2NrIGJlaW5nIGRlZmluZWQgYXQgdGhlIGVkZ2UgKDM2IGFuZCAyNCB3aGljaCBhcmUgaW52YWxpZCBpbiB0aGUgKVxuICAgIGZ1bmN0aW9uIF9jb252ZXJ0VG9CbG9jayhwb3NpdGlvbikge1xuICAgICAgICB2YXIgYmxvY2sgPSB7XG4gICAgICAgICAgICB4OiBNYXRoLmZsb29yKHBvc2l0aW9uLnggLyAyNSksXG4gICAgICAgICAgICB5OiBNYXRoLmZsb29yKHBvc2l0aW9uLnkgLyAyNSlcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQWRqdXN0cyBpZiBtb3VzZSBpcyBhdCBlbmQgb2YgY29udGFpbmVyXG4gICAgICAgIC8vIDM2IGJsb2NrcyB3aWR0aCBhbmQgMjQgYmxvY2tzIGhlaWdodFxuICAgICAgICBpZiAoYmxvY2sueCA+PSAzNSkge1xuICAgICAgICAgICAgYmxvY2sueC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJsb2NrLnkgPj0gMjMpIHtcbiAgICAgICAgICAgIGJsb2NrLnktLTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKlxuICAgIElucHV0OiBQYXRoIC0gYW4gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIGNvb3JkaW5hdGVzIHdoZXJlIHRoZSBwYXRoIHdpbGwgcnVuIHRvXG4gICAgT3V0cHV0OiBwYXRoTGluZXMgLSBhbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIHN0YXJ0UG9pbnQgKGNvb3JkaW5hdGVzKSwgZGlzdGFuY2Ugb2YgdGhlIGxpbmUgYW5kIGRpcmVjdGlvbiAobGVmdCwgcmlnaHQsIHVwLCBkb3duKVxuICAgICovXG4gICAgZnVuY3Rpb24gX2NvbnZlcnRQYXRoVG9MaW5lcyhwYXRoKSB7XG4gICAgICAgIHZhciBwYXRoTGluZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSB7fTtcblxuICAgICAgICAgICAgLy8gQXNzdW1lIHRoYXQgdGhlIGRpcmVjdGlvbiBpcyBvbmx5IDQgd2F5c1xuICAgICAgICAgICAgaWYgKHBhdGhbaSsxXS54IC0gcGF0aFtpXS54ID09PSAwKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAocGF0aFtpKzFdLnkgLSBwYXRoW2ldLnkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUuZGlyZWN0aW9uID0gXCJkb3duXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZS5kaXJlY3Rpb24gPSBcInVwXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocGF0aFtpKzFdLnggLSBwYXRoW2ldLnggPT09IDAgPiAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgbGluZS5kaXJlY3Rpb24gPSBcImxlZnRcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsaW5lLmRpcmVjdGlvbiA9IFwicmlnaHRcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5lLnN0YXJ0UG9pbnQgPSBwYXRoW2ldO1xuICAgICAgICAgICAgbGluZS5kaXN0YW5jZSA9IGdldFBvc2l0aW9uRGlmZmVyZW5jZShwYXRoW2ldLCBwYXRoW2krMV0pO1xuICAgICAgICAgICAgcGF0aExpbmVzLnB1c2gobGluZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0aExpbmVzO1xuICAgIH1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT0gUHVibGljIGZ1bmN0aW9ucyA9PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4gICAgZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgY3NzQ2xhc3MpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuY2xhc3NOYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNzc0NsYXNzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgKz0gXCIgXCIgKyBjc3NDbGFzcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNzc0NsYXNzKSB7XG4gICAgICAgIHZhciBhcnJheU9mQ2xhc3NlcyA9IGVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBhcnJheU9mQ2xhc3Nlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChhcnJheU9mQ2xhc3Nlc1tpXSA9PT0gY3NzQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICBhcnJheU9mQ2xhc3Nlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgaS0tOyBqLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBhcnJheU9mQ2xhc3Nlcy5qb2luKFwiIFwiKTtcbiAgICB9XG5cbiAgICAvLyBHZXRzIHRoZSBpbmRleCBvZiB0aGUgdG93ZXIgY2FyZHMgYmFzZWQgb24gYSB0b3dlcidzIG5hbWVcbiAgICBmdW5jdGlvbiBnZXRUb3dlckNhcmRJbmRleCh0b3dlckNhcmRMaXN0LCB0b3dlck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRvd2VyQ2FyZExpc3QuaW5kZXhPZih0b3dlck5hbWUpO1xuICAgIH1cblxuICAgIC8qXG4gICAgVGFrZXMgaW4gYSBwb3NpdGlvbiBvYmplY3QgKHggYW5kIHkgY29vcmRpbmF0ZXMpXG4gICAgUmV0dXJucyB0aGUgdG9wIGxlZnQgYmxvY2sgcG9zaXRpb24gYW5kIHRvcGxlZnQgY29vcmRpbmF0ZSBvZiB0aGUgdG93ZXJcbiAgICBHcmlkIGJsb2NrcyBhcmUgaW4gMjV4MjUgYmxvY2sgaW5jcmVtZW50c1xuICAgICovXG4gICAgZnVuY3Rpb24gY29udmVydFBvc2l0aW9uVG9Ub3dlcihwb3NpdGlvbikge1xuICAgICAgICB2YXIgdG93ZXJQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIGdyaWQ6IHt9LFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IHt9LFxuICAgICAgICAgICAgc2lkZTogNTBcbiAgICAgICAgfTtcblxuICAgICAgICB0b3dlclBvc2l0aW9uLmdyaWQgPSBfY29udmVydFRvQmxvY2socG9zaXRpb24pO1xuXG4gICAgICAgIC8vIENvbnRhaW5lciB3aWR0aCBhbmQgaGVpZ2h0IDkwMCBhbmQgNjAwIHB4IHJlc3BlY3RpdmVseVxuICAgICAgICB0b3dlclBvc2l0aW9uLmNvb3JkaW5hdGVzLnggPSAodG93ZXJQb3NpdGlvbi5ncmlkLnggLyAzNikgKiA5MDA7XG4gICAgICAgIHRvd2VyUG9zaXRpb24uY29vcmRpbmF0ZXMueSA9ICh0b3dlclBvc2l0aW9uLmdyaWQueSAvIDI0KSAqIDYwMDtcbiAgICAgICAgcmV0dXJuIHRvd2VyUG9zaXRpb247XG4gICAgfVxuXG4gICAgLypcbiAgICBjaGVja0lmSW5TcXVhcmUgY2hlY2tzIHdoZXRoZXIgYSBwb2ludCBpcyBpbiBhIHNxdWFyZSAod2hpY2ggaXMgYSBtb25zdGVyIG9yIGEgdG93ZXIpXG5cbiAgICBUYWtlcyBpbiB0aHJlZSBhcmd1bWVudHNcbiAgICBwb2ludCAtIGEgb2JqZWN0IHdpdGggeCBhbmQgeSBjb29yZGluYXRlc1xuICAgIHRvcExlZnRQb2ludCAtIGFuIG9iamVjdCB3aXRoIHggYW5kIHkgY29vcmRpbmF0ZXMgb2YgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgc3F1YXJlXG4gICAgc2lkZUxlbmd0aCAtIHRoZSBsZW5ndGggb2YgdGhlIHNxdWFyZVxuXG4gICAgUmV0dXJucyBhIGJvb2xlYW4gLSB0cnVlIGlmIHRoZSBjbGljayBvdmVybGFwcyB3aXRoIGFuIGVsZW1lbnQgYW5kIGZhbHNlXG4gICAgaWYgaXQgZG9lcyBub3RcbiAgICAqL1xuICAgIGZ1bmN0aW9uIGNoZWNrSWZJblNxdWFyZShwb2ludCwgdG9wTGVmdFBvaW50LCBzaWRlTGVuZ3RoKSB7XG4gICAgICAgIGlmIChwb2ludC54ID49IHRvcExlZnRQb2ludC54XG4gICAgICAgICYmIHBvaW50LnggPD0gdG9wTGVmdFBvaW50LnggKyBzaWRlTGVuZ3RoXG4gICAgICAgICYmIHBvaW50LnkgPj0gdG9wTGVmdFBvaW50LnlcbiAgICAgICAgJiYgcG9pbnQueSA8PSB0b3BMZWZ0UG9pbnQueSArIHNpZGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gR3JpZCBpcyAzNiBieSAyNFxuICAgIC8vIGNhbiBiZSBpbml0aWF0ZWQgYnkgW3hdW3ldIC0gZWFjaCBibG9jayBoYXMgYSBib29sZWFuIHRvIHJlcHJlc2VudCB3aGV0aGVyIHNvbWV0aGluZyBpcyB0aGVyZVxuICAgIGZ1bmN0aW9uIGluaXRpYXRlR3JpZChwYXRoKSB7XG4gICAgICAgIHZhciBncmlkID0gW10sXG4gICAgICAgICAgICBwYXRoTGluZXMgPSBfY29udmVydFBhdGhUb0xpbmVzKHBhdGgpLFxuICAgICAgICAgICAgYmxvY2tzID0gX2NyZWF0ZVBhdGhCbG9ja3MocGF0aExpbmVzKTtcblxuICAgICAgICAvLyBDcmVhdGUgdGhlIGdyaWRcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCAzNjsgeCsrKSB7XG4gICAgICAgICAgICBncmlkW3hdID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IDI0OyB5KyspIHtcbiAgICAgICAgICAgICAgICBncmlkW3hdW3ldID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJsb2Nrcy5tYXAoZnVuY3Rpb24oYmxvY2ssIGkpIHtcbiAgICAgICAgICAgIGdyaWRbYmxvY2sueF1bYmxvY2sueV0gPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnNvbGUudGFibGUoZ3JpZCk7XG5cbiAgICAgICAgcmV0dXJuIGdyaWQ7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldFBvc2l0aW9uRGlmZmVyZW5jZShwb3NpdGlvbjEsIHBvc2l0aW9uMikge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgICAgIE1hdGgucG93KHBvc2l0aW9uMS54LXBvc2l0aW9uMi54LCAyKSArXG4gICAgICAgICAgICAgICAgTWF0aC5wb3cocG9zaXRpb24xLnktcG9zaXRpb24yLnksIDIpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkQ2xhc3M6IGFkZENsYXNzLFxuICAgICAgICByZW1vdmVDbGFzczogcmVtb3ZlQ2xhc3MsXG4gICAgICAgIGdldFRvd2VyQ2FyZEluZGV4OiBnZXRUb3dlckNhcmRJbmRleCxcbiAgICAgICAgY29udmVydFBvc2l0aW9uVG9Ub3dlcjogY29udmVydFBvc2l0aW9uVG9Ub3dlcixcbiAgICAgICAgY2hlY2tJZkluU3F1YXJlOiBjaGVja0lmSW5TcXVhcmUsXG4gICAgICAgIGluaXRpYXRlR3JpZDogaW5pdGlhdGVHcmlkLFxuICAgICAgICBnZXRQb3NpdGlvbkRpZmZlcmVuY2U6IGdldFBvc2l0aW9uRGlmZmVyZW5jZVxuICAgIH1cbn0oKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvdXRpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAgcmVxdWlyZSBNb25zdGVyIHRvIGdhaW4gYWNjZXNzXG52YXIgTW9uc3RlciA9IHJlcXVpcmUoXCIuL01vbnN0ZXIuanNcIiksXG4gICAgVG93ZXIgPSByZXF1aXJlKFwiLi9Ub3dlci5qc1wiKSxcbiAgICB0b3dlckRhdGEgPSByZXF1aXJlKFwiLi4vZ2FtZURhdGEvdG93ZXJkYXRhLmpzXCIpLFxuICAgIHV0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzLmpzXCIpLFxuICAgIHBhdGhDb29yZGluYXRlcyA9IHJlcXVpcmUoXCIuLi9nYW1lRGF0YS9wYXRoZGF0YS5qc1wiKTtcblxudmFyIEdhbWVFbmdpbmUgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnVzZXJHb2xkID0gMTA7XG4gICAgdGhpcy5sZXZlbCA9IDE7XG4gICAgdGhpcy51c2VyTGl2ZXMgPSAzMDtcbiAgICB0aGlzLmFjdGl2ZU1vbnN0ZXJzID0gW107IC8vIExpc3Qgb2YgYWN0aXZlIG1vbnN0ZXJzIGluIHRoZVxuICAgIHRoaXMudG93ZXJzID0gW107IC8vIG9iamVjdCBvZiB0b3dlciBvYmplY3RzXG4gICAgdGhpcy50aW1lciA9IDE7XG4gICAgdGhpcy5nYW1lR3JpZCA9IHV0aWxzLmluaXRpYXRlR3JpZChwYXRoQ29vcmRpbmF0ZXMucGF0aCk7XG59XG5cbkdhbWVFbmdpbmUucHJvdG90eXBlLmFkZE1vbnN0ZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgLy8gYWRkIG1vbnN0ZXIgKHNwZWNpZmllZCBieSBuYW1lKSB0byBnYW1lXG4gICAgdmFyIG1vbnN0ZXIgPSBuZXcgTW9uc3RlcihcIm1vbnN0ZXIxXCIpO1xuICAgIHRoaXMuYWN0aXZlTW9uc3RlcnMucHVzaChtb25zdGVyKTtcbn1cblxuR2FtZUVuZ2luZS5wcm90b3R5cGUuYWRkVG93ZXIgPSBmdW5jdGlvbihpZCwgcG9zaXRpb24sIGdvbGRDb3N0KSB7XG4gICAgdGhpcy51c2VyR29sZCAtPSBnb2xkQ29zdDtcbiAgICB2YXIgdG93ZXIgPSBuZXcgVG93ZXIocG9zaXRpb24sIGlkKTtcbiAgICB0aGlzLnRvd2Vycy5wdXNoKHRvd2VyKTtcblxufVxuXG4vLyBtZXRob2QgdG8gY2hlY2sgZ29sZCBiZWZvcmUgcGxhY2UgdG93ZXIgb3IgdXBncmFkZVxuR2FtZUVuZ2luZS5wcm90b3R5cGUuY2hlY2tHb2xkID0gZnVuY3Rpb24oZ29sZENvc3QpIHtcbiAgICBpZiAoZ29sZENvc3QgPD0gdGhpcy51c2VyR29sZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuR2FtZUVuZ2luZS5wcm90b3R5cGUuZ2FtZU92ZXIgPSBmdW5jdGlvbigpIHtcblxufVxuXG5HYW1lRW5naW5lLnByb3RvdHlwZS5nYW1lV29uID0gZnVuY3Rpb24oKSB7XG5cbn1cblxuLy8gTmV3IGxldmVsIG1ldGhvZFxuR2FtZUVuZ2luZS5wcm90b3R5cGUubmV4dExldmVsID0gZnVuY3Rpb24oKSB7XG5cbn1cblxuR2FtZUVuZ2luZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gc2VuZCBzdGF0ZSB0byB0aGUgZGlzcGxheSBvYmplY3QgdG8gcmVuZGVyXG4gICAgZHluYW1pY0NvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgZHluYW1pY0NvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGR5bmFtaWNDYW52YXMud2lkdGgsIGR5bmFtaWNDYW52YXMuaGVpZ2h0KTtcblxuICAgIC8vIFJlbmRlciB0b3dlcnMgZmlyc3Qgc28gdGhhdCBpZiBtb25zdGVycyBhcmUgbGFyZ2VyIHRoZXkgc2hvdyBhYm92ZSB0b3dlcnNcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMudG93ZXJzLmxlbmd0aDsgaSA8IGo7IGkgKyspIHtcbiAgICAgICAgdGhpcy50b3dlcnNbaV0uZHJhdygpO1xuICAgIH1cblxuICAgIC8vICBsb29wIHRocm91Z2ggbGlzdCBvZiBhY3RpdmUgbW9uc3RlcnMgYW5kIHJlbmRlciB0aGVtXG4gICAgLy8gIFRPRE8gcHJvYmFibHkgbmVlZCB0byBmaW5kIGEgYmV0dGVyIHdheSB0byByZW5kIHRoZW0gYXBhcnQgZnJvbSByYW5kb20gcmVjdGFuZ2xlXG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSB0aGlzLmFjdGl2ZU1vbnN0ZXJzLmxlbmd0aDsgaSA8IGo7IGkgKyspIHtcbiAgICAgICAgdGhpcy5hY3RpdmVNb25zdGVyc1tpXS5kcmF3KCk7XG4gICAgfVxuXG4gICAgZHluYW1pY0NvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICAvLyBkeW5hbWljQ29udGV4dC5cbn07XG5cbkdhbWVFbmdpbmUucHJvdG90eXBlLnJ1bkN5Y2xlID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gIGJlZ2lubmluZyBvZiBjeWNsZSBjaGVjayBpZiBhbnkgbW9uc3RlcnMgaGF2ZSBkaWVkIGlmIHNvIHJlbW92ZSBmcm9tIGFjdGl2ZSBtb25zdGVyc1xuICAgIHRoaXMuY2hlY2tNb25zdGVyRGVhdGgoKTtcbiAgICAvLyBsb29wIHRocm91Z2ggYWN0aXZlIG1vbnN0ZXJzIGFuZCB0b3dlcnMgYW5kIHJ1biB0aGUgY3ljbGVcbiAgICAvLyBFYWNoIHJ1bkN5Y2xlIG1ldGhvZCByZXR1cm5zIGluZm9ybWF0aW9uIGZvciB0aGUgZ2FtZUVuZ2luZSB0b1xuICAgIC8vIHByb2Nlc3MgKGUuZy4gdGhlIG1vbnN0ZXIgZGllZCwgdG93ZXIgY2hhbmdlZClcblxuICAgIC8vICB0aW1lciB0byBhZGQgbW9uc3RlcnNcbiAgICB0aGlzLnRpbWVyLS07XG4gICAgaWYgKHRoaXMudGltZXIgPCAxKSB7XG4gICAgICAgIHRoaXMuYWRkTW9uc3RlcignYmxhaCcpO1xuICAgICAgICB0aGlzLnRpbWVyID0gMTA7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBqID0gdGhpcy5hY3RpdmVNb25zdGVycy5sZW5ndGg7IGkgPCBqOyBpICsrKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlTW9uc3RlcnNbaV0ubW92ZSgpO1xuICAgIH1cbiAgICAvLyBTZW5kIGluZm9ybWF0aW9uIHRvIHJlbmRlclxufVxuXG4vLyBtZXRob2QgdG8gdXBncmFkZSB0b3dlclxuXG4vLyBncmlkIHRvd2VyXG5HYW1lRW5naW5lLnByb3RvdHlwZS52YWxpZGF0ZVRvd2VyUGxhY2VtZW50ID0gZnVuY3Rpb24oZ3JpZFBvc2l0aW9uKSB7XG4gICAgdmFyIHBvc2l0aW9uVmFsaWQgPSB0cnVlO1xuICAgIC8vIHJldHVybnMgdHJ1ZSBvciBmYWxzZSB3aGV0aGVyIHRvd2VyIHBsYWNlbWVudCBpcyB2YWxpZFxuICAgIHJldHVybiBwb3NpdGlvblZhbGlkO1xufVxuXG5HYW1lRW5naW5lLnByb3RvdHlwZS5jaGVja01vbnN0ZXJEZWF0aCA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gdGhpcy5hY3RpdmVNb25zdGVycy5sZW5ndGg7IGkgPCBqOyBpICsrKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZU1vbnN0ZXJzW2ldLmNoZWNrRGVhdGgoKSkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVNb25zdGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgICBqLS07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qXG5UYWtlcyBpbiBhIHBvc2l0aW9uIG9iamVjdCAobG9jYXRpb24gb2YgdGhlIGNsaWNrKVxuUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGlzIGF0IHRoYXQgcG9zaXRpb25cbnt0eXBlOiBudWxsfSBpZiBub3RoaW5nIGZvdW5kXG4qL1xuR2FtZUVuZ2luZS5wcm90b3R5cGUuY2hlY2tDbGlja0xvY2F0aW9uID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICB2YXIgZWxlbWVudCA9IHt9O1xuICAgIC8vIExvb3BzIHRocm91Z2ggYWN0aXZlTW9uc3RlcnNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0aXZlTW9uc3RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHV0aWxzLmNoZWNrSWZJblNxdWFyZShwb3NpdGlvbiwgdGhpcy5hY3RpdmVNb25zdGVyc1tpXS5wb3NpdGlvbiwgdGhpcy5hY3RpdmVNb25zdGVyc1tpXS5wb3NpdGlvbi5zaWRlTGVuZ3RoKSkge1xuICAgICAgICAgICAgZWxlbWVudC50eXBlID0gXCJtb25zdGVyXCI7XG4gICAgICAgICAgICBlbGVtZW50LmlkID0gdGhpcy5hY3RpdmVNb25zdGVyc1tpXS5pZDtcbiAgICAgICAgICAgIGVsZW1lbnQuaW5kZXggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCwgbG9vcCB0aHJvdWdoIHRvd2Vyc1xuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudG93ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodXRpbHMuY2hlY2tJZkluU3F1YXJlKHBvc2l0aW9uLCB0aGlzLnRvd2Vyc1tpXS5wb3NpdGlvbiwgdGhpcy50b3dlcnNbaV0ucG9zaXRpb24uc2lkZUxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnR5cGUgPSBcInRvd2VyXCI7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5pZCA9IHRoaXMudG93ZXJzW2ldLmlkO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbm8gdG93ZXJzIG9yIG1vbnN0ZXJzIGZvdW5kIHJldHVybiBhIHR5cGUgb2YgbnVsbFxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbGVtZW50LnR5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xufVxuXG4vKlxucGxhY2VUb3dlciBoYW5kbGVzIHRoZSB2YWxpZGF0aW9uIG9mIHRoZSB0b3dlciBwbGFjZW1lbnQgKHBvc2l0aW9uIGFuZCBzdWZmaWNpZW50IGdvbGQpXG5UYWtlcyBpbiAzIGFyZ3VtZW50czpcbnRvd2VyTmFtZSAtIHN0cmluZyBzcGVjaWZ5aW5nIHdoYXQgdG93ZXIgaXMgYmVpbmcgcGxhY2VkXG5ncmlkUG9zaXRpb24gLSB0b3AgbGVmdCBncmlkIGJsb2NrIG9mIHdoZXJlIHRoZSB0b3dlciB3b3VsZCBiZSBwbGFjZWRcbnRvd2VyQ29vcmRpbmF0ZXMgLSB0b3AgbGVmdCBjb29yZGluYXRlIG9mIGEgdG93ZXJcblJldHVybnMgYW4gb2JqZWN0IHdpdGggYSBib29sZWFuIHRvIHJlcHJlc2VudCB3aGV0aGVyIHRoZSB0b3dlciBpcyBwbGFjZWQgYW5kIGFuIGVycm9yIG1lc3NhZ2UgaWYgdGhlIHRvd2VyIHdhcyBub3QgcGxhY2VkXG4qL1xuR2FtZUVuZ2luZS5wcm90b3R5cGUucGxhY2VUb3dlciA9IGZ1bmN0aW9uKHRvd2VyTmFtZSwgZ3JpZFBvc2l0aW9uLCB0b3dlckNvb3JkaW5hdGVzKSB7XG4gICAgdmFyIGdvbGRDb3N0ID0gdG93ZXJEYXRhW3Rvd2VyTmFtZV0uZ29sZENvc3Q7XG4gICAgLy8gVmFsaWRhdGUgdG93ZXIgcGxhY2VtZW50XG4gICAgaWYgKHRoaXMudmFsaWRhdGVUb3dlclBsYWNlbWVudChncmlkUG9zaXRpb24pXG4gICAgJiYgdGhpcy5jaGVja0dvbGQoZ29sZENvc3QpKSB7XG5cbiAgICAgICAgdGhpcy5hZGRUb3dlcih0b3dlck5hbWUsIHRvd2VyQ29vcmRpbmF0ZXMsIGdvbGRDb3N0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBsYWNlZDogdHJ1ZVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkYXRlVG93ZXJQbGFjZW1lbnQoZ3JpZFBvc2l0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwbGFjZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBUb3dlciBQbGFjZW1lbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwbGFjZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiTm90IEVub3VnaCBHb2xkXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gR2FtZUVuZ2luZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvY2xhc3Nlcy9HYW1lLmpzXG4gKiogbW9kdWxlIGlkID0gN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIG1vbnN0ZXJEYXRhID0gcmVxdWlyZShcIi4uL2dhbWVEYXRhL21vbnN0ZXJkYXRhLmpzXCIpO1xuXG52YXIgTW9uc3RlciA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuY3VycmVudEhwID0gbW9uc3RlckRhdGFbaWRdLm1heEhwO1xuICAgIHRoaXMubWF4SHAgPSBtb25zdGVyRGF0YVtpZF0ubWF4SHA7XG4gICAgdGhpcy5iYXNlTXMgPSBtb25zdGVyRGF0YVtpZF0uYmFzZU1zOyAvLyBNb3ZlbWVudCBzcGVlZCAtIFwidW5pdHNcIiBwZXIgc2Vjb25kXG4gICAgdGhpcy50eXBlID0gbW9uc3RlckRhdGFbaWRdLnR5cGU7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHsgLy8gQWxsIG1vbnN0ZXJzIGFyZSBjcmVhdGVkIGluIHRoZSBzYW1lIHBvc2l0aW9uIC0gdGhpcyBwb3NpdGlvbiBpcyByZWZlcmVuY2luZyB0aGUgdG9wbGVmdCBjb3JuZXIgb2YgdGhlIG9iamVjdFxuICAgICAgICB4OiAwLFxuICAgICAgICB5OiA0ODUsXG4gICAgICAgIHNpZGVMZW5ndGg6IDMwXG4gICAgfVxufTtcbi8vIE1ldGhvZCB0aGUgZ2FtZSBvYmplY3QgdXNlcyB0byBtb3ZlIG1vbnN0ZXJzXG5Nb25zdGVyLnByb3RvdHlwZS5ydW5DeWNsZSA9IGZ1bmN0aW9uKCkge1xuXG59XG5cbk1vbnN0ZXIucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbigpIHtcbiAgICBkeW5hbWljQ29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBkeW5hbWljQ29udGV4dC5yZWN0KHRoaXMucG9zaXRpb24ueCwgdGhpcy5wb3NpdGlvbi55LCAzMCwgMzApO1xuICAgIGR5bmFtaWNDb250ZXh0LnN0cm9rZSgpO1xuICAgIGR5bmFtaWNDb250ZXh0LmZpbGxTdHlsZSA9IFwicmVkXCI7XG4gICAgZHluYW1pY0NvbnRleHQuZmlsbFJlY3QodGhpcy5wb3NpdGlvbi54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24ueSArIDMwLzMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMzAgKiB0aGlzLmN1cnJlbnRIcC90aGlzLm1heEhwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMwLzMpO1xuICAgIGR5bmFtaWNDb250ZXh0LmNsb3NlUGF0aCgpO1xuXG59XG5cbk1vbnN0ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblxufTtcblxuTW9uc3Rlci5wcm90b3R5cGUuY2hlY2tEZWF0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRIcCA8PSAwO1xufTtcblxuLy8gRXhwZWN0cyB1cCwgZG93biwgbGVmdCBvciByaWdodFxuTW9uc3Rlci5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKGRpcmVjdGlvbikge1xuICAgIHZhciBzcGVlZCA9IHRoaXMuYmFzZU1zO1xuXG4gICAgLy8gc29tZSBiYXNpYyBtb25zdGVyIE1vdmVtZW50XG4gICAgLy8gIE5PVEUgc3VjaCBhIGhhc3NsZSB0byBmaWd1cmUgdGhpcyBvdXRcbiAgICAvLyAgVE9ETyBub3QgZmluaXNoZWQsIG5vdCBldmVuIGdvaW5nIHRvIHRyeSBhbmQgZmluaXNoIHdpbGwgZmlndXJlIG91dCBob3cgdGhpcyBzaG91bGQgd29yayBsYXRlclxuICAgIGlmICh0aGlzLnBvc2l0aW9uLnggPD0gNTAgJiYgdGhpcy5wb3NpdGlvbi55IDwgNTAwKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24ueCArPSBzcGVlZDtcbiAgICB9IGVsc2UgaWYgKHRoaXMucG9zaXRpb24ueCA+PSA1MCAmJiB0aGlzLnBvc2l0aW9uLnkgPj0gOTApIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi55IC09IHNwZWVkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wb3NpdGlvbi54IDw9IDE4MCAmJiB0aGlzLnBvc2l0aW9uLnkgPj0gODApIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi54ICs9IHNwZWVkO1xuICAgIH1cblxuICAgIC8vICBtYXkgbm90IGJlIHRoZSBiZXN0IHdheSB0byBkbyB0aGlzIGJ1dCBpbGwga2VlcCBpdCBiZWNhdXNlIG5vdCBldmVuIHN1cmUgaG93IHRvIGRvIHRoaXMgbW92ZW1lbnQgcGFydFxuICAgIC8vIGlmICh0eXBlb2YgZGlyZWN0aW9uICE9PSBcInN0cmluZ1wiKSB7XG4gICAgLy8gICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJkaXJlY3Rpb24gaXMgbm90IGEgc3RyaW5nXCIpO1xuICAgIC8vIH1cbiAgICAvLyBkaXJlY3Rpb24gPSBkaXJlY3Rpb24udG9Mb3dlckNhc2UoKTtcbiAgICAvLyBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgIC8vICAgICBjYXNlIFwidXBcIjpcbiAgICAvLyAgICAgY2FzZSBcImRvd25cIjpcbiAgICAvLyAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAvLyAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgLy8gICAgIGRlZmF1bHQ6XG4gICAgLy8gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRpcmVjdGlvblwiKTtcbiAgICAvLyB9XG59O1xuXG4vLyBDYW4gdGFrZSBpbiBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIG51bWJlclxuTW9uc3Rlci5wcm90b3R5cGUudXBkYXRlSHAgPSBmdW5jdGlvbihocENoYW5nZSkge1xuICAgIHRoaXMuY3VycmVudEhwICs9IGhwQ2hhbmdlO1xuXG4gICAgaWYgKHRoaXMuY3VycmVudEhwID4gdGhpcy5tYXhIcCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRIcCA9IHRoaXMubWF4SHA7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb25zdGVyO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9qcy9jbGFzc2VzL01vbnN0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtb25zdGVyMToge1xuICAgICAgICBtYXhIcDogMzAsXG4gICAgICAgIGJhc2VNczogMTAsXG4gICAgICAgIHR5cGU6IDEgLy8gQ2hhbmdlIHRoaXMgdHlwZSBsYXRlclxuICAgIH1cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2pzL2dhbWVEYXRhL21vbnN0ZXJkYXRhLmpzXG4gKiogbW9kdWxlIGlkID0gOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcGF0aDogW1xuICAgICAgICB7eDogMCwgeTogNTAwfSxcbiAgICAgICAge3g6IDc1LCB5OiA1MDB9LFxuICAgICAgICB7eDogNzUsIHk6IDEwMH0sXG4gICAgICAgIHt4OiAyMjUsIHk6IDEwMH0sXG4gICAgICAgIHt4OiAyMjUsIHk6IDUwMH0sXG4gICAgICAgIHt4OiAzNzUsIHk6IDUwMH0sXG4gICAgICAgIHt4OiAzNzUsIHk6IDEwMH0sXG4gICAgICAgIHt4OiA1MjUsIHk6IDEwMH0sXG4gICAgICAgIHt4OiA1MjUsIHk6IDUwMH0sXG4gICAgICAgIHt4OiA2NzUsIHk6IDUwMH0sXG4gICAgICAgIHt4OiA2NzUsIHk6IDEwMH0sXG4gICAgICAgIHt4OiA4MjUsIHk6IDEwMH0sXG4gICAgICAgIHt4OiA4MjUsIHk6IDUwMH0sXG4gICAgICAgIHt4OiA5MDAsIHk6IDUwMH1cbiAgICBdXG59XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2pzL2dhbWVEYXRhL3BhdGhkYXRhLmpzXG4gKiogbW9kdWxlIGlkID0gMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=