/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/src/js/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	// Canvas
	__webpack_require__(2);
	
	// User interaction elements
	__webpack_require__(3);


/***/ },
/* 2 */
/***/ function(module, exports) {

	// background contains the static canvas elements
	var background = document.getElementById("static");
	var backgroundContext = background.getContext("2d");
	
	// Settings for the background - move out to a separate file
	var settings = {
	    backgroundColor: "#8CD1E6",
	    pathColor: "gray"
	}
	
	// Drawing the background
	backgroundContext.fillStyle = settings.backgroundColor;
	backgroundContext.fillRect(0, 0, background.width, background.height);
	
	/* Main path will go from [0, 500], [75, 500], [75, 100], [225, 100], [225, 500], [375, 500], [375, 100], [525, 100], [525, 500], [675, 500], [675, 100], [825, 100], [825, 500], [900, 500] */
	
	// Drawing the path - width of the path is 50px
	backgroundContext.fillStyle = settings.pathColor;
	
	backgroundContext.beginPath();
	
	// For the bottom part of the path
	backgroundContext.moveTo(0, 525);
	
	backgroundContext.lineTo(100, 525);
	backgroundContext.lineTo(100, 125); // Top
	backgroundContext.lineTo(200, 125);
	backgroundContext.lineTo(200, 525); // Bottom
	backgroundContext.lineTo(400, 525);
	backgroundContext.lineTo(400, 125); // Top
	backgroundContext.lineTo(500, 125);
	backgroundContext.lineTo(500, 525); // Bottom
	backgroundContext.lineTo(700, 525);
	backgroundContext.lineTo(700, 125); // Top
	backgroundContext.lineTo(800, 125);
	backgroundContext.lineTo(800, 525); // Bottom
	
	//Middle section to the side
	backgroundContext.lineTo(900, 525);
	backgroundContext.lineTo(900, 475);
	backgroundContext.lineTo(850, 475);
	
	// For the top part of the path
	backgroundContext.lineTo(850, 75);
	backgroundContext.lineTo(650, 75);
	backgroundContext.lineTo(650, 475);
	backgroundContext.lineTo(550, 475);
	backgroundContext.lineTo(550, 75);
	backgroundContext.lineTo(350, 75);
	backgroundContext.lineTo(350, 475);
	backgroundContext.lineTo(250, 475);
	backgroundContext.lineTo(250, 75);
	backgroundContext.lineTo(50, 75);
	backgroundContext.lineTo(50, 475);
	
	// End section
	backgroundContext.lineTo(0, 475);
	
	backgroundContext.fill();
	// backgroundContext.lineTo();


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	// Initiate all the components
	var Tower = __webpack_require__(4),
	    GameEngine = __webpack_require__(5),
	    game = new GameEngine;
	
	
	// HERE IS ALL THE INTERACTION EVENT LISTENERS
	
	/* ============== On start click handlers ==============*/
	/* =====================================================*/
	
	// On start, create a game element - these event listeners will be destroyed when the container is overriden
	document.getElementById("start-btn").addEventListener("click", function() {
	    // Hides the modal lightbox
	    document.getElementsByClassName("modal-content")[0].style.display = "none";
	    document.getElementsByClassName("modal-background")[0].style.display = "none";
	});
	
	// On clicking the information button, show the information panel
	document.getElementById("information-btn").addEventListener("click", function() {
	    console.log("show information container here");
	});
	
	/* ======== Information container interactions =========*/
	/* =====================================================*/
	
	
	
	/* ================= Information Hover =================*/
	/* =====================================================*/
	// Shows information about towers or monsters if hovered over
	// or active
	var activeCanvasElement = null;
	
	
	// Get information from towerdata.js
	
	/* ========== Tower Card Click and placements ==========*/
	/* =====================================================*/
	// Click a tower card and make "active" which can be placed on UI element
	// While it is active - use #dynamic.onmousemove = function -> to Send
	// information to the canvas
	
	// set up event listeners at the start which reference functions - these functions depend on the state on the application to control their control flow
	var activeTowerSelected = null;
	var towerCards = document.getElementsByClassName("tower-card");
	var towerCardList = [];
	
	function addClass(element, cssClass) {
	    if (element.className === "") {
	        element.className = cssClass;
	    } else {
	        element.className += " " + cssClass;
	    }
	}
	
	function removeClass(element, cssClass) {
	    var arrayOfClasses = element.className.split(" ");
	    for (var i = 0; i < arrayOfClasses.length; i++) {
	        if (arrayOfClasses[i] === cssClass) {
	            arrayOfClasses.splice(i, 1);
	        }
	    }
	    element.className = arrayOfClasses.join(" ");
	}
	
	function getIndex(towerName) {
	    return towerCardList.indexOf(towerName);
	}
	
	function towerCardClick() {
	
	    var towerName = this.getAttribute("data-tower");
	
	    if (/disabled/i.test(this.className)) { // Tower is disabled
	        return;
	    } else if (activeTowerSelected === null) { // There is no active tower being placed
	        // set the active tower selected to be the tower name
	        // Set up active elements
	        activeTowerSelected = towerName;
	        addClass(towerCards[getIndex(activeTowerSelected)], "active");
	    } else if (activeTowerSelected === towerName) { // The tower card clicked is the same as the active tower
	        cancelTowerPlacement();
	    } else { // There is an active tower which is not the same as what was clicked
	        removeClass(towerCards[getIndex(activeTowerSelected)], "active");
	        activeTowerSelected = towerName;
	        addClass(towerCards[getIndex(activeTowerSelected)], "active");
	    }
	}
	
	function onTowerMouseMovement(e) {
	    if (activeTowerSelected === null) {
	        return
	    };
	    var canvasContainer = this.getBoundingClientRect();
	    var offsetX = e.clientX - canvasContainer.left,
	        offsetY = e.clientY - canvasContainer.top;
	    // send to display to get rendered
	};
	
	function towerPlacement(e) {
	    if (activeTowerSelected === null) {
	        return;
	    }
	
	    var towerName = activeTowerSelected, // NOTE CHANGE GET TOWER NAME FROM LIST
	        canvasContainer = this.getBoundingClientRect(),
	        position = {};
	
	    position.x = e.clientX - canvasContainer.left;
	    position.y = e.clientY - canvasContainer.top;
	
	    if (game.validateTowerPlacement(towerName, position)) {
	        console.log("towerPlaced");
	        game.addTower(towerName, position);
	    } else {
	        console.log("invalid tower placement");
	        // show error message somewhere for the user
	    }
	    removeClass(towerCards[getIndex(activeTowerSelected)], "active");
	    activeTowerSelected = null;
	}
	
	function cancelTowerPlacement() {
	
	    removeClass(towerCards[getIndex(activeTowerSelected)], "active");
	    activeTowerSelected = null;
	}
	
	
	// Set up event listeners
	// Convert from nodelist to array
	towerCards = Array.prototype.slice.call(towerCards);
	
	// Tower card click event listeners
	towerCards.map(function(towerCard, i) {
	    towerCardList.push(towerCard.getAttribute("data-tower"));
	    towerCard.addEventListener("click", towerCardClick);
	});
	
	// Game container event listeners
	document.getElementById("dynamic").onmousemove = onTowerMouseMovement;
	document.getElementById("dynamic").addEventListener("click", towerPlacement);
	
	// Tower placement cancelling event listeners
	document.onkeydown = function(e) {
	    if (e.keyCode === 27) {
	        cancelTowerPlacement();
	    }
	}


/***/ },
/* 4 */
/***/ function(module, exports) {

	var Tower = function(damage, speed, range, type, effect, position) {
	    this.damage = damage;
	    this.speed = speed; // Attack speed
	    this.range = range; // Range of the tower
	    this.type = type; // Type of damage
	    this.effect = effect; // Special effect (e.g. slow, splash, etc)
	    this.position = position; // object with x and y coordinates - should not change
	}
	// Method the game object uses to run towers
	Tower.prototype.runCycle = function() {
	
	}
	// change this to reference a list or something where a name can be used to determine the properties
	// Takes in a monster's position and checks whether that is in range based on the range - returns true or false if in range which can be used to
	Tower.prototype.checkInRange = function(monsterPosition) {
	
	}
	
	module.exports = Tower;


/***/ },
/* 5 */
/***/ function(module, exports) {

	var GameEngine = function() {
	    this.userGold = 10;
	    this.level = 1;
	    this.userLives = 30;
	    this.activeMonsters = {}; // List of active monsters in the
	    this.towers = {}; // object of tower objects
	
	    // Goes through and disables towers that can't be used yet
	}
	
	GameEngine.prototype.addMonster = function(name) {
	    // add monster (specified by name) to game
	}
	
	GameEngine.prototype.addTower = function(name, position) {
	    // add tower (specified by name) at location
	}
	
	// method to check gold before place tower or upgrade
	GameEngine.prototype.checkGold = function(goldCost) {
	    if (goldCost > this.userGold) {
	        return true;
	    } else {
	        return false;
	    }
	};
	
	GameEngine.prototype.gameOver = function() {
	
	}
	
	GameEngine.prototype.gameWon = function() {
	
	}
	
	// New level method
	GameEngine.prototype.nextLevel = function() {
	
	}
	
	GameEngine.prototype.render = function() {
	    // send state to the display object to render
	};
	
	GameEngine.prototype.runCycle = function() {
	    // loop through active monsters and towers and run the cycle
	    // Each runCycle method returns information for the gameEngine to
	    // process (e.g. the monster died, tower changed)
	
	    // loop and check death of monsters - update accordingly
	
	    // Send information to render
	}
	
	// method to upgrade tower
	
	GameEngine.prototype.validateTowerPlacement = function(name, position) {
	    // returns true or false whether tower placement is valid
	    return true;
	}
	
	// redraw canvas
	
	module.exports = GameEngine;


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNWI2YzYxYmQyZjU2ZWY1YjExOTYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2VudHJ5LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9iYWNrZ3JvdW5kLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NsYXNzZXMvVG93ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NsYXNzZXMvR2FtZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDSkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBLG9DQUFtQztBQUNuQztBQUNBLG9DQUFtQztBQUNuQztBQUNBLG9DQUFtQztBQUNuQztBQUNBLG9DQUFtQztBQUNuQztBQUNBLG9DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSw0Q0FBMkM7QUFDM0M7QUFDQSxNQUFLLHlDQUF5QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUssOENBQThDO0FBQ25EO0FBQ0EsTUFBSyxPQUFPO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQ3JKQTtBQUNBO0FBQ0Esd0JBQXVCO0FBQ3ZCLHdCQUF1QjtBQUN2QixzQkFBcUI7QUFDckIsMEJBQXlCO0FBQ3pCLDhCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkI7QUFDN0Isc0JBQXFCOztBQUVyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJmaWxlIjoibWFpbi5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvc3JjL2pzL1wiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgNWI2YzYxYmQyZjU2ZWY1YjExOTZcbiAqKi8iLCIvLyBDYW52YXNcbnJlcXVpcmUoXCIuL2JhY2tncm91bmQuanNcIik7XG5cbi8vIFVzZXIgaW50ZXJhY3Rpb24gZWxlbWVudHNcbnJlcXVpcmUoXCIuL2ludGVyZmFjZS5qc1wiKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvZW50cnkuanNcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBiYWNrZ3JvdW5kIGNvbnRhaW5zIHRoZSBzdGF0aWMgY2FudmFzIGVsZW1lbnRzXG52YXIgYmFja2dyb3VuZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RhdGljXCIpO1xudmFyIGJhY2tncm91bmRDb250ZXh0ID0gYmFja2dyb3VuZC5nZXRDb250ZXh0KFwiMmRcIik7XG5cbi8vIFNldHRpbmdzIGZvciB0aGUgYmFja2dyb3VuZCAtIG1vdmUgb3V0IHRvIGEgc2VwYXJhdGUgZmlsZVxudmFyIHNldHRpbmdzID0ge1xuICAgIGJhY2tncm91bmRDb2xvcjogXCIjOENEMUU2XCIsXG4gICAgcGF0aENvbG9yOiBcImdyYXlcIlxufVxuXG4vLyBEcmF3aW5nIHRoZSBiYWNrZ3JvdW5kXG5iYWNrZ3JvdW5kQ29udGV4dC5maWxsU3R5bGUgPSBzZXR0aW5ncy5iYWNrZ3JvdW5kQ29sb3I7XG5iYWNrZ3JvdW5kQ29udGV4dC5maWxsUmVjdCgwLCAwLCBiYWNrZ3JvdW5kLndpZHRoLCBiYWNrZ3JvdW5kLmhlaWdodCk7XG5cbi8qIE1haW4gcGF0aCB3aWxsIGdvIGZyb20gWzAsIDUwMF0sIFs3NSwgNTAwXSwgWzc1LCAxMDBdLCBbMjI1LCAxMDBdLCBbMjI1LCA1MDBdLCBbMzc1LCA1MDBdLCBbMzc1LCAxMDBdLCBbNTI1LCAxMDBdLCBbNTI1LCA1MDBdLCBbNjc1LCA1MDBdLCBbNjc1LCAxMDBdLCBbODI1LCAxMDBdLCBbODI1LCA1MDBdLCBbOTAwLCA1MDBdICovXG5cbi8vIERyYXdpbmcgdGhlIHBhdGggLSB3aWR0aCBvZiB0aGUgcGF0aCBpcyA1MHB4XG5iYWNrZ3JvdW5kQ29udGV4dC5maWxsU3R5bGUgPSBzZXR0aW5ncy5wYXRoQ29sb3I7XG5cbmJhY2tncm91bmRDb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4vLyBGb3IgdGhlIGJvdHRvbSBwYXJ0IG9mIHRoZSBwYXRoXG5iYWNrZ3JvdW5kQ29udGV4dC5tb3ZlVG8oMCwgNTI1KTtcblxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDEwMCwgNTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygxMDAsIDEyNSk7IC8vIFRvcFxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDIwMCwgMTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygyMDAsIDUyNSk7IC8vIEJvdHRvbVxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDQwMCwgNTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg0MDAsIDEyNSk7IC8vIFRvcFxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDUwMCwgMTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg1MDAsIDUyNSk7IC8vIEJvdHRvbVxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDcwMCwgNTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg3MDAsIDEyNSk7IC8vIFRvcFxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDgwMCwgMTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg4MDAsIDUyNSk7IC8vIEJvdHRvbVxuXG4vL01pZGRsZSBzZWN0aW9uIHRvIHRoZSBzaWRlXG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oOTAwLCA1MjUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDkwMCwgNDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg4NTAsIDQ3NSk7XG5cbi8vIEZvciB0aGUgdG9wIHBhcnQgb2YgdGhlIHBhdGhcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg4NTAsIDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg2NTAsIDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg2NTAsIDQ3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNTUwLCA0NzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDU1MCwgNzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDM1MCwgNzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDM1MCwgNDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygyNTAsIDQ3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oMjUwLCA3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNTAsIDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg1MCwgNDc1KTtcblxuLy8gRW5kIHNlY3Rpb25cbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygwLCA0NzUpO1xuXG5iYWNrZ3JvdW5kQ29udGV4dC5maWxsKCk7XG4vLyBiYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvYmFja2dyb3VuZC5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIEluaXRpYXRlIGFsbCB0aGUgY29tcG9uZW50c1xudmFyIFRvd2VyID0gcmVxdWlyZShcIi4vY2xhc3Nlcy9Ub3dlci5qc1wiKSxcbiAgICBHYW1lRW5naW5lID0gcmVxdWlyZShcIi4vY2xhc3Nlcy9HYW1lLmpzXCIpLFxuICAgIGdhbWUgPSBuZXcgR2FtZUVuZ2luZTtcblxuXG4vLyBIRVJFIElTIEFMTCBUSEUgSU5URVJBQ1RJT04gRVZFTlQgTElTVEVORVJTXG5cbi8qID09PT09PT09PT09PT09IE9uIHN0YXJ0IGNsaWNrIGhhbmRsZXJzID09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuLy8gT24gc3RhcnQsIGNyZWF0ZSBhIGdhbWUgZWxlbWVudCAtIHRoZXNlIGV2ZW50IGxpc3RlbmVycyB3aWxsIGJlIGRlc3Ryb3llZCB3aGVuIHRoZSBjb250YWluZXIgaXMgb3ZlcnJpZGVuXG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN0YXJ0LWJ0blwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgLy8gSGlkZXMgdGhlIG1vZGFsIGxpZ2h0Ym94XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIm1vZGFsLWNvbnRlbnRcIilbMF0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJtb2RhbC1iYWNrZ3JvdW5kXCIpWzBdLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbn0pO1xuXG4vLyBPbiBjbGlja2luZyB0aGUgaW5mb3JtYXRpb24gYnV0dG9uLCBzaG93IHRoZSBpbmZvcm1hdGlvbiBwYW5lbFxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbmZvcm1hdGlvbi1idG5cIikuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgIGNvbnNvbGUubG9nKFwic2hvdyBpbmZvcm1hdGlvbiBjb250YWluZXIgaGVyZVwiKTtcbn0pO1xuXG4vKiA9PT09PT09PSBJbmZvcm1hdGlvbiBjb250YWluZXIgaW50ZXJhY3Rpb25zID09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuXG4vKiA9PT09PT09PT09PT09PT09PSBJbmZvcm1hdGlvbiBIb3ZlciA9PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vLyBTaG93cyBpbmZvcm1hdGlvbiBhYm91dCB0b3dlcnMgb3IgbW9uc3RlcnMgaWYgaG92ZXJlZCBvdmVyXG4vLyBvciBhY3RpdmVcbnZhciBhY3RpdmVDYW52YXNFbGVtZW50ID0gbnVsbDtcblxuXG4vLyBHZXQgaW5mb3JtYXRpb24gZnJvbSB0b3dlcmRhdGEuanNcblxuLyogPT09PT09PT09PSBUb3dlciBDYXJkIENsaWNrIGFuZCBwbGFjZW1lbnRzID09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLy8gQ2xpY2sgYSB0b3dlciBjYXJkIGFuZCBtYWtlIFwiYWN0aXZlXCIgd2hpY2ggY2FuIGJlIHBsYWNlZCBvbiBVSSBlbGVtZW50XG4vLyBXaGlsZSBpdCBpcyBhY3RpdmUgLSB1c2UgI2R5bmFtaWMub25tb3VzZW1vdmUgPSBmdW5jdGlvbiAtPiB0byBTZW5kXG4vLyBpbmZvcm1hdGlvbiB0byB0aGUgY2FudmFzXG5cbi8vIHNldCB1cCBldmVudCBsaXN0ZW5lcnMgYXQgdGhlIHN0YXJ0IHdoaWNoIHJlZmVyZW5jZSBmdW5jdGlvbnMgLSB0aGVzZSBmdW5jdGlvbnMgZGVwZW5kIG9uIHRoZSBzdGF0ZSBvbiB0aGUgYXBwbGljYXRpb24gdG8gY29udHJvbCB0aGVpciBjb250cm9sIGZsb3dcbnZhciBhY3RpdmVUb3dlclNlbGVjdGVkID0gbnVsbDtcbnZhciB0b3dlckNhcmRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcInRvd2VyLWNhcmRcIik7XG52YXIgdG93ZXJDYXJkTGlzdCA9IFtdO1xuXG5mdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCBjc3NDbGFzcykge1xuICAgIGlmIChlbGVtZW50LmNsYXNzTmFtZSA9PT0gXCJcIikge1xuICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNzc0NsYXNzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lICs9IFwiIFwiICsgY3NzQ2xhc3M7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCBjc3NDbGFzcykge1xuICAgIHZhciBhcnJheU9mQ2xhc3NlcyA9IGVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KFwiIFwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZDbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhcnJheU9mQ2xhc3Nlc1tpXSA9PT0gY3NzQ2xhc3MpIHtcbiAgICAgICAgICAgIGFycmF5T2ZDbGFzc2VzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGFycmF5T2ZDbGFzc2VzLmpvaW4oXCIgXCIpO1xufVxuXG5mdW5jdGlvbiBnZXRJbmRleCh0b3dlck5hbWUpIHtcbiAgICByZXR1cm4gdG93ZXJDYXJkTGlzdC5pbmRleE9mKHRvd2VyTmFtZSk7XG59XG5cbmZ1bmN0aW9uIHRvd2VyQ2FyZENsaWNrKCkge1xuXG4gICAgdmFyIHRvd2VyTmFtZSA9IHRoaXMuZ2V0QXR0cmlidXRlKFwiZGF0YS10b3dlclwiKTtcblxuICAgIGlmICgvZGlzYWJsZWQvaS50ZXN0KHRoaXMuY2xhc3NOYW1lKSkgeyAvLyBUb3dlciBpcyBkaXNhYmxlZFxuICAgICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChhY3RpdmVUb3dlclNlbGVjdGVkID09PSBudWxsKSB7IC8vIFRoZXJlIGlzIG5vIGFjdGl2ZSB0b3dlciBiZWluZyBwbGFjZWRcbiAgICAgICAgLy8gc2V0IHRoZSBhY3RpdmUgdG93ZXIgc2VsZWN0ZWQgdG8gYmUgdGhlIHRvd2VyIG5hbWVcbiAgICAgICAgLy8gU2V0IHVwIGFjdGl2ZSBlbGVtZW50c1xuICAgICAgICBhY3RpdmVUb3dlclNlbGVjdGVkID0gdG93ZXJOYW1lO1xuICAgICAgICBhZGRDbGFzcyh0b3dlckNhcmRzW2dldEluZGV4KGFjdGl2ZVRvd2VyU2VsZWN0ZWQpXSwgXCJhY3RpdmVcIik7XG4gICAgfSBlbHNlIGlmIChhY3RpdmVUb3dlclNlbGVjdGVkID09PSB0b3dlck5hbWUpIHsgLy8gVGhlIHRvd2VyIGNhcmQgY2xpY2tlZCBpcyB0aGUgc2FtZSBhcyB0aGUgYWN0aXZlIHRvd2VyXG4gICAgICAgIGNhbmNlbFRvd2VyUGxhY2VtZW50KCk7XG4gICAgfSBlbHNlIHsgLy8gVGhlcmUgaXMgYW4gYWN0aXZlIHRvd2VyIHdoaWNoIGlzIG5vdCB0aGUgc2FtZSBhcyB3aGF0IHdhcyBjbGlja2VkXG4gICAgICAgIHJlbW92ZUNsYXNzKHRvd2VyQ2FyZHNbZ2V0SW5kZXgoYWN0aXZlVG93ZXJTZWxlY3RlZCldLCBcImFjdGl2ZVwiKTtcbiAgICAgICAgYWN0aXZlVG93ZXJTZWxlY3RlZCA9IHRvd2VyTmFtZTtcbiAgICAgICAgYWRkQ2xhc3ModG93ZXJDYXJkc1tnZXRJbmRleChhY3RpdmVUb3dlclNlbGVjdGVkKV0sIFwiYWN0aXZlXCIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gb25Ub3dlck1vdXNlTW92ZW1lbnQoZSkge1xuICAgIGlmIChhY3RpdmVUb3dlclNlbGVjdGVkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVyblxuICAgIH07XG4gICAgdmFyIGNhbnZhc0NvbnRhaW5lciA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIG9mZnNldFggPSBlLmNsaWVudFggLSBjYW52YXNDb250YWluZXIubGVmdCxcbiAgICAgICAgb2Zmc2V0WSA9IGUuY2xpZW50WSAtIGNhbnZhc0NvbnRhaW5lci50b3A7XG4gICAgLy8gc2VuZCB0byBkaXNwbGF5IHRvIGdldCByZW5kZXJlZFxufTtcblxuZnVuY3Rpb24gdG93ZXJQbGFjZW1lbnQoZSkge1xuICAgIGlmIChhY3RpdmVUb3dlclNlbGVjdGVkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdG93ZXJOYW1lID0gYWN0aXZlVG93ZXJTZWxlY3RlZCwgLy8gTk9URSBDSEFOR0UgR0VUIFRPV0VSIE5BTUUgRlJPTSBMSVNUXG4gICAgICAgIGNhbnZhc0NvbnRhaW5lciA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIHBvc2l0aW9uID0ge307XG5cbiAgICBwb3NpdGlvbi54ID0gZS5jbGllbnRYIC0gY2FudmFzQ29udGFpbmVyLmxlZnQ7XG4gICAgcG9zaXRpb24ueSA9IGUuY2xpZW50WSAtIGNhbnZhc0NvbnRhaW5lci50b3A7XG5cbiAgICBpZiAoZ2FtZS52YWxpZGF0ZVRvd2VyUGxhY2VtZW50KHRvd2VyTmFtZSwgcG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwidG93ZXJQbGFjZWRcIik7XG4gICAgICAgIGdhbWUuYWRkVG93ZXIodG93ZXJOYW1lLCBwb3NpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJpbnZhbGlkIHRvd2VyIHBsYWNlbWVudFwiKTtcbiAgICAgICAgLy8gc2hvdyBlcnJvciBtZXNzYWdlIHNvbWV3aGVyZSBmb3IgdGhlIHVzZXJcbiAgICB9XG4gICAgcmVtb3ZlQ2xhc3ModG93ZXJDYXJkc1tnZXRJbmRleChhY3RpdmVUb3dlclNlbGVjdGVkKV0sIFwiYWN0aXZlXCIpO1xuICAgIGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjYW5jZWxUb3dlclBsYWNlbWVudCgpIHtcblxuICAgIHJlbW92ZUNsYXNzKHRvd2VyQ2FyZHNbZ2V0SW5kZXgoYWN0aXZlVG93ZXJTZWxlY3RlZCldLCBcImFjdGl2ZVwiKTtcbiAgICBhY3RpdmVUb3dlclNlbGVjdGVkID0gbnVsbDtcbn1cblxuXG4vLyBTZXQgdXAgZXZlbnQgbGlzdGVuZXJzXG4vLyBDb252ZXJ0IGZyb20gbm9kZWxpc3QgdG8gYXJyYXlcbnRvd2VyQ2FyZHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0b3dlckNhcmRzKTtcblxuLy8gVG93ZXIgY2FyZCBjbGljayBldmVudCBsaXN0ZW5lcnNcbnRvd2VyQ2FyZHMubWFwKGZ1bmN0aW9uKHRvd2VyQ2FyZCwgaSkge1xuICAgIHRvd2VyQ2FyZExpc3QucHVzaCh0b3dlckNhcmQuZ2V0QXR0cmlidXRlKFwiZGF0YS10b3dlclwiKSk7XG4gICAgdG93ZXJDYXJkLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0b3dlckNhcmRDbGljayk7XG59KTtcblxuLy8gR2FtZSBjb250YWluZXIgZXZlbnQgbGlzdGVuZXJzXG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImR5bmFtaWNcIikub25tb3VzZW1vdmUgPSBvblRvd2VyTW91c2VNb3ZlbWVudDtcbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZHluYW1pY1wiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdG93ZXJQbGFjZW1lbnQpO1xuXG4vLyBUb3dlciBwbGFjZW1lbnQgY2FuY2VsbGluZyBldmVudCBsaXN0ZW5lcnNcbmRvY3VtZW50Lm9ua2V5ZG93biA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoZS5rZXlDb2RlID09PSAyNykge1xuICAgICAgICBjYW5jZWxUb3dlclBsYWNlbWVudCgpO1xuICAgIH1cbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvaW50ZXJmYWNlLmpzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIFRvd2VyID0gZnVuY3Rpb24oZGFtYWdlLCBzcGVlZCwgcmFuZ2UsIHR5cGUsIGVmZmVjdCwgcG9zaXRpb24pIHtcbiAgICB0aGlzLmRhbWFnZSA9IGRhbWFnZTtcbiAgICB0aGlzLnNwZWVkID0gc3BlZWQ7IC8vIEF0dGFjayBzcGVlZFxuICAgIHRoaXMucmFuZ2UgPSByYW5nZTsgLy8gUmFuZ2Ugb2YgdGhlIHRvd2VyXG4gICAgdGhpcy50eXBlID0gdHlwZTsgLy8gVHlwZSBvZiBkYW1hZ2VcbiAgICB0aGlzLmVmZmVjdCA9IGVmZmVjdDsgLy8gU3BlY2lhbCBlZmZlY3QgKGUuZy4gc2xvdywgc3BsYXNoLCBldGMpXG4gICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uOyAvLyBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvb3JkaW5hdGVzIC0gc2hvdWxkIG5vdCBjaGFuZ2Vcbn1cbi8vIE1ldGhvZCB0aGUgZ2FtZSBvYmplY3QgdXNlcyB0byBydW4gdG93ZXJzXG5Ub3dlci5wcm90b3R5cGUucnVuQ3ljbGUgPSBmdW5jdGlvbigpIHtcblxufVxuLy8gY2hhbmdlIHRoaXMgdG8gcmVmZXJlbmNlIGEgbGlzdCBvciBzb21ldGhpbmcgd2hlcmUgYSBuYW1lIGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSB0aGUgcHJvcGVydGllc1xuLy8gVGFrZXMgaW4gYSBtb25zdGVyJ3MgcG9zaXRpb24gYW5kIGNoZWNrcyB3aGV0aGVyIHRoYXQgaXMgaW4gcmFuZ2UgYmFzZWQgb24gdGhlIHJhbmdlIC0gcmV0dXJucyB0cnVlIG9yIGZhbHNlIGlmIGluIHJhbmdlIHdoaWNoIGNhbiBiZSB1c2VkIHRvXG5Ub3dlci5wcm90b3R5cGUuY2hlY2tJblJhbmdlID0gZnVuY3Rpb24obW9uc3RlclBvc2l0aW9uKSB7XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUb3dlcjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvY2xhc3Nlcy9Ub3dlci5qc1xuICoqIG1vZHVsZSBpZCA9IDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBHYW1lRW5naW5lID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy51c2VyR29sZCA9IDEwO1xuICAgIHRoaXMubGV2ZWwgPSAxO1xuICAgIHRoaXMudXNlckxpdmVzID0gMzA7XG4gICAgdGhpcy5hY3RpdmVNb25zdGVycyA9IHt9OyAvLyBMaXN0IG9mIGFjdGl2ZSBtb25zdGVycyBpbiB0aGVcbiAgICB0aGlzLnRvd2VycyA9IHt9OyAvLyBvYmplY3Qgb2YgdG93ZXIgb2JqZWN0c1xuXG4gICAgLy8gR29lcyB0aHJvdWdoIGFuZCBkaXNhYmxlcyB0b3dlcnMgdGhhdCBjYW4ndCBiZSB1c2VkIHlldFxufVxuXG5HYW1lRW5naW5lLnByb3RvdHlwZS5hZGRNb25zdGVyID0gZnVuY3Rpb24obmFtZSkge1xuICAgIC8vIGFkZCBtb25zdGVyIChzcGVjaWZpZWQgYnkgbmFtZSkgdG8gZ2FtZVxufVxuXG5HYW1lRW5naW5lLnByb3RvdHlwZS5hZGRUb3dlciA9IGZ1bmN0aW9uKG5hbWUsIHBvc2l0aW9uKSB7XG4gICAgLy8gYWRkIHRvd2VyIChzcGVjaWZpZWQgYnkgbmFtZSkgYXQgbG9jYXRpb25cbn1cblxuLy8gbWV0aG9kIHRvIGNoZWNrIGdvbGQgYmVmb3JlIHBsYWNlIHRvd2VyIG9yIHVwZ3JhZGVcbkdhbWVFbmdpbmUucHJvdG90eXBlLmNoZWNrR29sZCA9IGZ1bmN0aW9uKGdvbGRDb3N0KSB7XG4gICAgaWYgKGdvbGRDb3N0ID4gdGhpcy51c2VyR29sZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuR2FtZUVuZ2luZS5wcm90b3R5cGUuZ2FtZU92ZXIgPSBmdW5jdGlvbigpIHtcblxufVxuXG5HYW1lRW5naW5lLnByb3RvdHlwZS5nYW1lV29uID0gZnVuY3Rpb24oKSB7XG5cbn1cblxuLy8gTmV3IGxldmVsIG1ldGhvZFxuR2FtZUVuZ2luZS5wcm90b3R5cGUubmV4dExldmVsID0gZnVuY3Rpb24oKSB7XG5cbn1cblxuR2FtZUVuZ2luZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gc2VuZCBzdGF0ZSB0byB0aGUgZGlzcGxheSBvYmplY3QgdG8gcmVuZGVyXG59O1xuXG5HYW1lRW5naW5lLnByb3RvdHlwZS5ydW5DeWNsZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGxvb3AgdGhyb3VnaCBhY3RpdmUgbW9uc3RlcnMgYW5kIHRvd2VycyBhbmQgcnVuIHRoZSBjeWNsZVxuICAgIC8vIEVhY2ggcnVuQ3ljbGUgbWV0aG9kIHJldHVybnMgaW5mb3JtYXRpb24gZm9yIHRoZSBnYW1lRW5naW5lIHRvXG4gICAgLy8gcHJvY2VzcyAoZS5nLiB0aGUgbW9uc3RlciBkaWVkLCB0b3dlciBjaGFuZ2VkKVxuXG4gICAgLy8gbG9vcCBhbmQgY2hlY2sgZGVhdGggb2YgbW9uc3RlcnMgLSB1cGRhdGUgYWNjb3JkaW5nbHlcblxuICAgIC8vIFNlbmQgaW5mb3JtYXRpb24gdG8gcmVuZGVyXG59XG5cbi8vIG1ldGhvZCB0byB1cGdyYWRlIHRvd2VyXG5cbkdhbWVFbmdpbmUucHJvdG90eXBlLnZhbGlkYXRlVG93ZXJQbGFjZW1lbnQgPSBmdW5jdGlvbihuYW1lLCBwb3NpdGlvbikge1xuICAgIC8vIHJldHVybnMgdHJ1ZSBvciBmYWxzZSB3aGV0aGVyIHRvd2VyIHBsYWNlbWVudCBpcyB2YWxpZFxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vLyByZWRyYXcgY2FudmFzXG5cbm1vZHVsZS5leHBvcnRzID0gR2FtZUVuZ2luZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvY2xhc3Nlcy9HYW1lLmpzXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==