/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/src/js/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	// Canvas
	__webpack_require__(2);
	
	// User interaction elements
	__webpack_require__(3);


/***/ },
/* 2 */
/***/ function(module, exports) {

	// background contains the static canvas elements
	var background = document.getElementById("static");
	var backgroundContext = background.getContext("2d");
	
	// Settings for the background - move out to a separate file
	var settings = {
	    backgroundColor: "#8CD1E6",
	    pathColor: "gray"
	}
	
	// Drawing the background
	backgroundContext.fillStyle = settings.backgroundColor;
	backgroundContext.fillRect(0, 0, background.width, background.height);
	
	/* Main path will go from [0, 500], [75, 500], [75, 100], [225, 100], [225, 500], [375, 500], [375, 100], [525, 100], [525, 500], [675, 500], [675, 100], [825, 100], [825, 500], [900, 500] */
	
	// Drawing the path - width of the path is 50px
	backgroundContext.fillStyle = settings.pathColor;
	
	backgroundContext.beginPath();
	
	// For the bottom part of the path
	backgroundContext.moveTo(0, 525);
	
	backgroundContext.lineTo(100, 525);
	backgroundContext.lineTo(100, 125); // Top
	backgroundContext.lineTo(200, 125);
	backgroundContext.lineTo(200, 525); // Bottom
	backgroundContext.lineTo(400, 525);
	backgroundContext.lineTo(400, 125); // Top
	backgroundContext.lineTo(500, 125);
	backgroundContext.lineTo(500, 525); // Bottom
	backgroundContext.lineTo(700, 525);
	backgroundContext.lineTo(700, 125); // Top
	backgroundContext.lineTo(800, 125);
	backgroundContext.lineTo(800, 525); // Bottom
	
	//Middle section to the side
	backgroundContext.lineTo(900, 525);
	backgroundContext.lineTo(900, 475);
	backgroundContext.lineTo(850, 475);
	
	// For the top part of the path
	backgroundContext.lineTo(850, 75);
	backgroundContext.lineTo(650, 75);
	backgroundContext.lineTo(650, 475);
	backgroundContext.lineTo(550, 475);
	backgroundContext.lineTo(550, 75);
	backgroundContext.lineTo(350, 75);
	backgroundContext.lineTo(350, 475);
	backgroundContext.lineTo(250, 475);
	backgroundContext.lineTo(250, 75);
	backgroundContext.lineTo(50, 75);
	backgroundContext.lineTo(50, 475);
	
	// End section
	backgroundContext.lineTo(0, 475);
	
	backgroundContext.fill();
	// backgroundContext.lineTo();


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	// NOTE At some point I think we can move some functions into a different file
	
	// Initiate all the components
	var Tower = __webpack_require__(4),
	    GameEngine = __webpack_require__(6),
	    monsterData = __webpack_require__(8),
	    towerData = __webpack_require__(5);
	
	// Cache reused DOM elements
	var infoName = document.getElementById("info-name"),
	    infoIcon = document.getElementById("info-icon"),
	    infoBox1 = document.getElementById("info-box-1"),
	    infoBox2 = document.getElementById("info-box-2"),
	    infoBox3 = document.getElementById("info-box-3"),
	    infoBox4 = document.getElementById("info-box-4");
	
	var towerCards = document.getElementsByClassName("tower-card");
	var towerCardList = [];
	
	//  creates global variables
	game = new GameEngine;
	dynamicCanvas = document.getElementById('dynamic');
	dynamicContext = dynamicCanvas.getContext('2d');
	
	// create state variables
	var activeCanvasElement = {type: null}, // initiate default as null
	    activeTowerSelected = null;
	
	runCycle = function() {
	    game.runCycle();
	    setTimeout(runCycle, 1000);
	}
	
	renderCycle = function() {
	    game.render();
	    renderInformationContainer(); // Renders the information container
	    requestAnimationFrame(renderCycle);
	}
	
	// HERE IS ALL THE INTERACTION EVENT LISTENERS
	
	/* ============== On start click handlers ==============*/
	/* =====================================================*/
	
	// On start, create a game element - these event listeners will be destroyed when the container is overriden
	document.getElementById("start-btn").addEventListener("click", function() {
	    // Hides the modal lightbox
	    document.getElementsByClassName("modal-content")[0].style.display = "none";
	    document.getElementsByClassName("modal-background")[0].style.display = "none";
	
	    // run repeating function that runs game engine run cycle and rendering
	    setTimeout(runCycle, 1000);
	    requestAnimationFrame(renderCycle);
	});
	
	// On clicking the information button, show the information panel
	document.getElementById("information-btn").addEventListener("click", function() {
	    console.log("show information container here");
	});
	
	/* ======== Information container interactions =========*/
	/* =====================================================*/
	
	
	
	/* ================= Information Click =================*/
	/* =====================================================*/
	// Shows information about towers or monsters if hovered over
	// or active
	
	// Runs every game cycle
	function renderInformationContainer() {
	    if (activeCanvasElement.type === "monster") {
	        renderMonsterInformation(activeCanvasElement.id, activeCanvasElement.index);
	    } else if (activeCanvasElement.type === "tower") {
	        renderTowerInformation(activeCanvasElement.id, activeCanvasElement.index);
	    } else {
	        renderDefaultInformation();
	    }
	}
	
	function comparePositions(clickPosition, elementPosition, type) {
	    var sideLength = type === "monster" ? 30 : 50; // width and height of the element
	    if (clickPosition.x >= elementPosition.x
	    && clickPosition.x <= elementPosition.x + sideLength
	    && clickPosition.y >= elementPosition.y
	    && clickPosition.y <= elementPosition.y + sideLength) {
	        return true;
	    } else {
	        return false;
	    }
	}
	
	// Takes in a position object (location of the click)
	// returns an object with information about what is at that position
	function checkClickLocation(position) {
	    var element = {};
	    // Loops through activeMonsters
	    for (var i = 0; i < game.activeMonsters.length; i++) {
	        if (comparePositions(position, game.activeMonsters[i].position, "monster")) {
	            element.type = "monster";
	            element.id = game.activeMonsters[i].id;
	            element.index = i;
	            break;
	        }
	    }
	
	    // If nothing was found, loop through towers
	    if (element.type === undefined) {
	        for (var i = 0; i < game.towers.length; i++) {
	            if (comparePositions(position, game.towers[i].position, "tower")) {
	                element.type = "tower";
	                element.id = game.towers[i].id;
	                element.index = i;
	                break;
	            }
	        }
	    }
	
	    // If no towers or monsters found return a type of null
	    if (element.type === undefined) {
	        element.type = null;
	    }
	
	    return element;
	}
	
	// ID refers to the type of monster and index is the index of the active monster in the active monster's array
	function renderMonsterInformation(id, index) {
	    var currentHp = game.activeMonsters[index].currentHp,
	        maxHp = game.activeMonsters[index].maxHp,
	        type = game.activeMonsters[index].type;
	    infoName.innerHTML = id;
	    // Change icon to active monster - use a sprite
	    infoBox1.innerHTML = "HP: " + currentHp + " / " + maxHp;
	    infoBox2.innerHTML = "Type: " + type;
	    infoBox3.innerHTML = "Strengths: All sorts mate" ;
	    infoBox4.innerHTML = "Weaknesses: Ducks" ;
	}
	
	// ID refers to the type of tower and index is the index of the active tower in the active tower's array
	function renderTowerInformation(id, index) {
	    infoName.innerHTML = id;
	    // Change icon to active monster - use a sprite
	    infoBox1.innerHTML = "Damage: <br> Range: <br> Effect: ";
	    infoBox2.innerHTML = "Attack Speed: <br> Type: " ;
	    infoBox3.innerHTML = "Strengths: All sorts mate" ;
	    infoBox4.innerHTML = "Weaknesses: Ducks" ;
	    // Change icon to tower monster - use a sprite
	
	}
	
	function renderDefaultInformation() {
	    infoName.innerHTML = "Awesome TD";
	    // Change icon to default image - use a sprite
	    infoBox1.innerHTML = "This is some text";
	    infoBox2.innerHTML = "This is different text";
	    infoBox3.innerHTML = "This is ??? text" ;
	    infoBox4.innerHTML = "This 1231241235" ;
	}
	
	// Get information from towerdata.js
	
	/* ========== Tower Card Click and placements ==========*/
	/* =====================================================*/
	// Click a tower card and make "active" which can be placed on UI element
	// While it is active - use #dynamic.onmousemove = function -> to Send
	// information to the canvas
	
	// set up event listeners at the start which reference functions - these functions depend on the state on the application to control their control flow
	
	function addClass(element, cssClass) {
	    if (element.className === "") {
	        element.className = cssClass;
	    } else {
	        element.className += " " + cssClass;
	    }
	}
	
	function removeClass(element, cssClass) {
	    var arrayOfClasses = element.className.split(" ");
	    for (var i = 0, j = arrayOfClasses.length; i < j; i++) {
	        if (arrayOfClasses[i] === cssClass) {
	            arrayOfClasses.splice(i, 1);
	            i--; j--;
	        }
	    }
	    element.className = arrayOfClasses.join(" ");
	}
	
	function getIndex(towerName) {
	    return towerCardList.indexOf(towerName);
	}
	
	function towerCardClick() {
	
	    var towerName = this.getAttribute("data-tower");
	
	    if (/disabled/i.test(this.className)) { // Tower is disabled
	        return;
	    } else if (activeTowerSelected === null) { // There is no active tower being placed
	        // set the active tower selected to be the tower name
	        // Set up active elements
	        activeTowerSelected = towerName;
	        addClass(towerCards[getIndex(activeTowerSelected)], "active");
	    } else if (activeTowerSelected === towerName) { // The tower card clicked is the same as the active tower
	        cancelTowerPlacement();
	    } else { // There is an active tower which is not the same as what was clicked
	        removeClass(towerCards[getIndex(activeTowerSelected)], "active");
	        activeTowerSelected = towerName;
	        addClass(towerCards[getIndex(activeTowerSelected)], "active");
	    }
	}
	
	function onTowerMouseMovement(e) {
	    if (activeTowerSelected === null) {
	        return
	    };
	    var canvasContainer = this.getBoundingClientRect();
	    var offsetX = e.clientX - canvasContainer.left,
	        offsetY = e.clientY - canvasContainer.top;
	    // send to display to get rendered
	};
	
	// Two possible canvas click scenarios:
	// 1) Tower selection is active (place a tower)
	// 2) Tower selection is inactive (clicking to get information about a monster or tower on the map)
	function canvasClick(e) {
	    // Get click location relative to the canvas element
	    var canvasContainer = this.getBoundingClientRect(),
	    position = {};
	
	    position.x = e.clientX - canvasContainer.left;
	    position.y = e.clientY - canvasContainer.top;
	
	    if (activeTowerSelected !== null) { //
	        var towerName = activeTowerSelected; // NOTE CHANGE GET TOWER NAME FROM LIST
	
	        if (game.validateTowerPlacement(towerName, position)) {
	            console.log("towerPlaced");
	            game.addTower(towerName, position);
	        } else {
	            console.log("invalid tower placement");
	            // show error message somewhere for the user
	        }
	        removeClass(towerCards[getIndex(activeTowerSelected)], "active");
	        activeTowerSelected = null;
	
	    } else {
	        // check if the position overlaps with the bounding rectangle of monster or tower
	        var element = checkClickLocation(position);
	        activeCanvasElement = element;
	    }
	
	}
	
	function cancelTowerPlacement() {
	
	    removeClass(towerCards[getIndex(activeTowerSelected)], "active");
	    activeTowerSelected = null;
	}
	
	
	// Set up event listeners
	// Convert from nodelist to array
	towerCards = Array.prototype.slice.call(towerCards);
	
	// Tower card click event listeners
	towerCards.map(function(towerCard, i) {
	    towerCardList.push(towerCard.getAttribute("data-tower"));
	    towerCard.addEventListener("click", towerCardClick);
	});
	
	// Game container event listeners
	document.getElementById("dynamic").onmousemove = onTowerMouseMovement;
	document.getElementById("dynamic").addEventListener("click", canvasClick);
	
	// Tower placement cancelling event listeners
	document.onkeydown = function(e) {
	    if (e.keyCode === 27) {
	        cancelTowerPlacement();
	    }
	}


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var towerData = __webpack_require__(5);
	
	var Tower = function(position, id) {
	    this.id = id;
	    this.damage = towerData[id].damage;
	    this.speed = towerData[id].speed; // Attack speed
	    this.range = towerData[id].range; // Range of the tower
	    this.type = towerData[id].type; // Type of damage
	    this.effect = towerData[id].effect; // Special effect (e.g. slow, splash, etc)
	    this.position = position; // object with x and y coordinates - should not change
	}
	// Method the game object uses to run towers
	Tower.prototype.runCycle = function() {
	
	}
	// change this to reference a list or something where a name can be used to determine the properties
	// Takes in a monster's position and checks whether that is in range based on the range - returns true or false if in range which can be used to
	Tower.prototype.checkInRange = function(monsterPosition) {
	    // using sqrt((x2-x1)^2 - (y2-y1)^2)
	    var monsterDistance =
	    Math.sqrt(
	        Math.Pow(monsterPosition.x-this.position.x)
	    -   Math.Pow(monsterPosition.y-this.position.y)
	   );
	
	   if (monsterDistance <= this.range) {
	       return true;
	   } else {
	       return false;
	   }
	}
	
	module.exports = Tower;


/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = {
	    basic: {
	        damage: 10,
	        speed: 10,
	        range: 100,
	        type: "basic",
	        effect: "none"
	    }
	};


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	//  require Monster to gain access
	var Monster = __webpack_require__(7);
	
	var GameEngine = function() {
	    this.userGold = 10;
	    this.level = 1;
	    this.userLives = 30;
	    this.activeMonsters = []; // List of active monsters in the
	    this.towers = []; // object of tower objects
	    this.timer = 1;
	    // Goes through and disables towers that can't be used yet
	}
	
	GameEngine.prototype.addMonster = function(name) {
	    // add monster (specified by name) to game
	    var monster = new Monster("monster1");
	    this.activeMonsters.push(monster);
	}
	
	GameEngine.prototype.addTower = function(name, position) {
	    // add tower (specified by name) at location
	}
	
	// method to check gold before place tower or upgrade
	GameEngine.prototype.checkGold = function(goldCost) {
	    if (goldCost > this.userGold) {
	        return true;
	    } else {
	        return false;
	    }
	};
	
	GameEngine.prototype.gameOver = function() {
	
	}
	
	GameEngine.prototype.gameWon = function() {
	
	}
	
	// New level method
	GameEngine.prototype.nextLevel = function() {
	
	}
	
	GameEngine.prototype.render = function() {
	    // send state to the display object to render
	    dynamicContext.beginPath();
	    dynamicContext.clearRect(0, 0, dynamicCanvas.width, dynamicCanvas.height);
	
	    //  loop through list of active monsters and render them
	    //  TODO probably need to find a better way to rend them apart from random rectangle
	    for (var i = 0, j = this.activeMonsters.length; i < j; i ++) {
	        this.activeMonsters[i].draw();
	    }
	
	    // dynamicContext.
	};
	
	GameEngine.prototype.runCycle = function() {
	    //  beginning of cycle check if any monsters have died if so remove from active monsters
	    this.checkMonsterDeath();
	    // loop through active monsters and towers and run the cycle
	    // Each runCycle method returns information for the gameEngine to
	    // process (e.g. the monster died, tower changed)
	
	    //  timer to add monsters
	    this.timer--;
	    if (this.timer < 1) {
	        this.addMonster('blah');
	        this.timer = 10;
	    }
	    for (var i = 0, j = this.activeMonsters.length; i < j; i ++) {
	        this.activeMonsters[i].move();
	    }
	    // Send information to render
	}
	
	// method to upgrade tower
	
	GameEngine.prototype.validateTowerPlacement = function(name, position) {
	    // returns true or false whether tower placement is valid
	    return true;
	}
	
	GameEngine.prototype.checkMonsterDeath = function() {
	    for (var i = 0, j = this.activeMonsters.length; i < j; i ++) {
	        if (this.activeMonsters[i].checkDeath()) {
	            this.activeMonsters.splice(i, 1);
	            i--;
	            j--;
	        }
	    }
	}
	
	// redraw canvas
	
	module.exports = GameEngine;


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var monsterData = __webpack_require__(8);
	
	var Monster = function(id) {
	    this.id = id;
	    this.currentHp = monsterData[id].maxHp;
	    this.maxHp = monsterData[id].maxHp;
	    this.baseMs = monsterData[id].baseMs; // Movement speed - "units" per second
	    this.type = monsterData[id].type;
	    this.position = { // All monsters are created in the same position
	        x: 0,
	        y: 485
	    }
	};
	// Method the game object uses to move monsters
	Monster.prototype.runCycle = function() {
	
	}
	
	Monster.prototype.draw = function() {
	    dynamicContext.beginPath();
	    dynamicContext.rect(this.position.x, this.position.y, 30, 30);
	    dynamicContext.stroke();
	    dynamicContext.fillStyle = "red";
	    dynamicContext.fillRect(this.position.x,
	                            this.position.y + 30/3,
	                            30 * this.currentHp/this.maxHp,
	                            30/3);
	}
	
	Monster.prototype.destroy = function() {
	
	};
	
	Monster.prototype.checkDeath = function() {
	    return this.currentHp <= 0;
	};
	
	// Expects up, down, left or right
	Monster.prototype.move = function(direction) {
	    var speed = this.baseMs;
	
	    // some basic monster Movement
	    //  NOTE such a hassle to figure this out
	    //  TODO not finished, not even going to try and finish will figure out how this should work later
	    if (this.position.x <= 50 && this.position.y < 500) {
	        this.position.x += speed;
	    } else if (this.position.x >= 50 && this.position.y >= 90) {
	        this.position.y -= speed;
	    } else if (this.position.x <= 180 && this.position.y >= 80) {
	        this.position.x += speed;
	    }
	
	    //  may not be the best way to do this but ill keep it because not even sure how to do this movement part
	    // if (typeof direction !== "string") {
	    //     throw new TypeError("direction is not a string");
	    // }
	    // direction = direction.toLowerCase();
	    // switch (direction) {
	    //     case "up":
	    //     case "down":
	    //     case "left":
	    //     case "right":
	    //     default:
	    //         throw new Error("Invalid direction");
	    // }
	};
	
	// Can take in a positive or negative number
	Monster.prototype.updateHp = function(hpChange) {
	    this.currentHp += hpChange;
	
	    if (this.currentHp > this.maxHp) {
	        this.currentHp = this.maxHp;
	    }
	};
	
	module.exports = Monster;


/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = {
	    monster1: {
	        maxHp: 30,
	        baseMs: 10,
	        type: 1 // Change this type later
	    }
	};


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZDg1NjBiNmJlYzE4NTRiZTgyMmIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2VudHJ5LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9iYWNrZ3JvdW5kLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NsYXNzZXMvVG93ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2dhbWVEYXRhL3Rvd2VyZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY2xhc3Nlcy9HYW1lLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9jbGFzc2VzL01vbnN0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2dhbWVEYXRhL21vbnN0ZXJkYXRhLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0Esb0NBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDM0RBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUEyQixXQUFXO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBaUM7QUFDakM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixnQ0FBZ0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDRDQUEyQztBQUMzQztBQUNBLE1BQUsseUNBQXlDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSyw4Q0FBOEM7QUFDbkQ7QUFDQSxNQUFLLE9BQU87QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF1QztBQUN2Qyw2Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzFSQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBcUM7QUFDckMsc0NBQXFDO0FBQ3JDLG9DQUFtQztBQUNuQyx3Q0FBdUM7QUFDdkMsOEJBQTZCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNSQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFtRCxPQUFPO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvREFBbUQsT0FBTztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7OztBQ2pHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUF5QztBQUN6QztBQUNBLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0EsTUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoibWFpbi5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvc3JjL2pzL1wiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgZDg1NjBiNmJlYzE4NTRiZTgyMmJcbiAqKi8iLCIvLyBDYW52YXNcbnJlcXVpcmUoXCIuL2JhY2tncm91bmQuanNcIik7XG5cbi8vIFVzZXIgaW50ZXJhY3Rpb24gZWxlbWVudHNcbnJlcXVpcmUoXCIuL2ludGVyZmFjZS5qc1wiKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvZW50cnkuanNcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyBiYWNrZ3JvdW5kIGNvbnRhaW5zIHRoZSBzdGF0aWMgY2FudmFzIGVsZW1lbnRzXG52YXIgYmFja2dyb3VuZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RhdGljXCIpO1xudmFyIGJhY2tncm91bmRDb250ZXh0ID0gYmFja2dyb3VuZC5nZXRDb250ZXh0KFwiMmRcIik7XG5cbi8vIFNldHRpbmdzIGZvciB0aGUgYmFja2dyb3VuZCAtIG1vdmUgb3V0IHRvIGEgc2VwYXJhdGUgZmlsZVxudmFyIHNldHRpbmdzID0ge1xuICAgIGJhY2tncm91bmRDb2xvcjogXCIjOENEMUU2XCIsXG4gICAgcGF0aENvbG9yOiBcImdyYXlcIlxufVxuXG4vLyBEcmF3aW5nIHRoZSBiYWNrZ3JvdW5kXG5iYWNrZ3JvdW5kQ29udGV4dC5maWxsU3R5bGUgPSBzZXR0aW5ncy5iYWNrZ3JvdW5kQ29sb3I7XG5iYWNrZ3JvdW5kQ29udGV4dC5maWxsUmVjdCgwLCAwLCBiYWNrZ3JvdW5kLndpZHRoLCBiYWNrZ3JvdW5kLmhlaWdodCk7XG5cbi8qIE1haW4gcGF0aCB3aWxsIGdvIGZyb20gWzAsIDUwMF0sIFs3NSwgNTAwXSwgWzc1LCAxMDBdLCBbMjI1LCAxMDBdLCBbMjI1LCA1MDBdLCBbMzc1LCA1MDBdLCBbMzc1LCAxMDBdLCBbNTI1LCAxMDBdLCBbNTI1LCA1MDBdLCBbNjc1LCA1MDBdLCBbNjc1LCAxMDBdLCBbODI1LCAxMDBdLCBbODI1LCA1MDBdLCBbOTAwLCA1MDBdICovXG5cbi8vIERyYXdpbmcgdGhlIHBhdGggLSB3aWR0aCBvZiB0aGUgcGF0aCBpcyA1MHB4XG5iYWNrZ3JvdW5kQ29udGV4dC5maWxsU3R5bGUgPSBzZXR0aW5ncy5wYXRoQ29sb3I7XG5cbmJhY2tncm91bmRDb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4vLyBGb3IgdGhlIGJvdHRvbSBwYXJ0IG9mIHRoZSBwYXRoXG5iYWNrZ3JvdW5kQ29udGV4dC5tb3ZlVG8oMCwgNTI1KTtcblxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDEwMCwgNTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygxMDAsIDEyNSk7IC8vIFRvcFxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDIwMCwgMTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygyMDAsIDUyNSk7IC8vIEJvdHRvbVxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDQwMCwgNTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg0MDAsIDEyNSk7IC8vIFRvcFxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDUwMCwgMTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg1MDAsIDUyNSk7IC8vIEJvdHRvbVxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDcwMCwgNTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg3MDAsIDEyNSk7IC8vIFRvcFxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDgwMCwgMTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg4MDAsIDUyNSk7IC8vIEJvdHRvbVxuXG4vL01pZGRsZSBzZWN0aW9uIHRvIHRoZSBzaWRlXG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oOTAwLCA1MjUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDkwMCwgNDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg4NTAsIDQ3NSk7XG5cbi8vIEZvciB0aGUgdG9wIHBhcnQgb2YgdGhlIHBhdGhcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg4NTAsIDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg2NTAsIDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg2NTAsIDQ3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNTUwLCA0NzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDU1MCwgNzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDM1MCwgNzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDM1MCwgNDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygyNTAsIDQ3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oMjUwLCA3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNTAsIDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg1MCwgNDc1KTtcblxuLy8gRW5kIHNlY3Rpb25cbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygwLCA0NzUpO1xuXG5iYWNrZ3JvdW5kQ29udGV4dC5maWxsKCk7XG4vLyBiYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oKTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvYmFja2dyb3VuZC5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIE5PVEUgQXQgc29tZSBwb2ludCBJIHRoaW5rIHdlIGNhbiBtb3ZlIHNvbWUgZnVuY3Rpb25zIGludG8gYSBkaWZmZXJlbnQgZmlsZVxuXG4vLyBJbml0aWF0ZSBhbGwgdGhlIGNvbXBvbmVudHNcbnZhciBUb3dlciA9IHJlcXVpcmUoXCIuL2NsYXNzZXMvVG93ZXIuanNcIiksXG4gICAgR2FtZUVuZ2luZSA9IHJlcXVpcmUoXCIuL2NsYXNzZXMvR2FtZS5qc1wiKSxcbiAgICBtb25zdGVyRGF0YSA9IHJlcXVpcmUoXCIuL2dhbWVEYXRhL21vbnN0ZXJkYXRhLmpzXCIpLFxuICAgIHRvd2VyRGF0YSA9IHJlcXVpcmUoXCIuL2dhbWVEYXRhL3Rvd2VyZGF0YS5qc1wiKTtcblxuLy8gQ2FjaGUgcmV1c2VkIERPTSBlbGVtZW50c1xudmFyIGluZm9OYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbmZvLW5hbWVcIiksXG4gICAgaW5mb0ljb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImluZm8taWNvblwiKSxcbiAgICBpbmZvQm94MSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5mby1ib3gtMVwiKSxcbiAgICBpbmZvQm94MiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5mby1ib3gtMlwiKSxcbiAgICBpbmZvQm94MyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5mby1ib3gtM1wiKSxcbiAgICBpbmZvQm94NCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5mby1ib3gtNFwiKTtcblxudmFyIHRvd2VyQ2FyZHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwidG93ZXItY2FyZFwiKTtcbnZhciB0b3dlckNhcmRMaXN0ID0gW107XG5cbi8vICBjcmVhdGVzIGdsb2JhbCB2YXJpYWJsZXNcbmdhbWUgPSBuZXcgR2FtZUVuZ2luZTtcbmR5bmFtaWNDYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZHluYW1pYycpO1xuZHluYW1pY0NvbnRleHQgPSBkeW5hbWljQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbi8vIGNyZWF0ZSBzdGF0ZSB2YXJpYWJsZXNcbnZhciBhY3RpdmVDYW52YXNFbGVtZW50ID0ge3R5cGU6IG51bGx9LCAvLyBpbml0aWF0ZSBkZWZhdWx0IGFzIG51bGxcbiAgICBhY3RpdmVUb3dlclNlbGVjdGVkID0gbnVsbDtcblxucnVuQ3ljbGUgPSBmdW5jdGlvbigpIHtcbiAgICBnYW1lLnJ1bkN5Y2xlKCk7XG4gICAgc2V0VGltZW91dChydW5DeWNsZSwgMTAwMCk7XG59XG5cbnJlbmRlckN5Y2xlID0gZnVuY3Rpb24oKSB7XG4gICAgZ2FtZS5yZW5kZXIoKTtcbiAgICByZW5kZXJJbmZvcm1hdGlvbkNvbnRhaW5lcigpOyAvLyBSZW5kZXJzIHRoZSBpbmZvcm1hdGlvbiBjb250YWluZXJcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyQ3ljbGUpO1xufVxuXG4vLyBIRVJFIElTIEFMTCBUSEUgSU5URVJBQ1RJT04gRVZFTlQgTElTVEVORVJTXG5cbi8qID09PT09PT09PT09PT09IE9uIHN0YXJ0IGNsaWNrIGhhbmRsZXJzID09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuLy8gT24gc3RhcnQsIGNyZWF0ZSBhIGdhbWUgZWxlbWVudCAtIHRoZXNlIGV2ZW50IGxpc3RlbmVycyB3aWxsIGJlIGRlc3Ryb3llZCB3aGVuIHRoZSBjb250YWluZXIgaXMgb3ZlcnJpZGVuXG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN0YXJ0LWJ0blwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgLy8gSGlkZXMgdGhlIG1vZGFsIGxpZ2h0Ym94XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIm1vZGFsLWNvbnRlbnRcIilbMF0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJtb2RhbC1iYWNrZ3JvdW5kXCIpWzBdLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblxuICAgIC8vIHJ1biByZXBlYXRpbmcgZnVuY3Rpb24gdGhhdCBydW5zIGdhbWUgZW5naW5lIHJ1biBjeWNsZSBhbmQgcmVuZGVyaW5nXG4gICAgc2V0VGltZW91dChydW5DeWNsZSwgMTAwMCk7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlckN5Y2xlKTtcbn0pO1xuXG4vLyBPbiBjbGlja2luZyB0aGUgaW5mb3JtYXRpb24gYnV0dG9uLCBzaG93IHRoZSBpbmZvcm1hdGlvbiBwYW5lbFxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbmZvcm1hdGlvbi1idG5cIikuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgIGNvbnNvbGUubG9nKFwic2hvdyBpbmZvcm1hdGlvbiBjb250YWluZXIgaGVyZVwiKTtcbn0pO1xuXG4vKiA9PT09PT09PSBJbmZvcm1hdGlvbiBjb250YWluZXIgaW50ZXJhY3Rpb25zID09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuXG4vKiA9PT09PT09PT09PT09PT09PSBJbmZvcm1hdGlvbiBDbGljayA9PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vLyBTaG93cyBpbmZvcm1hdGlvbiBhYm91dCB0b3dlcnMgb3IgbW9uc3RlcnMgaWYgaG92ZXJlZCBvdmVyXG4vLyBvciBhY3RpdmVcblxuLy8gUnVucyBldmVyeSBnYW1lIGN5Y2xlXG5mdW5jdGlvbiByZW5kZXJJbmZvcm1hdGlvbkNvbnRhaW5lcigpIHtcbiAgICBpZiAoYWN0aXZlQ2FudmFzRWxlbWVudC50eXBlID09PSBcIm1vbnN0ZXJcIikge1xuICAgICAgICByZW5kZXJNb25zdGVySW5mb3JtYXRpb24oYWN0aXZlQ2FudmFzRWxlbWVudC5pZCwgYWN0aXZlQ2FudmFzRWxlbWVudC5pbmRleCk7XG4gICAgfSBlbHNlIGlmIChhY3RpdmVDYW52YXNFbGVtZW50LnR5cGUgPT09IFwidG93ZXJcIikge1xuICAgICAgICByZW5kZXJUb3dlckluZm9ybWF0aW9uKGFjdGl2ZUNhbnZhc0VsZW1lbnQuaWQsIGFjdGl2ZUNhbnZhc0VsZW1lbnQuaW5kZXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbmRlckRlZmF1bHRJbmZvcm1hdGlvbigpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY29tcGFyZVBvc2l0aW9ucyhjbGlja1Bvc2l0aW9uLCBlbGVtZW50UG9zaXRpb24sIHR5cGUpIHtcbiAgICB2YXIgc2lkZUxlbmd0aCA9IHR5cGUgPT09IFwibW9uc3RlclwiID8gMzAgOiA1MDsgLy8gd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgZWxlbWVudFxuICAgIGlmIChjbGlja1Bvc2l0aW9uLnggPj0gZWxlbWVudFBvc2l0aW9uLnhcbiAgICAmJiBjbGlja1Bvc2l0aW9uLnggPD0gZWxlbWVudFBvc2l0aW9uLnggKyBzaWRlTGVuZ3RoXG4gICAgJiYgY2xpY2tQb3NpdGlvbi55ID49IGVsZW1lbnRQb3NpdGlvbi55XG4gICAgJiYgY2xpY2tQb3NpdGlvbi55IDw9IGVsZW1lbnRQb3NpdGlvbi55ICsgc2lkZUxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vLyBUYWtlcyBpbiBhIHBvc2l0aW9uIG9iamVjdCAobG9jYXRpb24gb2YgdGhlIGNsaWNrKVxuLy8gcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGlzIGF0IHRoYXQgcG9zaXRpb25cbmZ1bmN0aW9uIGNoZWNrQ2xpY2tMb2NhdGlvbihwb3NpdGlvbikge1xuICAgIHZhciBlbGVtZW50ID0ge307XG4gICAgLy8gTG9vcHMgdGhyb3VnaCBhY3RpdmVNb25zdGVyc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2FtZS5hY3RpdmVNb25zdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoY29tcGFyZVBvc2l0aW9ucyhwb3NpdGlvbiwgZ2FtZS5hY3RpdmVNb25zdGVyc1tpXS5wb3NpdGlvbiwgXCJtb25zdGVyXCIpKSB7XG4gICAgICAgICAgICBlbGVtZW50LnR5cGUgPSBcIm1vbnN0ZXJcIjtcbiAgICAgICAgICAgIGVsZW1lbnQuaWQgPSBnYW1lLmFjdGl2ZU1vbnN0ZXJzW2ldLmlkO1xuICAgICAgICAgICAgZWxlbWVudC5pbmRleCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kLCBsb29wIHRocm91Z2ggdG93ZXJzXG4gICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2FtZS50b3dlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjb21wYXJlUG9zaXRpb25zKHBvc2l0aW9uLCBnYW1lLnRvd2Vyc1tpXS5wb3NpdGlvbiwgXCJ0b3dlclwiKSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQudHlwZSA9IFwidG93ZXJcIjtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmlkID0gZ2FtZS50b3dlcnNbaV0uaWQ7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBubyB0b3dlcnMgb3IgbW9uc3RlcnMgZm91bmQgcmV0dXJuIGEgdHlwZSBvZiBudWxsXG4gICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVsZW1lbnQudHlwZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbi8vIElEIHJlZmVycyB0byB0aGUgdHlwZSBvZiBtb25zdGVyIGFuZCBpbmRleCBpcyB0aGUgaW5kZXggb2YgdGhlIGFjdGl2ZSBtb25zdGVyIGluIHRoZSBhY3RpdmUgbW9uc3RlcidzIGFycmF5XG5mdW5jdGlvbiByZW5kZXJNb25zdGVySW5mb3JtYXRpb24oaWQsIGluZGV4KSB7XG4gICAgdmFyIGN1cnJlbnRIcCA9IGdhbWUuYWN0aXZlTW9uc3RlcnNbaW5kZXhdLmN1cnJlbnRIcCxcbiAgICAgICAgbWF4SHAgPSBnYW1lLmFjdGl2ZU1vbnN0ZXJzW2luZGV4XS5tYXhIcCxcbiAgICAgICAgdHlwZSA9IGdhbWUuYWN0aXZlTW9uc3RlcnNbaW5kZXhdLnR5cGU7XG4gICAgaW5mb05hbWUuaW5uZXJIVE1MID0gaWQ7XG4gICAgLy8gQ2hhbmdlIGljb24gdG8gYWN0aXZlIG1vbnN0ZXIgLSB1c2UgYSBzcHJpdGVcbiAgICBpbmZvQm94MS5pbm5lckhUTUwgPSBcIkhQOiBcIiArIGN1cnJlbnRIcCArIFwiIC8gXCIgKyBtYXhIcDtcbiAgICBpbmZvQm94Mi5pbm5lckhUTUwgPSBcIlR5cGU6IFwiICsgdHlwZTtcbiAgICBpbmZvQm94My5pbm5lckhUTUwgPSBcIlN0cmVuZ3RoczogQWxsIHNvcnRzIG1hdGVcIiA7XG4gICAgaW5mb0JveDQuaW5uZXJIVE1MID0gXCJXZWFrbmVzc2VzOiBEdWNrc1wiIDtcbn1cblxuLy8gSUQgcmVmZXJzIHRvIHRoZSB0eXBlIG9mIHRvd2VyIGFuZCBpbmRleCBpcyB0aGUgaW5kZXggb2YgdGhlIGFjdGl2ZSB0b3dlciBpbiB0aGUgYWN0aXZlIHRvd2VyJ3MgYXJyYXlcbmZ1bmN0aW9uIHJlbmRlclRvd2VySW5mb3JtYXRpb24oaWQsIGluZGV4KSB7XG4gICAgaW5mb05hbWUuaW5uZXJIVE1MID0gaWQ7XG4gICAgLy8gQ2hhbmdlIGljb24gdG8gYWN0aXZlIG1vbnN0ZXIgLSB1c2UgYSBzcHJpdGVcbiAgICBpbmZvQm94MS5pbm5lckhUTUwgPSBcIkRhbWFnZTogPGJyPiBSYW5nZTogPGJyPiBFZmZlY3Q6IFwiO1xuICAgIGluZm9Cb3gyLmlubmVySFRNTCA9IFwiQXR0YWNrIFNwZWVkOiA8YnI+IFR5cGU6IFwiIDtcbiAgICBpbmZvQm94My5pbm5lckhUTUwgPSBcIlN0cmVuZ3RoczogQWxsIHNvcnRzIG1hdGVcIiA7XG4gICAgaW5mb0JveDQuaW5uZXJIVE1MID0gXCJXZWFrbmVzc2VzOiBEdWNrc1wiIDtcbiAgICAvLyBDaGFuZ2UgaWNvbiB0byB0b3dlciBtb25zdGVyIC0gdXNlIGEgc3ByaXRlXG5cbn1cblxuZnVuY3Rpb24gcmVuZGVyRGVmYXVsdEluZm9ybWF0aW9uKCkge1xuICAgIGluZm9OYW1lLmlubmVySFRNTCA9IFwiQXdlc29tZSBURFwiO1xuICAgIC8vIENoYW5nZSBpY29uIHRvIGRlZmF1bHQgaW1hZ2UgLSB1c2UgYSBzcHJpdGVcbiAgICBpbmZvQm94MS5pbm5lckhUTUwgPSBcIlRoaXMgaXMgc29tZSB0ZXh0XCI7XG4gICAgaW5mb0JveDIuaW5uZXJIVE1MID0gXCJUaGlzIGlzIGRpZmZlcmVudCB0ZXh0XCI7XG4gICAgaW5mb0JveDMuaW5uZXJIVE1MID0gXCJUaGlzIGlzID8/PyB0ZXh0XCIgO1xuICAgIGluZm9Cb3g0LmlubmVySFRNTCA9IFwiVGhpcyAxMjMxMjQxMjM1XCIgO1xufVxuXG4vLyBHZXQgaW5mb3JtYXRpb24gZnJvbSB0b3dlcmRhdGEuanNcblxuLyogPT09PT09PT09PSBUb3dlciBDYXJkIENsaWNrIGFuZCBwbGFjZW1lbnRzID09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLy8gQ2xpY2sgYSB0b3dlciBjYXJkIGFuZCBtYWtlIFwiYWN0aXZlXCIgd2hpY2ggY2FuIGJlIHBsYWNlZCBvbiBVSSBlbGVtZW50XG4vLyBXaGlsZSBpdCBpcyBhY3RpdmUgLSB1c2UgI2R5bmFtaWMub25tb3VzZW1vdmUgPSBmdW5jdGlvbiAtPiB0byBTZW5kXG4vLyBpbmZvcm1hdGlvbiB0byB0aGUgY2FudmFzXG5cbi8vIHNldCB1cCBldmVudCBsaXN0ZW5lcnMgYXQgdGhlIHN0YXJ0IHdoaWNoIHJlZmVyZW5jZSBmdW5jdGlvbnMgLSB0aGVzZSBmdW5jdGlvbnMgZGVwZW5kIG9uIHRoZSBzdGF0ZSBvbiB0aGUgYXBwbGljYXRpb24gdG8gY29udHJvbCB0aGVpciBjb250cm9sIGZsb3dcblxuZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgY3NzQ2xhc3MpIHtcbiAgICBpZiAoZWxlbWVudC5jbGFzc05hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBjc3NDbGFzcztcbiAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSArPSBcIiBcIiArIGNzc0NsYXNzO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY3NzQ2xhc3MpIHtcbiAgICB2YXIgYXJyYXlPZkNsYXNzZXMgPSBlbGVtZW50LmNsYXNzTmFtZS5zcGxpdChcIiBcIik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBhcnJheU9mQ2xhc3Nlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgaWYgKGFycmF5T2ZDbGFzc2VzW2ldID09PSBjc3NDbGFzcykge1xuICAgICAgICAgICAgYXJyYXlPZkNsYXNzZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgaS0tOyBqLS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBhcnJheU9mQ2xhc3Nlcy5qb2luKFwiIFwiKTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5kZXgodG93ZXJOYW1lKSB7XG4gICAgcmV0dXJuIHRvd2VyQ2FyZExpc3QuaW5kZXhPZih0b3dlck5hbWUpO1xufVxuXG5mdW5jdGlvbiB0b3dlckNhcmRDbGljaygpIHtcblxuICAgIHZhciB0b3dlck5hbWUgPSB0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtdG93ZXJcIik7XG5cbiAgICBpZiAoL2Rpc2FibGVkL2kudGVzdCh0aGlzLmNsYXNzTmFtZSkpIHsgLy8gVG93ZXIgaXMgZGlzYWJsZWRcbiAgICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoYWN0aXZlVG93ZXJTZWxlY3RlZCA9PT0gbnVsbCkgeyAvLyBUaGVyZSBpcyBubyBhY3RpdmUgdG93ZXIgYmVpbmcgcGxhY2VkXG4gICAgICAgIC8vIHNldCB0aGUgYWN0aXZlIHRvd2VyIHNlbGVjdGVkIHRvIGJlIHRoZSB0b3dlciBuYW1lXG4gICAgICAgIC8vIFNldCB1cCBhY3RpdmUgZWxlbWVudHNcbiAgICAgICAgYWN0aXZlVG93ZXJTZWxlY3RlZCA9IHRvd2VyTmFtZTtcbiAgICAgICAgYWRkQ2xhc3ModG93ZXJDYXJkc1tnZXRJbmRleChhY3RpdmVUb3dlclNlbGVjdGVkKV0sIFwiYWN0aXZlXCIpO1xuICAgIH0gZWxzZSBpZiAoYWN0aXZlVG93ZXJTZWxlY3RlZCA9PT0gdG93ZXJOYW1lKSB7IC8vIFRoZSB0b3dlciBjYXJkIGNsaWNrZWQgaXMgdGhlIHNhbWUgYXMgdGhlIGFjdGl2ZSB0b3dlclxuICAgICAgICBjYW5jZWxUb3dlclBsYWNlbWVudCgpO1xuICAgIH0gZWxzZSB7IC8vIFRoZXJlIGlzIGFuIGFjdGl2ZSB0b3dlciB3aGljaCBpcyBub3QgdGhlIHNhbWUgYXMgd2hhdCB3YXMgY2xpY2tlZFxuICAgICAgICByZW1vdmVDbGFzcyh0b3dlckNhcmRzW2dldEluZGV4KGFjdGl2ZVRvd2VyU2VsZWN0ZWQpXSwgXCJhY3RpdmVcIik7XG4gICAgICAgIGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPSB0b3dlck5hbWU7XG4gICAgICAgIGFkZENsYXNzKHRvd2VyQ2FyZHNbZ2V0SW5kZXgoYWN0aXZlVG93ZXJTZWxlY3RlZCldLCBcImFjdGl2ZVwiKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG9uVG93ZXJNb3VzZU1vdmVtZW50KGUpIHtcbiAgICBpZiAoYWN0aXZlVG93ZXJTZWxlY3RlZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm5cbiAgICB9O1xuICAgIHZhciBjYW52YXNDb250YWluZXIgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBvZmZzZXRYID0gZS5jbGllbnRYIC0gY2FudmFzQ29udGFpbmVyLmxlZnQsXG4gICAgICAgIG9mZnNldFkgPSBlLmNsaWVudFkgLSBjYW52YXNDb250YWluZXIudG9wO1xuICAgIC8vIHNlbmQgdG8gZGlzcGxheSB0byBnZXQgcmVuZGVyZWRcbn07XG5cbi8vIFR3byBwb3NzaWJsZSBjYW52YXMgY2xpY2sgc2NlbmFyaW9zOlxuLy8gMSkgVG93ZXIgc2VsZWN0aW9uIGlzIGFjdGl2ZSAocGxhY2UgYSB0b3dlcilcbi8vIDIpIFRvd2VyIHNlbGVjdGlvbiBpcyBpbmFjdGl2ZSAoY2xpY2tpbmcgdG8gZ2V0IGluZm9ybWF0aW9uIGFib3V0IGEgbW9uc3RlciBvciB0b3dlciBvbiB0aGUgbWFwKVxuZnVuY3Rpb24gY2FudmFzQ2xpY2soZSkge1xuICAgIC8vIEdldCBjbGljayBsb2NhdGlvbiByZWxhdGl2ZSB0byB0aGUgY2FudmFzIGVsZW1lbnRcbiAgICB2YXIgY2FudmFzQ29udGFpbmVyID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICBwb3NpdGlvbiA9IHt9O1xuXG4gICAgcG9zaXRpb24ueCA9IGUuY2xpZW50WCAtIGNhbnZhc0NvbnRhaW5lci5sZWZ0O1xuICAgIHBvc2l0aW9uLnkgPSBlLmNsaWVudFkgLSBjYW52YXNDb250YWluZXIudG9wO1xuXG4gICAgaWYgKGFjdGl2ZVRvd2VyU2VsZWN0ZWQgIT09IG51bGwpIHsgLy9cbiAgICAgICAgdmFyIHRvd2VyTmFtZSA9IGFjdGl2ZVRvd2VyU2VsZWN0ZWQ7IC8vIE5PVEUgQ0hBTkdFIEdFVCBUT1dFUiBOQU1FIEZST00gTElTVFxuXG4gICAgICAgIGlmIChnYW1lLnZhbGlkYXRlVG93ZXJQbGFjZW1lbnQodG93ZXJOYW1lLCBwb3NpdGlvbikpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidG93ZXJQbGFjZWRcIik7XG4gICAgICAgICAgICBnYW1lLmFkZFRvd2VyKHRvd2VyTmFtZSwgcG9zaXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJpbnZhbGlkIHRvd2VyIHBsYWNlbWVudFwiKTtcbiAgICAgICAgICAgIC8vIHNob3cgZXJyb3IgbWVzc2FnZSBzb21ld2hlcmUgZm9yIHRoZSB1c2VyXG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlQ2xhc3ModG93ZXJDYXJkc1tnZXRJbmRleChhY3RpdmVUb3dlclNlbGVjdGVkKV0sIFwiYWN0aXZlXCIpO1xuICAgICAgICBhY3RpdmVUb3dlclNlbGVjdGVkID0gbnVsbDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBwb3NpdGlvbiBvdmVybGFwcyB3aXRoIHRoZSBib3VuZGluZyByZWN0YW5nbGUgb2YgbW9uc3RlciBvciB0b3dlclxuICAgICAgICB2YXIgZWxlbWVudCA9IGNoZWNrQ2xpY2tMb2NhdGlvbihwb3NpdGlvbik7XG4gICAgICAgIGFjdGl2ZUNhbnZhc0VsZW1lbnQgPSBlbGVtZW50O1xuICAgIH1cblxufVxuXG5mdW5jdGlvbiBjYW5jZWxUb3dlclBsYWNlbWVudCgpIHtcblxuICAgIHJlbW92ZUNsYXNzKHRvd2VyQ2FyZHNbZ2V0SW5kZXgoYWN0aXZlVG93ZXJTZWxlY3RlZCldLCBcImFjdGl2ZVwiKTtcbiAgICBhY3RpdmVUb3dlclNlbGVjdGVkID0gbnVsbDtcbn1cblxuXG4vLyBTZXQgdXAgZXZlbnQgbGlzdGVuZXJzXG4vLyBDb252ZXJ0IGZyb20gbm9kZWxpc3QgdG8gYXJyYXlcbnRvd2VyQ2FyZHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0b3dlckNhcmRzKTtcblxuLy8gVG93ZXIgY2FyZCBjbGljayBldmVudCBsaXN0ZW5lcnNcbnRvd2VyQ2FyZHMubWFwKGZ1bmN0aW9uKHRvd2VyQ2FyZCwgaSkge1xuICAgIHRvd2VyQ2FyZExpc3QucHVzaCh0b3dlckNhcmQuZ2V0QXR0cmlidXRlKFwiZGF0YS10b3dlclwiKSk7XG4gICAgdG93ZXJDYXJkLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0b3dlckNhcmRDbGljayk7XG59KTtcblxuLy8gR2FtZSBjb250YWluZXIgZXZlbnQgbGlzdGVuZXJzXG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImR5bmFtaWNcIikub25tb3VzZW1vdmUgPSBvblRvd2VyTW91c2VNb3ZlbWVudDtcbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZHluYW1pY1wiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgY2FudmFzQ2xpY2spO1xuXG4vLyBUb3dlciBwbGFjZW1lbnQgY2FuY2VsbGluZyBldmVudCBsaXN0ZW5lcnNcbmRvY3VtZW50Lm9ua2V5ZG93biA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoZS5rZXlDb2RlID09PSAyNykge1xuICAgICAgICBjYW5jZWxUb3dlclBsYWNlbWVudCgpO1xuICAgIH1cbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvaW50ZXJmYWNlLmpzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvd2VyRGF0YSA9IHJlcXVpcmUoXCIuLi9nYW1lRGF0YS90b3dlcmRhdGEuanNcIik7XG5cbnZhciBUb3dlciA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBpZCkge1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmRhbWFnZSA9IHRvd2VyRGF0YVtpZF0uZGFtYWdlO1xuICAgIHRoaXMuc3BlZWQgPSB0b3dlckRhdGFbaWRdLnNwZWVkOyAvLyBBdHRhY2sgc3BlZWRcbiAgICB0aGlzLnJhbmdlID0gdG93ZXJEYXRhW2lkXS5yYW5nZTsgLy8gUmFuZ2Ugb2YgdGhlIHRvd2VyXG4gICAgdGhpcy50eXBlID0gdG93ZXJEYXRhW2lkXS50eXBlOyAvLyBUeXBlIG9mIGRhbWFnZVxuICAgIHRoaXMuZWZmZWN0ID0gdG93ZXJEYXRhW2lkXS5lZmZlY3Q7IC8vIFNwZWNpYWwgZWZmZWN0IChlLmcuIHNsb3csIHNwbGFzaCwgZXRjKVxuICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjsgLy8gb2JqZWN0IHdpdGggeCBhbmQgeSBjb29yZGluYXRlcyAtIHNob3VsZCBub3QgY2hhbmdlXG59XG4vLyBNZXRob2QgdGhlIGdhbWUgb2JqZWN0IHVzZXMgdG8gcnVuIHRvd2Vyc1xuVG93ZXIucHJvdG90eXBlLnJ1bkN5Y2xlID0gZnVuY3Rpb24oKSB7XG5cbn1cbi8vIGNoYW5nZSB0aGlzIHRvIHJlZmVyZW5jZSBhIGxpc3Qgb3Igc29tZXRoaW5nIHdoZXJlIGEgbmFtZSBjYW4gYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHByb3BlcnRpZXNcbi8vIFRha2VzIGluIGEgbW9uc3RlcidzIHBvc2l0aW9uIGFuZCBjaGVja3Mgd2hldGhlciB0aGF0IGlzIGluIHJhbmdlIGJhc2VkIG9uIHRoZSByYW5nZSAtIHJldHVybnMgdHJ1ZSBvciBmYWxzZSBpZiBpbiByYW5nZSB3aGljaCBjYW4gYmUgdXNlZCB0b1xuVG93ZXIucHJvdG90eXBlLmNoZWNrSW5SYW5nZSA9IGZ1bmN0aW9uKG1vbnN0ZXJQb3NpdGlvbikge1xuICAgIC8vIHVzaW5nIHNxcnQoKHgyLXgxKV4yIC0gKHkyLXkxKV4yKVxuICAgIHZhciBtb25zdGVyRGlzdGFuY2UgPVxuICAgIE1hdGguc3FydChcbiAgICAgICAgTWF0aC5Qb3cobW9uc3RlclBvc2l0aW9uLngtdGhpcy5wb3NpdGlvbi54KVxuICAgIC0gICBNYXRoLlBvdyhtb25zdGVyUG9zaXRpb24ueS10aGlzLnBvc2l0aW9uLnkpXG4gICApO1xuXG4gICBpZiAobW9uc3RlckRpc3RhbmNlIDw9IHRoaXMucmFuZ2UpIHtcbiAgICAgICByZXR1cm4gdHJ1ZTtcbiAgIH0gZWxzZSB7XG4gICAgICAgcmV0dXJuIGZhbHNlO1xuICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRvd2VyO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9qcy9jbGFzc2VzL1Rvd2VyLmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYmFzaWM6IHtcbiAgICAgICAgZGFtYWdlOiAxMCxcbiAgICAgICAgc3BlZWQ6IDEwLFxuICAgICAgICByYW5nZTogMTAwLFxuICAgICAgICB0eXBlOiBcImJhc2ljXCIsXG4gICAgICAgIGVmZmVjdDogXCJub25lXCJcbiAgICB9XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9qcy9nYW1lRGF0YS90b3dlcmRhdGEuanNcbiAqKiBtb2R1bGUgaWQgPSA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvLyAgcmVxdWlyZSBNb25zdGVyIHRvIGdhaW4gYWNjZXNzXG52YXIgTW9uc3RlciA9IHJlcXVpcmUoXCIuL01vbnN0ZXIuanNcIik7XG5cbnZhciBHYW1lRW5naW5lID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy51c2VyR29sZCA9IDEwO1xuICAgIHRoaXMubGV2ZWwgPSAxO1xuICAgIHRoaXMudXNlckxpdmVzID0gMzA7XG4gICAgdGhpcy5hY3RpdmVNb25zdGVycyA9IFtdOyAvLyBMaXN0IG9mIGFjdGl2ZSBtb25zdGVycyBpbiB0aGVcbiAgICB0aGlzLnRvd2VycyA9IFtdOyAvLyBvYmplY3Qgb2YgdG93ZXIgb2JqZWN0c1xuICAgIHRoaXMudGltZXIgPSAxO1xuICAgIC8vIEdvZXMgdGhyb3VnaCBhbmQgZGlzYWJsZXMgdG93ZXJzIHRoYXQgY2FuJ3QgYmUgdXNlZCB5ZXRcbn1cblxuR2FtZUVuZ2luZS5wcm90b3R5cGUuYWRkTW9uc3RlciA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAvLyBhZGQgbW9uc3RlciAoc3BlY2lmaWVkIGJ5IG5hbWUpIHRvIGdhbWVcbiAgICB2YXIgbW9uc3RlciA9IG5ldyBNb25zdGVyKFwibW9uc3RlcjFcIik7XG4gICAgdGhpcy5hY3RpdmVNb25zdGVycy5wdXNoKG1vbnN0ZXIpO1xufVxuXG5HYW1lRW5naW5lLnByb3RvdHlwZS5hZGRUb3dlciA9IGZ1bmN0aW9uKG5hbWUsIHBvc2l0aW9uKSB7XG4gICAgLy8gYWRkIHRvd2VyIChzcGVjaWZpZWQgYnkgbmFtZSkgYXQgbG9jYXRpb25cbn1cblxuLy8gbWV0aG9kIHRvIGNoZWNrIGdvbGQgYmVmb3JlIHBsYWNlIHRvd2VyIG9yIHVwZ3JhZGVcbkdhbWVFbmdpbmUucHJvdG90eXBlLmNoZWNrR29sZCA9IGZ1bmN0aW9uKGdvbGRDb3N0KSB7XG4gICAgaWYgKGdvbGRDb3N0ID4gdGhpcy51c2VyR29sZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuR2FtZUVuZ2luZS5wcm90b3R5cGUuZ2FtZU92ZXIgPSBmdW5jdGlvbigpIHtcblxufVxuXG5HYW1lRW5naW5lLnByb3RvdHlwZS5nYW1lV29uID0gZnVuY3Rpb24oKSB7XG5cbn1cblxuLy8gTmV3IGxldmVsIG1ldGhvZFxuR2FtZUVuZ2luZS5wcm90b3R5cGUubmV4dExldmVsID0gZnVuY3Rpb24oKSB7XG5cbn1cblxuR2FtZUVuZ2luZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gc2VuZCBzdGF0ZSB0byB0aGUgZGlzcGxheSBvYmplY3QgdG8gcmVuZGVyXG4gICAgZHluYW1pY0NvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgZHluYW1pY0NvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGR5bmFtaWNDYW52YXMud2lkdGgsIGR5bmFtaWNDYW52YXMuaGVpZ2h0KTtcblxuICAgIC8vICBsb29wIHRocm91Z2ggbGlzdCBvZiBhY3RpdmUgbW9uc3RlcnMgYW5kIHJlbmRlciB0aGVtXG4gICAgLy8gIFRPRE8gcHJvYmFibHkgbmVlZCB0byBmaW5kIGEgYmV0dGVyIHdheSB0byByZW5kIHRoZW0gYXBhcnQgZnJvbSByYW5kb20gcmVjdGFuZ2xlXG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSB0aGlzLmFjdGl2ZU1vbnN0ZXJzLmxlbmd0aDsgaSA8IGo7IGkgKyspIHtcbiAgICAgICAgdGhpcy5hY3RpdmVNb25zdGVyc1tpXS5kcmF3KCk7XG4gICAgfVxuXG4gICAgLy8gZHluYW1pY0NvbnRleHQuXG59O1xuXG5HYW1lRW5naW5lLnByb3RvdHlwZS5ydW5DeWNsZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vICBiZWdpbm5pbmcgb2YgY3ljbGUgY2hlY2sgaWYgYW55IG1vbnN0ZXJzIGhhdmUgZGllZCBpZiBzbyByZW1vdmUgZnJvbSBhY3RpdmUgbW9uc3RlcnNcbiAgICB0aGlzLmNoZWNrTW9uc3RlckRlYXRoKCk7XG4gICAgLy8gbG9vcCB0aHJvdWdoIGFjdGl2ZSBtb25zdGVycyBhbmQgdG93ZXJzIGFuZCBydW4gdGhlIGN5Y2xlXG4gICAgLy8gRWFjaCBydW5DeWNsZSBtZXRob2QgcmV0dXJucyBpbmZvcm1hdGlvbiBmb3IgdGhlIGdhbWVFbmdpbmUgdG9cbiAgICAvLyBwcm9jZXNzIChlLmcuIHRoZSBtb25zdGVyIGRpZWQsIHRvd2VyIGNoYW5nZWQpXG5cbiAgICAvLyAgdGltZXIgdG8gYWRkIG1vbnN0ZXJzXG4gICAgdGhpcy50aW1lci0tO1xuICAgIGlmICh0aGlzLnRpbWVyIDwgMSkge1xuICAgICAgICB0aGlzLmFkZE1vbnN0ZXIoJ2JsYWgnKTtcbiAgICAgICAgdGhpcy50aW1lciA9IDEwO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuYWN0aXZlTW9uc3RlcnMubGVuZ3RoOyBpIDwgajsgaSArKykge1xuICAgICAgICB0aGlzLmFjdGl2ZU1vbnN0ZXJzW2ldLm1vdmUoKTtcbiAgICB9XG4gICAgLy8gU2VuZCBpbmZvcm1hdGlvbiB0byByZW5kZXJcbn1cblxuLy8gbWV0aG9kIHRvIHVwZ3JhZGUgdG93ZXJcblxuR2FtZUVuZ2luZS5wcm90b3R5cGUudmFsaWRhdGVUb3dlclBsYWNlbWVudCA9IGZ1bmN0aW9uKG5hbWUsIHBvc2l0aW9uKSB7XG4gICAgLy8gcmV0dXJucyB0cnVlIG9yIGZhbHNlIHdoZXRoZXIgdG93ZXIgcGxhY2VtZW50IGlzIHZhbGlkXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbkdhbWVFbmdpbmUucHJvdG90eXBlLmNoZWNrTW9uc3RlckRlYXRoID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSB0aGlzLmFjdGl2ZU1vbnN0ZXJzLmxlbmd0aDsgaSA8IGo7IGkgKyspIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlTW9uc3RlcnNbaV0uY2hlY2tEZWF0aCgpKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZU1vbnN0ZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gcmVkcmF3IGNhbnZhc1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdhbWVFbmdpbmU7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2pzL2NsYXNzZXMvR2FtZS5qc1xuICoqIG1vZHVsZSBpZCA9IDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBtb25zdGVyRGF0YSA9IHJlcXVpcmUoXCIuLi9nYW1lRGF0YS9tb25zdGVyZGF0YS5qc1wiKTtcblxudmFyIE1vbnN0ZXIgPSBmdW5jdGlvbihpZCkge1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmN1cnJlbnRIcCA9IG1vbnN0ZXJEYXRhW2lkXS5tYXhIcDtcbiAgICB0aGlzLm1heEhwID0gbW9uc3RlckRhdGFbaWRdLm1heEhwO1xuICAgIHRoaXMuYmFzZU1zID0gbW9uc3RlckRhdGFbaWRdLmJhc2VNczsgLy8gTW92ZW1lbnQgc3BlZWQgLSBcInVuaXRzXCIgcGVyIHNlY29uZFxuICAgIHRoaXMudHlwZSA9IG1vbnN0ZXJEYXRhW2lkXS50eXBlO1xuICAgIHRoaXMucG9zaXRpb24gPSB7IC8vIEFsbCBtb25zdGVycyBhcmUgY3JlYXRlZCBpbiB0aGUgc2FtZSBwb3NpdGlvblxuICAgICAgICB4OiAwLFxuICAgICAgICB5OiA0ODVcbiAgICB9XG59O1xuLy8gTWV0aG9kIHRoZSBnYW1lIG9iamVjdCB1c2VzIHRvIG1vdmUgbW9uc3RlcnNcbk1vbnN0ZXIucHJvdG90eXBlLnJ1bkN5Y2xlID0gZnVuY3Rpb24oKSB7XG5cbn1cblxuTW9uc3Rlci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKCkge1xuICAgIGR5bmFtaWNDb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGR5bmFtaWNDb250ZXh0LnJlY3QodGhpcy5wb3NpdGlvbi54LCB0aGlzLnBvc2l0aW9uLnksIDMwLCAzMCk7XG4gICAgZHluYW1pY0NvbnRleHQuc3Ryb2tlKCk7XG4gICAgZHluYW1pY0NvbnRleHQuZmlsbFN0eWxlID0gXCJyZWRcIjtcbiAgICBkeW5hbWljQ29udGV4dC5maWxsUmVjdCh0aGlzLnBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi55ICsgMzAvMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzMCAqIHRoaXMuY3VycmVudEhwL3RoaXMubWF4SHAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMzAvMyk7XG59XG5cbk1vbnN0ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblxufTtcblxuTW9uc3Rlci5wcm90b3R5cGUuY2hlY2tEZWF0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRIcCA8PSAwO1xufTtcblxuLy8gRXhwZWN0cyB1cCwgZG93biwgbGVmdCBvciByaWdodFxuTW9uc3Rlci5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKGRpcmVjdGlvbikge1xuICAgIHZhciBzcGVlZCA9IHRoaXMuYmFzZU1zO1xuXG4gICAgLy8gc29tZSBiYXNpYyBtb25zdGVyIE1vdmVtZW50XG4gICAgLy8gIE5PVEUgc3VjaCBhIGhhc3NsZSB0byBmaWd1cmUgdGhpcyBvdXRcbiAgICAvLyAgVE9ETyBub3QgZmluaXNoZWQsIG5vdCBldmVuIGdvaW5nIHRvIHRyeSBhbmQgZmluaXNoIHdpbGwgZmlndXJlIG91dCBob3cgdGhpcyBzaG91bGQgd29yayBsYXRlclxuICAgIGlmICh0aGlzLnBvc2l0aW9uLnggPD0gNTAgJiYgdGhpcy5wb3NpdGlvbi55IDwgNTAwKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24ueCArPSBzcGVlZDtcbiAgICB9IGVsc2UgaWYgKHRoaXMucG9zaXRpb24ueCA+PSA1MCAmJiB0aGlzLnBvc2l0aW9uLnkgPj0gOTApIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi55IC09IHNwZWVkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wb3NpdGlvbi54IDw9IDE4MCAmJiB0aGlzLnBvc2l0aW9uLnkgPj0gODApIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi54ICs9IHNwZWVkO1xuICAgIH1cblxuICAgIC8vICBtYXkgbm90IGJlIHRoZSBiZXN0IHdheSB0byBkbyB0aGlzIGJ1dCBpbGwga2VlcCBpdCBiZWNhdXNlIG5vdCBldmVuIHN1cmUgaG93IHRvIGRvIHRoaXMgbW92ZW1lbnQgcGFydFxuICAgIC8vIGlmICh0eXBlb2YgZGlyZWN0aW9uICE9PSBcInN0cmluZ1wiKSB7XG4gICAgLy8gICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJkaXJlY3Rpb24gaXMgbm90IGEgc3RyaW5nXCIpO1xuICAgIC8vIH1cbiAgICAvLyBkaXJlY3Rpb24gPSBkaXJlY3Rpb24udG9Mb3dlckNhc2UoKTtcbiAgICAvLyBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgIC8vICAgICBjYXNlIFwidXBcIjpcbiAgICAvLyAgICAgY2FzZSBcImRvd25cIjpcbiAgICAvLyAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAvLyAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgLy8gICAgIGRlZmF1bHQ6XG4gICAgLy8gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRpcmVjdGlvblwiKTtcbiAgICAvLyB9XG59O1xuXG4vLyBDYW4gdGFrZSBpbiBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIG51bWJlclxuTW9uc3Rlci5wcm90b3R5cGUudXBkYXRlSHAgPSBmdW5jdGlvbihocENoYW5nZSkge1xuICAgIHRoaXMuY3VycmVudEhwICs9IGhwQ2hhbmdlO1xuXG4gICAgaWYgKHRoaXMuY3VycmVudEhwID4gdGhpcy5tYXhIcCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRIcCA9IHRoaXMubWF4SHA7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb25zdGVyO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9qcy9jbGFzc2VzL01vbnN0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtb25zdGVyMToge1xuICAgICAgICBtYXhIcDogMzAsXG4gICAgICAgIGJhc2VNczogMTAsXG4gICAgICAgIHR5cGU6IDEgLy8gQ2hhbmdlIHRoaXMgdHlwZSBsYXRlclxuICAgIH1cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2pzL2dhbWVEYXRhL21vbnN0ZXJkYXRhLmpzXG4gKiogbW9kdWxlIGlkID0gOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==