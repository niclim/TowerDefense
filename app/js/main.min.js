/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/src/js/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	// Canvas
	__webpack_require__(2);
	
	// User interaction elements
	__webpack_require__(3);


/***/ },
/* 2 */
/***/ function(module, exports) {

	// background contains the static canvas elements
	var background = document.getElementById("static");
	var backgroundContext = background.getContext("2d");
	
	// Settings for the background - move out to a separate file
	var settings = {
	    backgroundColor: "#8CD1E6",
	    pathColor: "gray"
	}
	
	// Drawing the background
	backgroundContext.fillStyle = settings.backgroundColor;
	backgroundContext.fillRect(0, 0, background.width, background.height);
	
	/* Main path will go from [0, 500], [75, 500], [75, 100], [225, 100], [225, 500], [375, 500], [375, 100], [525, 100], [525, 500], [675, 500], [675, 100], [825, 100], [825, 500], [900, 500] */
	
	// Drawing the path - width of the path is 50px
	backgroundContext.fillStyle = settings.pathColor;
	
	backgroundContext.beginPath();
	
	// For the bottom part of the path
	backgroundContext.moveTo(0, 525);
	
	backgroundContext.lineTo(100, 525);
	backgroundContext.lineTo(100, 125); // Top
	backgroundContext.lineTo(200, 125);
	backgroundContext.lineTo(200, 525); // Bottom
	backgroundContext.lineTo(400, 525);
	backgroundContext.lineTo(400, 125); // Top
	backgroundContext.lineTo(500, 125);
	backgroundContext.lineTo(500, 525); // Bottom
	backgroundContext.lineTo(700, 525);
	backgroundContext.lineTo(700, 125); // Top
	backgroundContext.lineTo(800, 125);
	backgroundContext.lineTo(800, 525); // Bottom
	
	//Middle section to the side
	backgroundContext.lineTo(900, 525);
	backgroundContext.lineTo(900, 475);
	backgroundContext.lineTo(850, 475);
	
	// For the top part of the path
	backgroundContext.lineTo(850, 75);
	backgroundContext.lineTo(650, 75);
	backgroundContext.lineTo(650, 475);
	backgroundContext.lineTo(550, 475);
	backgroundContext.lineTo(550, 75);
	backgroundContext.lineTo(350, 75);
	backgroundContext.lineTo(350, 475);
	backgroundContext.lineTo(250, 475);
	backgroundContext.lineTo(250, 75);
	backgroundContext.lineTo(50, 75);
	backgroundContext.lineTo(50, 475);
	
	// End section
	backgroundContext.lineTo(0, 475);
	
	backgroundContext.fill();
	// backgroundContext.lineTo();
	
	// draw a grid (for development purposes)
	var width = 900, height = 600;
	// draw vertical lines
	for (var i = 0; i < width; i += 25) {
	    backgroundContext.moveTo(i, 0);
	    backgroundContext.lineTo(i, height);
	    backgroundContext.stroke();
	}
	// draw horizontal lines
	for (var i = 0; i < height; i += 25) {
	    backgroundContext.moveTo(0, i);
	    backgroundContext.lineTo(width, i);
	    backgroundContext.stroke();
	}


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	// Initiate all the components
	var Tower = __webpack_require__(4),
	    GameEngine = __webpack_require__(9);
	
	// Import and declare utility functions
	var utils = __webpack_require__(6);
	
	var constants = __webpack_require__(7),
	    towerData = __webpack_require__(5);
	
	// Cache reused DOM elements
	var infoName = document.getElementById("info-name"),
	    infoIcon = document.getElementById("info-icon"),
	    infoBox1 = document.getElementById("info-box-1"),
	    infoBox2 = document.getElementById("info-box-2"),
	    infoBox3 = document.getElementById("info-box-3"),
	    infoBox4 = document.getElementById("info-box-4"),
	    levelInfo = document.getElementById("level"),
	    goldInfo = document.getElementById("gold"),
	    livesInfo = document.getElementById("lives"),
	    towerCards = document.getElementsByClassName("tower-card"),
	    towerCardList = [];
	
	// Convert from nodelist to array
	towerCards = Array.prototype.slice.call(towerCards);
	
	/*
	Create state variables - These are modified on user interaction events
	State variables
	activeCanvasElement - Changed on a mouse click event on a monster, tower or nothing
	activeTowerSelected - The name of the tower that is being placed by the user
	activeMessage - Message displayed in the canvas (can be used for new levels, invalid tower placements, etc)
	canvasMousePosition -
	    onCanvas - boolean to represent whether the mouse is currently on the canvas
	    towerPosition - object with a grid value and coordinate value and sides
	        grid - the top left block of the tower being placed - towers are a 2x2 grid
	        coordinate - the top left corner coordinate
	        sides - 50 px
	    mousePosition - the current mouse coordinates
	*/
	
	var activeCanvasElement = {type: null},
	    activeTowerSelected = null,
	    activeMessage = {message: null},
	    canvasMousePosition = {
	        onCanvas: false,
	        towerPosition: {},
	        mousePosition: {}
	    };
	
	//  creates global variables
	game = new GameEngine; // Privatize this later
	dynamicCanvas = document.getElementById('dynamic');
	dynamicContext = dynamicCanvas.getContext('2d');
	
	// Declare the game loop
	var lastTime;
	function gameLoop() {
	    var now = Date.now(),
	        dt = (now - lastTime) / 1000.0; // Convert to seconds
	
	    game.runCycle(dt);
	
	    lastTime = now;
	    // Renders methods based on state variables
	    game.render();
	    updateGameDependentInformation();
	    renderTowerPlacement();
	    renderMessage(dt);
	    requestAnimationFrame(gameLoop);
	}
	
	/* ================== Render functions =================*/
	/* =====================================================*/
	
	function updateGameDependentInformation() {
	    livesInfo.innerHTML = game.userLives;
	    goldInfo.innerHTML = game.userGold;
	    levelInfo.innerHTML = game.level;
	
	    if (activeCanvasElement.type === "monster") {
	        document.getElementById("monsterHp").innerHTML = game.activeMonsters[activeCanvasElement.index].currentHp;
	    } else if (activeCanvasElement.type === "tower") {
	        // Add any relevant tower information here
	    }
	}
	
	// Moved this outside of the gameLoop, will only update the relevant data when necessary
	function updateInformationPanel() {
	    if (activeCanvasElement.type === "monster") {
	        renderMonsterInformation(activeCanvasElement.index);
	    } else if (activeCanvasElement.type === "tower") {
	        renderTowerInformation(activeCanvasElement.index);
	    } else {
	        renderDefaultInformation();
	    }
	}
	
	// ID refers to the type of monster and index is the index of the active monster in the active monster's array
	function renderMonsterInformation(index) {
	    var currentHp = game.activeMonsters[index].currentHp,
	        maxHp = game.activeMonsters[index].maxHp,
	        type = game.activeMonsters[index].type,
	        id = game.activeMonsters[index].id;
	
	    infoName.innerHTML = id;
	    // Change icon to active monster - use a sprite
	    infoBox1.innerHTML = "HP: <span id='monsterHp'>" + currentHp + "</span> / " + maxHp;
	    infoBox2.innerHTML = "Type: " + type;
	    infoBox3.innerHTML = "Strengths: All sorts mate" ;
	    infoBox4.innerHTML = "Weaknesses: Ducks" ;
	}
	
	// ID refers to the type of tower and index is the index of the active tower in the active tower's array
	// TODO add number of targetrs
	function renderTowerInformation(index) {
	    var id = game.towers[index].id,
	        damage = towerData[id].projectile.damage,
	        type = towerData[id].projectile.type,
	        effect = "",
	        range = game.towers[index].range,
	        speed = game.towers[index].attackSpeed,
	        upgradeAvailable = towerData[id].upgrade.length !== 0;
	
	    if (towerData[id].projectile.effects.length === 0) {
	        effect = "None"
	    } else {
	        towerData[id].projectile.effects.forEach(function(e) {
	            effect += e + " ";
	        });
	    }
	
	    infoName.innerHTML = id;
	    // Change icon to tower monster - use a sprite
	    infoBox1.innerHTML = "Damage: " + damage + " <br>Range: " + range + " <br>Effect: " + effect;
	    infoBox2.innerHTML = "Attack Speed: " + speed + " <br>Type: " + type;
	    infoBox3.innerHTML = upgradeAvailable ? "<a class='waves-effect waves-light btn red' id='upgradeButton'>Upgrade</a>" : "";
	    infoBox4.innerHTML = "<a class='waves-effect waves-light btn red' id='sellButton'>Sell</a>";
	}
	
	function renderDefaultInformation() {
	    infoName.innerHTML = "Awesome TD";
	    // Change icon to default image - use a sprite
	    infoBox1.innerHTML = "This is some text";
	    infoBox2.innerHTML = "This is different text";
	    infoBox3.innerHTML = "This is ??? text" ;
	    infoBox4.innerHTML = "This 1231241235" ;
	}
	
	function renderMessage(dt) {
	    if (activeMessage.message === null) {
	        return;
	    } else {
	        dynamicContext.globalAlpha = activeMessage.timer > 0 ? activeMessage.timer : 0; // Sets transparency to 0 if a negative number
	        dynamicContext.font = constants.MESSAGEFONT;
	        dynamicContext.textAlign = "center";
	        dynamicContext.fillStyle = constants.MESSAGECOLOR;
	        dynamicContext.fillText(activeMessage.message, constants.CANVASWIDTH / 2, 50);
	        dynamicContext.globalAlpha = 1;
	
	        if (activeMessage.timer <= 0) {
	            activeMessage = {message: null}; // Reset message
	        } else {
	            activeMessage.timer -= dt;
	        }
	    }
	}
	
	function renderTowerPlacement() {
	    if (activeTowerSelected === null ||
	        !canvasMousePosition.onCanvas) {
	        return
	    };
	
	    var coordinates = canvasMousePosition.towerPosition.coordinates;
	    dynamicContext.beginPath();
	    dynamicContext.globalAlpha = 0.5;
	
	    // Draw grid validation placement
	    if (game.validateTowerPlacement(canvasMousePosition.towerPosition.grid)) {
	        dynamicContext.fillStyle = "green";
	    } else {
	        dynamicContext.fillStyle = "red";
	    }
	    dynamicContext.fillRect(coordinates.x,
	                            coordinates.y,
	                            constants.TOWERLENGTH,
	                            constants.TOWERLENGTH
	     );
	
	     // Draw tower
	    dynamicContext.globalAlpha = 0.7;
	    dynamicContext.arc(coordinates.x + constants.TOWERLENGTH / 2,
	                       coordinates.y + constants.TOWERLENGTH / 2,
	                       constants.TOWERLENGTH * 0.6,
	                       0,
	                       2 * Math.PI,
	                       false
	     );
	    dynamicContext.fillStyle = 'gray';
	    dynamicContext.fill();
	
	    dynamicContext.globalAlpha = 1;
	    dynamicContext.closePath();
	}
	
	/* ================ UI Event Listeners =================*/
	/* =====================================================*/
	document.getElementById("mainModal").addEventListener("click", modalClick);
	
	/*
	These event listeners control the application by interacting with the game
	object and by changing the state variables (which the render functions use
	to read)
	*/
	towerCards.forEach(function(towerCard, i) {
	    towerCardList.push(towerCard.getAttribute("data-tower"));
	    towerCard.addEventListener("click", towerCardClick);
	});
	
	document.getElementById("dynamic").onmousemove = onCanvasMouseMovement;
	document.getElementById("dynamic").addEventListener("click", canvasClick);
	
	document.onkeydown = function(e) {
	    if (e.keyCode === 27) {
	        cancelTowerPlacement();
	    }
	}
	
	// updates activeCanvasElement when monster death or tower removed affects the current selected target
	document.addEventListener("unitRemoved", function(e) {
	    // Updates if the active element is the same as the type of unit removed
	    if (activeCanvasElement.type === e.detail.element) {
	        if (e.detail.index < activeCanvasElement.index) {
	            activeCanvasElement.index--; // Update positioning in element
	        } else if (e.detail.index === activeCanvasElement.index) {
	            activeCanvasElement = {type: null} // Reset
	        }
	        updateInformationPanel();
	    }
	});
	
	// Adds event listeners only to the info box
	document.getElementsByClassName("side-section left")[0].addEventListener("click", function(e) {
	    if (activeCanvasElement.type === "tower") {
	        if (e.target.id === "upgradeButton") {
	            showUpgradeOptions(activeCanvasElement.index);
	        } else if (e.target.id === "sellButton") {
	            sellTower();
	        }
	    }
	})
	
	/* =================== UI Functions ====================*/
	/* =====================================================*/
	function modalClick(e) {
	    var clickTarget = e.target.getAttribute("data-action");
	
	    switch (clickTarget) {
	        case "start":
	            startGame();
	            break;
	        case "information":
	            console.log("show information container here");
	            break;
	        case "upgrade":
	            var upgradeName = e.target.getAttribute("data-upgradename");
	            upgradeTower(activeCanvasElement.index, upgradeName);
	            break;
	        default:
	            return;
	    }
	    document.getElementById("mainModal").style.display = "none";
	    document.getElementsByClassName("modal-background")[0].style.display = "none";
	}
	
	function startGame() {
	    game.gameStart();
	    // Sets up game loop and render loop
	    lastTime = Date.now();
	    gameLoop();
	}
	
	/* Click event listener on the tower cards
	Used to control what tower is being actively placed on the canvas
	4 possible flows based on the state of the interface
	1) The tower that was clicked is currently disabled:
	    -> function returns
	2) No towers are actively being placed
	    -> the clicked tower card now becomes the active tower being placed
	3) The clicked tower is the same as the tower actively being placed
	    -> the state is reset so that no towers are actively being placed
	4) The clicked tower is different from the tower actively being placed
	    -> the state is changed to the clicked tower becoming the active tower
	*/
	function towerCardClick() {
	
	    var towerName = this.getAttribute("data-tower"),
	        oldTowerIndex = towerCardList.indexOf(activeTowerSelected),
	        newTowerIndex = towerCardList.indexOf(towerName);
	
	    if (/disabled/i.test(this.className)) {
	        return;
	
	    } else if (activeTowerSelected === null) {
	        activeTowerSelected = towerName;
	        utils.addClass(towerCards[newTowerIndex], "active");
	        canvasMousePosition.onCanvas = false;
	    } else if (activeTowerSelected === towerName) {
	        cancelTowerPlacement();
	        canvasMousePosition.onCanvas = false;
	    } else {
	        utils.removeClass(towerCards[oldTowerIndex], "active");
	        activeTowerSelected = towerName;
	        utils.addClass(towerCards[newTowerIndex], "active");
	        canvasMousePosition.onCanvas = false;
	    }
	}
	
	/*
	Called from towerCardClick (when clicking the active tower card) and on an escape key press
	Resets the active tower placement state to null
	*/
	function cancelTowerPlacement() {
	    utils.removeClass(towerCards[towerCardList.indexOf(activeTowerSelected)], "active");
	    activeTowerSelected = null;
	}
	
	/* Mouse move event listener on the canvas
	If the active tower selected state (a tower is being placed by the user):
	    -> update the position of the mouse on the canvas (used by the renderTowerPlacement function)
	otherwise:
	    -> do nothing
	*/
	function onCanvasMouseMovement(e) {
	    if (activeTowerSelected === null) {
	        return
	    };
	
	    var canvasContainer = this.getBoundingClientRect(),
	        position = {};
	
	    position.x = e.clientX - canvasContainer.left;
	    position.y = e.clientY - canvasContainer.top;
	    canvasMousePosition.mousePosition = position;
	    canvasMousePosition.towerPosition = utils.convertPositionToTower(position);
	    canvasMousePosition.onCanvas = true;
	};
	
	
	/* Click event listener on the canvas
	Handles two possible canvas click scenarios
	1) A tower is selected and is actively being placed
	    -> Clicking will validate the tower placement and check the user's gold
	    if both are valid, will tower will be placed (by game object)
	    otherwise, an error message will show up
	2) A tower is not selected and is not being placed
	    -> Will check whether the click position overlaps with the bounding
	    rectangle of monster or tower - if so, it will return the information
	    in the information container
	*/
	function canvasClick(e) {
	    // Get click location relative to the canvas element
	    var canvasContainer = this.getBoundingClientRect(),
	        position = {},
	        towerGridPosition = canvasMousePosition.towerPosition.grid,
	        towerCoordinates = canvasMousePosition.towerPosition.coordinates; // Passes in grid blocks - this is the topLeft block
	
	    position.x = e.clientX - canvasContainer.left;
	    position.y = e.clientY - canvasContainer.top;
	
	    // Runs if the user is placing a tower
	    if (activeTowerSelected !== null) {
	        var towerName = activeTowerSelected,
	            towerPlaced = game.placeTower(towerName, towerGridPosition, towerCoordinates);
	
	        // If the tower was not placed, show an error message
	        if (!towerPlaced.placed) {
	            activeMessage = {
	                message: towerPlaced.message,
	                timer: constants.MESSAGEDURATION // seconds
	            }
	        }
	
	        utils.removeClass(towerCards[towerCardList.indexOf(activeTowerSelected)], "active");
	        activeTowerSelected = null;
	    } else {
	        // User is not running a tower placement
	        activeCanvasElement = game.checkClickLocation(position);
	        updateInformationPanel();
	    }
	}
	
	function sellTower() {
	    game.sellTower(activeCanvasElement.index);
	    updateInformationPanel();
	}
	
	// At the moment expects only towers with upgrades should be able to access this
	function showUpgradeOptions(towerIndex) {
	    // Figure out where to show the upgrade contianer
	    document.getElementById("mainModal").style.display = "block";
	    document.getElementsByClassName("modal-background")[0].style.display = "block";
	
	    var towerId = game.towers[towerIndex].id,
	        upgrades = towerData[towerId].upgrade;
	
	    // Todo move HTML out into a template
	    var title = "Upgrade Tower",
	        content = "";
	
	    upgrades.forEach(function(upgradeObj) {
	        var towerDataObject = towerData[upgradeObj.name];
	        content += "<a class='waves-effect waves-light btn-large red' data-action='upgrade' data-upgradename='" + upgradeObj.name + "'>" + upgradeObj.name + " Upgrade</a>";
	    });
	
	    document.getElementById("mainModalTitle").innerHTML = title;
	    document.getElementById("mainModalContent").innerHTML = content;
	
	}
	
	function upgradeTower(towerIndex, upgradeName) {
	   var upgraded = game.upgradeTower(towerIndex, upgradeName);
	    if (upgraded) {
	        updateInformationPanel();
	    } else {
	        activeMessage = {
	            message: constants.MESSAGENOTENOUGHGOLD,
	            timer: constants.MESSAGEDURATION // seconds
	        }
	    }
	}


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var towerData = __webpack_require__(5),
	    utils = __webpack_require__(6),
	    Projectile = __webpack_require__(8),
	    constants = __webpack_require__(7);
	
	// Position refers to the upper left corner of the elements
	// Tower width - 50 x 50
	var Tower = function(position, id) {
	    if (towerData[id] === undefined) {
	        throw new Error("Invalid tower name, check html dataattribute or towerdata")
	    }
	    this.id = id;
	    this.attackSpeed = towerData[id].attackSpeed; // Attack speed
	    this.cooldown = 0;
	    this.range = towerData[id].range; // Range of the tower
	    this.effects = towerData[id].effects; // Special effect (e.g. slow, splash, etc)
	    this.goldCost = towerData[id].goldCost;
	    this.totalCost = towerData[id].totalCost;
	    this.upgrade = towerData[id].upgrade;
	    this.targets = towerData[id].targets;
	    this.position = position; // object with x and y coordinates - references the top left corner of the tower
	    this.position.sideLength = constants.TOWERLENGTH;
	}
	// Method the game object uses to run towers
	Tower.prototype.runCycle = function(activeMonsters, dt) {
	    var targetMonster = null;
	
	    if (this.cooldown < 0) {
	        // Creates projectiles up to the number of targets specified by the tower
	        var firedShots = 0;
	        activeMonsters.forEach(function(monster) {
	            if (this.checkInRange(monster.position) && (firedShots < this.targets)) {
	                monster.projectiles.push(new Projectile(this.id, this.position));
	                firedShots++;
	            }
	        }.bind(this));
	
	        this.cooldown = this.attackSpeed;
	    }
	
	    if (this.cooldown >= 0) {
	        this.cooldown -= dt;
	    }
	}
	
	// Takes in a monster's position and checks whether that is in range based on the range - returns true or false if in range which can be used to
	Tower.prototype.checkInRange = function(monsterPosition) {
	    // using sqrt((x2-x1)^2 - (y2-y1)^2)
	    var monsterDistance = utils.getPositionDifference(monsterPosition, this.position);
	
	   if (monsterDistance <= this.range) {
	       return true;
	   } else {
	       return false;
	   }
	}
	
	// TODO figure out a better way to render towers
	Tower.prototype.draw = function() {
	    dynamicContext.beginPath();
	    dynamicContext.fillStyle = "green";
	    dynamicContext.fillRect(this.position.x,
	                            this.position.y,
	                            constants.TOWERLENGTH,
	                            constants.TOWERLENGTH);
	    dynamicContext.closePath();
	}
	
	module.exports = Tower;


/***/ },
/* 5 */
/***/ function(module, exports) {

	// This should probably be in a database
	module.exports = {
	    // Basic tower tree here
	    basic: {
	        projectile: {
	            damage: 5,
	            travelTime: 0.5, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "normal", //
	            effects: []
	        },
	        sprite: "TODO",
	        targets: 1,
	        attackSpeed: 1, // 1 second per attack
	        range: 300,
	        goldCost: 10,
	        totalCost: 10, // Used for upgraded towers
	        upgrade: [
	            {
	                name: "advanced"
	            },
	            {
	                name: "multishot"
	            }
	        ]
	    },
	    advanced: {
	        projectile: {
	            damage: 15,
	            travelTime: 0.5, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "normal",
	            effects: []
	        },
	        sprite: "TODO",
	        targets: 1,
	        attackSpeed: 0.8,
	        range: 400,
	        goldCost: 20,
	        totalCost: 30,
	        upgrade: [
	            {
	                name: "expert"
	            }
	        ]
	    },
	    expert: {
	        projectile: {
	            damage: 45,
	            travelTime: 0.5, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "normal",
	            effects: []
	        },
	        sprite: "TODO",
	        targets: 1,
	        attackSpeed: 0.8,
	        range: 400,
	        goldCost: 60,
	        totalCost: 90,
	        upgrade: []
	    },
	    multishot: {
	        projectile: {
	            damage: 5,
	            travelTime: 0.5, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "normal",
	            effects: []
	        },
	        sprite: "TODO",
	        targets: 3,
	        attackSpeed: 0.8,
	        range: 400,
	        goldCost: 20,
	        totalCost: 30,
	        upgrade: [
	            {
	                name: "expertMultishot"
	            }
	        ]
	    },
	    expertMultishot: {
	        projectile: {
	            damage: 30,
	            travelTime: 0.5, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "normal",
	            effects: []
	        },
	        sprite: "TODO",
	        targets: 4,
	        attackSpeed: 0.8,
	        range: 400,
	        goldCost: 100,
	        totalCost: 130,
	        upgrade: []
	    },
	
	    // Heavy tower tree here
	    heavy: {
	        projectile: {
	            damage: 15,
	            travelTime: 0.8, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "normal",
	            effects: []
	        },
	        sprite: "TODO",
	        targets: 1,
	        attackSpeed: 2,
	        range: 250,
	        goldCost: 10,
	        totalCost: 10,
	        upgrade: [
	            {
	                name: "siege"
	            },
	            {
	                name: "cannon"
	            }
	        ]
	    },
	    siege: {
	        projectile: {
	            damage: 40,
	            travelTime: 0.6, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "normal",
	            effects: []
	        },
	        sprite: "TODO",
	        targets: 1,
	        attackSpeed: 2,
	        range: 350,
	        goldCost: 30,
	        totalCost: 40,
	        upgrade: [
	            {
	                name: "demolition"
	            },
	            {
	                name: "explosion"
	            }
	        ]
	    },
	    demolition: {
	        projectile: {
	            damage: 100,
	            travelTime: 0.6, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "normal",
	            effects: []
	        },
	        sprite: "TODO",
	        targets: 1,
	        attackSpeed: 1.5,
	        range: 500,
	        goldCost: 100,
	        totalCost: 140,
	        upgrade: []
	    },
	    explosion: {
	        projectile: {
	            damage: 60,
	            travelTime: 0.6, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "normal",
	            effects: [
	                {
	                    type: "splash",
	                    radius: 200
	                }
	            ]
	        },
	        sprite: "TODO",
	        targets: 1,
	        attackSpeed: 1.5,
	        range: 500,
	        goldCost: 100,
	        totalCost: 140,
	        upgrade: []
	    },
	    cannon: {
	        projectile: {
	            damage: 20,
	            travelTime: 0.6, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "normal",
	            effects: [
	                {
	                    type: "amplify",
	                    amount: 1.5 // damage multiplier
	                }
	            ]
	        },
	        sprite: "TODO",
	        targets: 1,
	        attackSpeed: 1,
	        range: 350,
	        goldCost: 30,
	        totalCost: 40,
	        upgrade: [
	            {
	                name: "shrapnel"
	            },
	            {
	                name: "artillery"
	            }
	        ]
	    },
	    shrapnel: {
	        projectile: {
	            damage: 40,
	            travelTime: 0.6, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "normal",
	            effects: [
	                {
	                    type: "amplify",
	                    amount: 1.5 // damage multiplier
	                }
	            ]
	        },
	        sprite: "TODO",
	        targets: 3,
	        attackSpeed: 1,
	        range: 350,
	        goldCost: 80,
	        totalCost: 120,
	        upgrade: []
	    },
	    artillery: {
	        projectile: {
	            damage: 70,
	            travelTime: 0.3, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "normal",
	            effects: [
	                {
	                    type: "amplify",
	                    amount: 2 // damage multiplier
	                }
	            ]
	        },
	        sprite: "TODO",
	        targets: 1,
	        attackSpeed: 1,
	        range: 600,
	        goldCost: 110,
	        totalCost: 150,
	        upgrade: []
	    },
	
	    // Fire tower tree here
	    fire: {
	        projectile: {
	            damage: 10,
	            travelTime: 0.3, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "fire",
	            effects: [
	                {
	                    type: "dot",
	                    dps: 5
	                }
	            ]
	        },
	        sprite: "TODO",
	        targets: 1,
	        attackSpeed: 0.6,
	        range: 300,
	        goldCost: 30,
	        totalCost: 30,
	        upgrade: [
	            {
	                name: "broiler"
	            },
	            {
	                name: "flamethrower"
	            }
	        ]
	    },
	    broiler: {
	        projectile: {
	            damage: 8,
	            travelTime: 0.01, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "fire",
	            effects: []
	        },
	        sprite: "TODO",
	        targets: 30,
	        attackSpeed: 0.2,
	        range: 300,
	        goldCost: 60,
	        totalCost: 90,
	        upgrade: [
	            {
	                name: "volcano"
	            },
	            {
	                name: "inferno"
	            }
	        ]
	    },
	    volcano: {
	        projectile: {
	            damage: 20,
	            travelTime: 0.01, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "fire",
	            effects: []
	        },
	        sprite: "TODO",
	        targets: 30,
	        attackSpeed: 0.2,
	        range: 300,
	        goldCost: 110,
	        totalCost: 200,
	        upgrade: []
	    },
	    inferno: {
	        projectile: {
	            damage: 15,
	            travelTime: 0.01, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "fire",
	            effects: []
	        },
	        sprite: "TODO",
	        targets: 30,
	        attackSpeed: 0.2,
	        range: 500,
	        goldCost: 110,
	        totalCost: 200,
	        upgrade: []
	    },
	    flamethrower: {
	        projectile: {
	            damage: 20,
	            travelTime: 0.01, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "fire",
	            effects: [
	                {
	                    type: "dot",
	                    dps: 10
	                }
	            ]
	        },
	        sprite: "TODO",
	        targets: 1,
	        attackSpeed: 0.5,
	        range: 300,
	        goldCost: 60,
	        totalCost: 90,
	        upgrade: [
	            {
	                name: "napalm"
	            }
	        ]
	    },
	    napalm: {
	        projectile: {
	            damage: 50,
	            travelTime: 0.01, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "fire",
	            effects: [
	                {
	                    type: "dot",
	                    dps: 30
	                }
	            ]
	        },
	        sprite: "TODO",
	        targets: 1,
	        attackSpeed: 0.5,
	        range: 400,
	        goldCost: 90,
	        totalCost: 150,
	        upgrade: []
	    },
	
	    // Ice starts here
	    ice: {
	        projectile: {
	            damage: 10,
	            travelTime: 0.8, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "ice",
	            effects: [
	                {
	                    type: "slow",
	                    slow: 0.3 // decimal of how slow - higher is more slow
	                }
	            ]
	        },
	        sprite: "TODO",
	        targets: 1,
	        attackSpeed: 0.8,
	        range: 300,
	        goldCost: 30,
	        totalCost: 30,
	        upgrade: [
	            {
	                name: "blizzard"
	            },
	            {
	                name: "frost"
	            }
	        ]
	    },
	    blizzard: {
	        projectile: {
	            damage: 5,
	            travelTime: 0.2, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "ice",
	            effects: [
	                {
	                    type: "slow",
	                    slow: 0.4 // decimal of how slow - higher is more slow
	                }
	            ]
	        },
	        sprite: "TODO",
	        targets: 30,
	        attackSpeed: 0.8,
	        range: 300,
	        goldCost: 70,
	        totalCost: 100,
	        upgrade: [
	            {
	                name: "arctic"
	            }
	        ]
	    },
	    arctic: {
	        projectile: {
	            damage: 12,
	            travelTime: 0.2, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "ice",
	            effects: [
	                {
	                    type: "slow",
	                    slow: 0.5 // decimal of how slow - higher is more slow
	                }
	            ]
	        },
	        sprite: "TODO",
	        targets: 30,
	        attackSpeed: 0.8,
	        range: 400,
	        goldCost: 70,
	        totalCost: 170,
	        upgrade: []
	    },
	    frost: {
	        projectile: {
	            damage: 25,
	            travelTime: 0.6, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "ice",
	            effects: [
	                {
	                    type: "slow",
	                    slow: 0.5 // decimal of how slow - higher is more slow
	                }
	            ]
	        },
	        sprite: "TODO",
	        targets: 1,
	        attackSpeed: 0.8,
	        range: 300,
	        goldCost: 60,
	        totalCost: 90,
	        upgrade: [
	            {
	                name: "tundra"
	            },
	            {
	                name: "permafrost"
	            }
	        ]
	    },
	    tundra: {
	        projectile: {
	            damage: 40,
	            travelTime: 0.6, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "ice",
	            effects: [
	                {
	                    type: "slow",
	                    slow: 0.65 // decimal of how slow - higher is more slow
	                }
	            ]
	        },
	        sprite: "TODO",
	        targets: 1,
	        attackSpeed: 0.8,
	        range: 400,
	        goldCost: 90,
	        totalCost: 180,
	        upgrade: []
	    },
	    permafrost: {
	        projectile: {
	            damage: 30,
	            travelTime: 0.6, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "ice",
	            effects: [
	                {
	                    type: "freeze",
	                    duration: 1,
	                    chance: 0.2
	                }
	            ]
	        },
	        sprite: "TODO",
	        targets: 1,
	        attackSpeed: 0.8,
	        range: 400,
	        goldCost: 120,
	        totalCost: 210,
	        upgrade: []
	    },
	    // Light tower tree here
	    light: {
	        projectile: {
	            damage: 5,
	            travelTime: 0.1, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "light",
	            effects: []
	        },
	        sprite: "TODO",
	        targets: 1,
	        attackSpeed: 0.4,
	        range: 500,
	        goldCost: 30,
	        totalCost: 30,
	        upgrade: [
	            {
	                name: "laser"
	            },
	            {
	                name: "electric"
	            }
	        ]
	    },
	    laser: {
	        projectile: {
	            damage: 15,
	            travelTime: 0.1, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "light",
	            effects: []
	        },
	        sprite: "TODO",
	        targets: 1,
	        attackSpeed: 0.3,
	        range: 600,
	        goldCost: 60,
	        totalCost: 90,
	        upgrade: [
	            {
	                name: "prism"
	            }
	        ]
	    },
	    prism: {
	        projectile: {
	            damage: 50,
	            travelTime: 0.1, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "light",
	            effects: []
	        },
	        sprite: "TODO",
	        targets: 1,
	        attackSpeed: 0.2,
	        range: 600,
	        goldCost: 180,
	        totalCost: 270,
	        upgrade: [
	            {
	                name: "prism"
	            }
	        ]
	    },
	    electric: {
	        projectile: {
	            damage: 15,
	            travelTime: 0.1, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "light",
	            effects: [
	                {
	                    type: "bounce",
	                    range: 300,
	                    bounces: 2
	                }
	            ]
	        },
	        sprite: "TODO",
	        targets: 1,
	        attackSpeed: 0.6,
	        range: 400,
	        goldCost: 60,
	        totalCost: 90,
	        upgrade: [
	            {
	                name: "lightning"
	            },
	            {
	                name: "generator"
	            }
	        ]
	    },
	    lightning: {
	        projectile: {
	            damage: 35,
	            travelTime: 0.1, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "light",
	            effects: [
	                {
	                    type: "bounce",
	                    range: 300,
	                    bounces: 2
	                }
	            ]
	        },
	        sprite: "TODO",
	        targets: 1,
	        attackSpeed: 0.6,
	        range: 400,
	        goldCost: 90,
	        totalCost: 180,
	        upgrade: []
	    },
	    generator: {
	        projectile: {
	            damage: 35,
	            travelTime: 0.1, // time in seconds before impact
	            sprite: "TODO", // change this to have animations
	            type: "light",
	            effects: []
	        },
	        sprite: "TODO",
	        targets: 3,
	        attackSpeed: 0.6,
	        range: 400,
	        goldCost: 90,
	        totalCost: 180,
	        upgrade: []
	    }
	
	};


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var constants = __webpack_require__(7);
	
	/* ================== Public functions =================*/
	/* =====================================================*/
	function addClass(element, cssClass) {
	    if (element.className === "") {
	        element.className = cssClass;
	    } else {
	        element.className += " " + cssClass;
	    }
	}
	
	/*
	checkIfInSquare checks whether a point is in a square (which is a monster or a tower)
	
	Takes in three arguments
	point - a object with x and y coordinates
	topLeftPoint - an object with x and y coordinates of the top left corner of the square
	sideLength - the length of the square
	
	Returns a boolean - true if the click overlaps with an element and false
	                    if it does not
	*/
	function checkIfInSquare(point, topLeftPoint, sideLength) {
	    if (point.x >= topLeftPoint.x
	    && point.x <= topLeftPoint.x + sideLength
	    && point.y >= topLeftPoint.y
	    && point.y <= topLeftPoint.y + sideLength) {
	        return true;
	    } else {
	        return false;
	    }
	}
	
	/*
	Takes in a distance (int) and pathLines(array of path objects) and converts it to coordinates for a monster
	Returns a coordinate object
	*/
	function convertDistanceToCoordinates(distance, pathLines) {
	    var coordinates,
	        end = false; // Boolean to represent whether the monster is at the end
	
	
	    for (var i = 0; i < pathLines.length; i ++) {
	        if (distance - pathLines[i].distance <= 0) {
	            break;
	        } else {
	            distance -= pathLines[i].distance;
	        }
	    }
	
	    if (i === pathLines.length) {
	        i--; // Set the counter value to be the last value in the pathlines array
	        distance =  pathLines[i].distance;
	        end = true;
	    }
	
	    // Create a new object to return (instead of modifiying startPoint object)
	    coordinates = Object.create(pathLines[i].startPoint);
	    coordinates.end = end;
	
	    // Case for when monster is at the end of the thingy - there is a better way to write this but not right now
	    if (!end) {
	        switch (pathLines[i].direction) {
	            // 15 is a half of the monster width
	            // values used to offset the positioning based on the monster direciton movement
	            case "up":
	            coordinates.x -= constants.MONSTERLENGTH/2;
	            coordinates.y -= distance + constants.MONSTERLENGTH/2;
	            break;
	            case "down":
	            coordinates.x -= constants.MONSTERLENGTH/2;
	            coordinates.y += distance - constants.MONSTERLENGTH/2;
	            break;
	            case "left":
	            coordinates.x -= distance + constants.MONSTERLENGTH/2;
	            coordinates.y -= constants.MONSTERLENGTH/2;
	            break;
	            case "right":
	            coordinates.x += distance - constants.MONSTERLENGTH/2;
	            coordinates.y -= constants.MONSTERLENGTH/2;
	            break;
	            default:
	            throw new Error("Invalid direction provided in pathLines");
	        }
	    } else {
	        switch (pathLines[i].direction) {
	            case "up":
	                coordinates.y -= pathLines[i].distance;
	                break;
	            case "down":
	                coordinates.y += pathLines[i].distance;
	                break;
	            case "left":
	                coordinates.x -= pathLines[i].distance;
	                break;
	            case "right":
	                coordinates.x += pathLines[i].distance;
	                break;
	            default:
	                throw new Error("Invalid direction provided in pathLines");
	        }
	
	    }
	
	    return coordinates
	}
	
	// Takes in a position object with coordinates{x, y}
	// returns a block object {x, y} with block numbers
	// Handles edge cases of the block being defined at the edge (36 and 24 which are invalid in the )
	function convertToBlock(position) {
	    var xGridAmount = constants.CANVASWIDTH / constants.GRIDSIZE,
	        yGridAmount = constants.CANVASHEIGHT / constants.GRIDSIZE;
	
	    if (position.x > (xGridAmount * (constants.TOWERLENGTH/2)) ||
	        position.y > (yGridAmount * (constants.TOWERLENGTH/2))) {
	        console.log(position)
	        throw new Error("Position out of grid range");
	    }
	
	    var block = {
	        x: Math.floor(position.x / (constants.TOWERLENGTH/2)),
	        y: Math.floor(position.y / (constants.TOWERLENGTH/2))
	    };
	    // Adjusts if mouse is at end of container
	    // 36 blocks width and 24 blocks height
	    if (block.x >= xGridAmount - 1) {
	        block.x--;
	    }
	
	    if (block.y >= yGridAmount - 1) {
	        block.y--;
	    }
	
	    return block;
	}
	
	/*
	Takes in a position object (x and y coordinates)
	Returns the top left block position and topleft coordinate of the tower
	Grid blocks are in 25x25 block increments
	*/
	function convertPositionToTower(position) {
	    var towerPosition = {
	        grid: {},
	        coordinates: {},
	        side: constants.TOWERLENGTH
	    },
	        xGridAmount = constants.CANVASWIDTH / constants.GRIDSIZE,
	        yGridAmount = constants.CANVASHEIGHT / constants.GRIDSIZE;
	
	
	    towerPosition.grid = convertToBlock(position);
	
	    // Container width and height 900 and 600 px respectively
	    towerPosition.coordinates.x = (towerPosition.grid.x / xGridAmount) * constants.CANVASWIDTH;
	    towerPosition.coordinates.y = (towerPosition.grid.y / yGridAmount) * constants.CANVASHEIGHT;
	    return towerPosition;
	}
	/*
	getPathPosition inputs:
	initialPosition: position object {x, y}
	finalPosition: position object {x, y}
	fractionTravelled: decimal of how far along the path
	
	Output: position object {x, y}
	*/
	function getPathPosition(pos1, pos2, fractionTravelled) {
	    var finalPosition = {},
	        angle = Math.atan2(pos2.y - pos1.y, pos2.x - pos1.x), // the line angle (in radians) from pos1 to pos2 with respect to the origin
	        distanceFromPos1 = getPositionDifference(pos1, pos2) * fractionTravelled;
	
	    finalPosition.x = pos1.x + distanceFromPos1 * Math.cos(angle);
	    finalPosition.y = pos1.y + distanceFromPos1 * Math.sin(angle);
	
	    return finalPosition;
	}
	
	function getPositionDifference(position1, position2) {
	    return Math.sqrt(
	            Math.pow(position1.x-position2.x, 2) +
	            Math.pow(position1.y-position2.y, 2)
	    );
	}
	
	function removeClass(element, cssClass) {
	    var arrayOfClasses = element.className.split(" ");
	    for (var i = 0, j = arrayOfClasses.length; i < j; i++) {
	        if (arrayOfClasses[i] === cssClass) {
	            arrayOfClasses.splice(i, 1);
	            i--; j--;
	        }
	    }
	    element.className = arrayOfClasses.join(" ");
	}
	
	module.exports = {
	    addClass: addClass,
	    checkIfInSquare: checkIfInSquare,
	    convertToBlock: convertToBlock,
	    convertDistanceToCoordinates: convertDistanceToCoordinates,
	    convertPositionToTower: convertPositionToTower,
	    getPathPosition: getPathPosition,
	    getPositionDifference: getPositionDifference,
	    removeClass: removeClass
	}


/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = {
	    CANVASWIDTH: 900, // probably need a way to set the html canvas size from here
	    CANVASHEIGHT: 600, // probably need a way to set the html canvas size from here
	    GRIDSIZE: 25,
	    TOWERLENGTH: 50,
	    MONSTERLENGTH: 30,
	    PROJECTILELENGTH: 10,
	    TIMEBETWEENMONSTERCREATE: 1, // second
	    TIMEBETWEENLEVELS: 2, // seconds
	    FINALLEVEL: 50,
	    STARTINGGOLD: 10,
	    STARTINGLIVES: 30,
	    MESSAGEFONT: '40pt Droid Sans',
	    MESSAGECOLOR: 'red',
	    MESSAGEDURATION: 0.8,
	    MESSAGEINVALIDPLACEMENT: "Invalid Tower Placement",
	    MESSAGENOTENOUGHGOLD: "Not Enough Gold",
	}


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var towerData = __webpack_require__(5),
	    utils = __webpack_require__(6),
	    constants = __webpack_require__(7);
	
	// Projectiles are attached to monsters
	var Projectile = function(id, towerPosition) {
	    this.damage = towerData[id].projectile.damage;
	    this.totalTravelTime = towerData[id].projectile.travelTime;
	    this.sprite = towerData[id].projectile.sprite;
	    this.type = towerData[id].projectile.type;
	    this.effect = towerData[id].projectile.effect;
	    this.currentTravelTime = 0;
	    this.end = false;
	    this.initialPosition = {
	        x: towerPosition.x + (constants.TOWERLENGTH/2) - (constants.PROJECTILELENGTH/2),
	        y: towerPosition.y + (constants.TOWERLENGTH/2) - (constants.PROJECTILELENGTH/2)
	    };
	}
	
	Projectile.prototype.draw = function(monsterPosition) {
	    var fractionTravelled = this.currentTravelTime / this.totalTravelTime,
	        adjustedMonsterPosition = {
	            x: monsterPosition.x + (constants.MONSTERLENGTH/2) - (constants.PROJECTILELENGTH/2),
	            y: monsterPosition.y + (constants.MONSTERLENGTH/2) - (constants.PROJECTILELENGTH/2)
	        },
	        position = utils.getPathPosition(this.initialPosition, adjustedMonsterPosition, fractionTravelled);
	
	    // Calculate a fraction based on currentTravelTime / travelTime to get the position
	    dynamicContext.beginPath();
	    dynamicContext.fillStyle = "orange";
	    dynamicContext.rect(position.x, position.y, constants.PROJECTILELENGTH, constants.PROJECTILELENGTH);
	    dynamicContext.fill();
	    // Change this to use a sprite
	    // draw based on position here
	
	    dynamicContext.closePath();
	}
	
	Projectile.prototype.move = function(dt) {
	    this.currentTravelTime += dt;
	    if (this.currentTravelTime >= this.totalTravelTime) {
	        this.end = true;
	    }
	}
	
	module.exports = Projectile;


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	//  require Monster to gain access
	var Monster = __webpack_require__(10),
	    Tower = __webpack_require__(4),
	    towerData = __webpack_require__(5),
	    levelData = __webpack_require__(12),
	    utils = __webpack_require__(6),
	    pathCoordinates = __webpack_require__(13),
	    constants = __webpack_require__(7);
	
	var GameEngine = function() {
	    this.userGold = constants.STARTINGGOLD;
	    this.level = 0;
	    this.userLives = constants.STARTINGLIVES;
	    this.activeMonsters = []; // List of active monsters in the game
	    this.towers = []; // object of tower objects
	    this.timer = constants.TIMEBETWEENMONSTERCREATE;
	    this.nextLevelCalled = false;
	    this.monstersToCreate = 0;
	    this.gameState = "start"; // Possible values are start, lost, won, playing
	    this.gamePath = _convertPathToLines(pathCoordinates.path);
	    this.gameGrid = _initiateGrid(this.gamePath);
	}
	
	GameEngine.prototype.addMonster = function(level) {
	    level--; // Change to access correct array
	    var multiplier = (level / 2) + 1,
	        monster = new Monster(levelData[level].type, multiplier);
	    this.activeMonsters.push(monster);
	}
	
	GameEngine.prototype.addTower = function(id, position, gridPosition, goldCost) {
	    this.userGold -= goldCost;
	    var tower = new Tower(position, id);
	    this.towers.push(tower);
	    // Set gameGrid positioning
	    this.gameGrid[gridPosition.x][gridPosition.y] = {empty: false};
	    this.gameGrid[gridPosition.x + 1][gridPosition.y] = {empty: false};
	    this.gameGrid[gridPosition.x][gridPosition.y + 1] = {empty: false};
	    this.gameGrid[gridPosition.x + 1][gridPosition.y + 1] = {empty: false};
	}
	
	/*
	Takes in a position object (location of the click)
	Returns an object with information about what is at that position
	{type: null} if nothing found
	*/
	GameEngine.prototype.checkClickLocation = function(position) {
	    var element = {};
	    // Loops through activeMonsters
	    for (var i = 0; i < this.activeMonsters.length; i++) {
	        if (utils.checkIfInSquare(position, this.activeMonsters[i].position, this.activeMonsters[i].sideLength)) {
	            element.type = "monster";
	            element.index = i;
	            break;
	        }
	    }
	
	    // If nothing was found, loop through towers
	    if (element.type === undefined) {
	        for (var i = 0; i < this.towers.length; i++) {
	            if (utils.checkIfInSquare(position, this.towers[i].position, this.towers[i].position.sideLength)) {
	                element.type = "tower";
	                element.index = i;
	                break;
	            }
	        }
	    }
	
	    // If no towers or monsters found return a type of null
	    if (element.type === undefined) {
	        element.type = null;
	    }
	
	    return element;
	}
	
	GameEngine.prototype.checkGameState = function() {
	    if (this.level === constants.FINALLEVEL + 1) { // MAX level
	        this.gameState = "won";
	    } else if (this.userLives <= 0) {
	        this.gameState = "lost";
	    }
	}
	
	// method to check gold before place tower or upgrade
	GameEngine.prototype.checkGold = function(goldCost) {
	    if (goldCost <= this.userGold) {
	        return true;
	    } else {
	        return false;
	    }
	}
	
	GameEngine.prototype.gameOver = function() {
	
	}
	
	GameEngine.prototype.gameStart = function() {
	    this.gameState = "playing";
	    this.nextLevel();
	}
	
	GameEngine.prototype.gameWon = function() {
	
	}
	
	GameEngine.prototype.nextLevel = function() {
	    // Only calls the next level once - nextLevelCalled is reset on a new monster creation
	    this.monstersToCreate = levelData[this.level].amount; // this.level refers to the next level
	    this.level++;
	    this.nextLevelCalled = false;
	}
	
	/*
	placeTower handles the validation of the tower placement (position and sufficient gold)
	Takes in 3 arguments:
	towerName - string specifying what tower is being placed
	gridPosition - top left grid block of where the tower would be placed
	towerCoordinates - top left coordinate of a tower
	Returns an object with a boolean to represent whether the tower is placed and an error message if the tower was not placed
	*/
	GameEngine.prototype.placeTower = function(towerName, gridPosition, towerCoordinates) {
	    var goldCost = towerData[towerName].goldCost;
	    // Validate tower placement
	    if (this.validateTowerPlacement(gridPosition)
	    && this.checkGold(goldCost)) {
	
	        this.addTower(towerName, towerCoordinates, gridPosition, goldCost);
	        return {
	            placed: true
	        };
	    } else {
	
	        if (!this.validateTowerPlacement(gridPosition)) {
	            return {
	                placed: false,
	                message: constants.MESSAGEINVALIDPLACEMENT
	            }
	        } else {
	            return {
	                placed: false,
	                message: constants.MESSAGENOTENOUGHGOLD
	            }
	        }
	    }
	
	}
	
	GameEngine.prototype.render = function() {
	
	    if (this.gameState === "playing") {
	        // send state to the display object to render
	        dynamicContext.beginPath();
	        dynamicContext.clearRect(0, 0, dynamicCanvas.width, dynamicCanvas.height);
	
	        // Render towers first so that if monsters are larger they show above towers
	        this.towers.forEach(function(tower) {
	            tower.draw();
	        })
	
	        //  loop through list of active monsters and render them
	        //  TODO probably need to find a better way to rend them apart from random rectangle
	        this.activeMonsters.forEach(function(activeMonster) {
	            activeMonster.draw();
	
	            // Renders projectile animations that are active for each monster
	            activeMonster.projectiles.forEach(function(projectile) {
	                projectile.draw(activeMonster.position);
	            });
	        });
	
	        dynamicContext.closePath();
	
	    } else if (this.gameState === "lost") {
	        // Add render method to add thing
	        console.log("you lost lol");
	    } else if (this.gameState === "won") {
	        // Add render method to add thing
	        console.log("congrats you won");
	    }
	
	};
	
	// Changed values to be based off dt (change in time since last render)
	GameEngine.prototype.runCycle = function(dt) {
	    this.checkGameState();
	
	    if (this.gameState === "playing") {
	        // loop through active monsters and towers and run the cycle
	        // Each runCycle method returns information for the gameEngine to
	        // process (e.g. the monster died, tower changed)
	
	        // Adds monsters if there are monsters to create - creates 10 per level
	        if (this.monstersToCreate > 0) {
	            //  timer to add monsters
	            this.timer -= dt;
	            if (this.timer <= 0) {
	                this.addMonster(this.level); // send through the level number
	                this.timer = constants.TIMEBETWEENMONSTERCREATE; // Every 1 second create a new monster
	                this.monstersToCreate--;
	                this.nextLevelCalled = false;
	            }
	        }
	
	        // Calls the next level if all the monsters are dead - TODO add a delay to space out between levels
	        // Checks whether there are any monsters left and whether all the monsters have been created
	        if (this.activeMonsters.length === 0 && this.monstersToCreate === 0) {
	            if (!this.nextLevelCalled) {
	                setTimeout(function() {
	                    this.nextLevel();
	                }.bind(this), constants.TIMEBETWEENLEVELS * 1000);
	
	                this.nextLevelCalled = true;
	            }
	        } else {
	            this.activeMonsters.forEach(function(activeMonster, i, monsterArray) {
	                // moves the monsters and checks whether they get to the end of the cycle
	                // also factor to have a projectiles array - which means that each cycle for monsters they will take damage
	                var monsterStatus = activeMonster.runCycle(this.gamePath, dt);
	
	                if (!monsterStatus.alive) {
	                    if (monsterStatus.giveGold) {
	                        this.userGold += activeMonster.bounty
	                    } else {
	                        this.userLives--;
	                    }
	                    var monsterDeath = new CustomEvent("unitRemoved", {"detail": {index: i, element: "monster"}});
	                    document.dispatchEvent(monsterDeath);
	                    monsterArray.splice(i, 1);
	                }
	            }.bind(this));
	
	            // Run tower cycles here - pass in active monsters - towers only create projectiles
	            this.towers.forEach(function(tower) {
	                tower.runCycle(this.activeMonsters, dt); // Pass in active monsters and attach projectiles to them
	            }.bind(this));
	        }
	
	
	    }
	}
	
	GameEngine.prototype.sellTower = function(towerIndex) {
	    var gridPosition = utils.convertToBlock(this.towers[towerIndex].position),
	        towerDeath = new CustomEvent("unitRemoved", {"detail": {index: towerIndex, element: "tower"}});
	    // Dispatch the tower death event for the ui to update
	    document.dispatchEvent(towerDeath);
	
	    this.userGold += Math.floor(this.towers[towerIndex].totalCost * 0.75);
	    this.towers.splice(towerIndex, 1);
	
	    // Remove tower from the game grid
	    this.gameGrid[gridPosition.x][gridPosition.y].empty = true;
	    this.gameGrid[gridPosition.x + 1][gridPosition.y].empty = true;
	    this.gameGrid[gridPosition.x][gridPosition.y + 1].empty = true;
	    this.gameGrid[gridPosition.x + 1][gridPosition.y + 1].empty = true;
	    return true;
	}
	
	GameEngine.prototype.upgradeTower = function(towerIndex, upgradeName) {
	    // Check for sufficient gold
	    if (towerData[upgradeName].goldCost > this.userGold) {
	        return false;
	    } else {
	        // Create a the upgraded tower at the same position and replace that in the towers array
	        var upgradedTower = new Tower(this.towers[towerIndex].position, upgradeName);
	        this.userGold -= towerData[upgradeName].goldCost;
	        this.towers.splice(towerIndex, 1, upgradedTower);
	        return true;
	    }
	}
	
	/*
	Takes in a gridPosition object (points to the top left corner of the tower)
	Towers take up a 2x2 grid - this function checks all positions
	Returns true if the position is a valid placement for a tower
	Returns false if the position is invalid
	*/
	GameEngine.prototype.validateTowerPlacement = function(gridPosition) {
	    // Checks all 4 positions
	    var positionValid = this.gameGrid[gridPosition.x][gridPosition.y].empty
	    && this.gameGrid[gridPosition.x + 1][gridPosition.y].empty
	    && this.gameGrid[gridPosition.x][gridPosition.y + 1].empty
	    && this.gameGrid[gridPosition.x + 1][gridPosition.y + 1].empty;
	    return positionValid;
	}
	
	/*
	Input: Path - an array of objects containing coordinates where the path will run to
	Output: pathLines - an array of objects containing the startPoint (coordinates),
	        distance of the line and direction (left, right, up, down)
	*/
	function _convertPathToLines(path) {
	    var pathLines = [];
	    for (var i = 0; i < path.length - 1; i++) {
	        var line = {};
	
	        // Assume that the direction is only 4 ways
	        if (path[i+1].x - path[i].x === 0) {
	
	            if (path[i+1].y - path[i].y > 0) {
	                line.direction = "down";
	            } else {
	                line.direction = "up";
	            }
	        } else {
	            if (path[i+1].x - path[i].x === 0 > 0) {
	                line.direction = "left";
	            } else {
	                line.direction = "right";
	            }
	        }
	        line.startPoint = path[i];
	        line.distance = utils.getPositionDifference(path[i], path[i+1]);
	        pathLines.push(line);
	    }
	
	    return pathLines;
	}
	
	/*
	Converts a pathLines array (an array of objects with a startPoint,
	direction and a distance) into an array of grid blocks ()
	Note that there will be some overlap with blocks, however,
	as they are only used to set grid positions to not empty, overlap is not an issue
	*/
	function _createPathBlocks(pathLines) {
	    var blocks = [];
	    // Loops through all the pathLines and creates blocks based on that
	    for (var i = 0; i < pathLines.length; i++) {
	        // blockAmount refers to the amount of blocks that follow the path
	        var blockAmount = Math.floor(pathLines[i].distance / constants.GRIDSIZE) + 1,
	            pathDirection;
	        /* Set direction
	        x: 1 = right
	        x: -1 = left
	        y: 1 = down
	        y: -1 = up
	        Offset values help center the grid blocks (i.e. inline with the direction)
	        Side values are used to define which side the blocks are on relative to
	        the path direction (i.e. horizontally or vertically)
	        */
	        switch (pathLines[i].direction) {
	            case "up":
	                pathDirection = {
	                    x: 0,
	                    y: -1,
	                    xSide: constants.GRIDSIZE / 2,
	                    ySide: 0
	                }
	                break;
	            case "down":
	                pathDirection = {
	                    x: 0,
	                    y: 1,
	                    xSide: constants.GRIDSIZE / 2,
	                    ySide: 0
	                }
	                break;
	            case "left":
	                pathDirection = {
	                    x: -1,
	                    y: 0,
	                    xSide: 0,
	                    ySide: constants.GRIDSIZE / 2
	                }
	                break;
	            case "right":
	                pathDirection = {
	                    x: 1,
	                    y: 0,
	                    xSide: 0,
	                    ySide: constants.GRIDSIZE / 2
	                }
	                break;
	            default:
	                throw new Error("Invalid direction provided in pathLines");
	        }
	
	        /*
	        Creates block equal to double the amount of the blockAmount (the equivalent amount of blocks to the path distance)
	        blockBefore refers to blocks either to the left or top of the path
	        blockAfter refers to blocks either to the right or below of the path
	        Creates block locations and gives them offsets to their center positions (for clarity in converting to blocks)
	        */
	        for (var j = 0; j < blockAmount; j++) {
	
	            var blockBefore = {
	
	                x: pathLines[i].startPoint.x -
	                    pathDirection.xSide +
	                    (pathDirection.x * constants.GRIDSIZE * j) +
	                    (pathDirection.x * constants.GRIDSIZE / 2), // Adds a slight offset
	
	                y: pathLines[i].startPoint.y -
	                    pathDirection.ySide +
	                    (pathDirection.y * constants.GRIDSIZE * j ) +
	                    (pathDirection.y * constants.GRIDSIZE / 2) // Adds a slight offset
	
	            },
	                blockAfter = {
	                    x: pathLines[i].startPoint.x +
	                        pathDirection.xSide +
	                        (pathDirection.x * constants.GRIDSIZE * j) +
	                        (pathDirection.x * constants.GRIDSIZE / 2), // Adds a slight offset
	
	                    y: pathLines[i].startPoint.y  +
	                        pathDirection.ySide +
	                        (pathDirection.y * constants.GRIDSIZE * j) +
	                        (pathDirection.y * constants.GRIDSIZE / 2) // Adds a slight offset
	            };
	            // Edge case for when the path exits the screen (there is definitely a better way to handle this)
	            // This is such a bad solution lol.
	            if (blockBefore.x < constants.CANVASWIDTH && blockBefore.y < constants.CANVASHEIGHT) {
	                blocks.push(utils.convertToBlock(blockBefore));
	            }
	            if (blockAfter.x < constants.CANVASWIDTH && blockAfter.y < constants.CANVASHEIGHT) {
	                blocks.push(utils.convertToBlock(blockAfter));
	            }
	        }
	    }
	
	    return blocks
	}
	
	// Grid is 36 by 24
	// can be initiated by [x][y] - each block has a boolean to represent whether something is there
	function _initiateGrid(pathLines) {
	    var grid = [],
	        blocks = _createPathBlocks(pathLines),
	        xGridAmount = constants.CANVASWIDTH / constants.GRIDSIZE,
	        yGridAmount = constants.CANVASHEIGHT / constants.GRIDSIZE;
	
	    // Create the grid
	    for (var x = 0; x < xGridAmount; x++) {
	        grid[x] = [];
	        for (var y = 0; y < yGridAmount; y++) {
	            grid[x][y] = {
	                empty: true
	            };
	        }
	    }
	    // Loop through the blocks (which are on the path) and
	    blocks.forEach(function(block) {
	        grid[block.x][block.y] = {
	            empty: false
	        };
	    });
	
	    return grid;
	};
	
	module.exports = GameEngine;


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var monsterData = __webpack_require__(11),
	    utils = __webpack_require__(6),
	    constants = __webpack_require__(7);
	
	var Monster = function(id, multiplier) {
	    this.id = id;
	    this.currentHp = Math.floor(monsterData[id].maxHp * multiplier);
	    this.maxHp = Math.floor(monsterData[id].maxHp * multiplier);
	    this.baseMs = monsterData[id].baseMs; // Movement speed - "units" per second
	    this.type = monsterData[id].type;
	    this.bounty = Math.floor(monsterData[id].bounty * multiplier);
	    this.projectiles = [];
	    this.distanceTravelled = 0;
	    this.position = {}; // Initial position is defined by the path
	    this.sideLength = constants.MONSTERLENGTH;
	};
	// Method the game object uses to move monsters
	Monster.prototype.runCycle = function(gamePath, dt) {
	    var status = {};
	    this.move(gamePath, dt);
	
	    this.projectiles.forEach(function(projectile, i, projectileArray) {
	        projectile.move(dt);
	        if (projectile.end) {
	            this.updateHp(-projectile.damage);
	            projectileArray.splice(i, 1);
	        }
	    }.bind(this));
	
	    this.checkDeath();
	
	    if (this.checkDeath()) {
	        status.alive = false;
	        status.giveGold = !this.position.end; // Does not give gold if the monster reached the end
	    } else {
	        status.alive = true;
	    }
	
	    return status;
	}
	
	Monster.prototype.draw = function() {
	    dynamicContext.beginPath();
	    dynamicContext.rect(this.position.x, this.position.y, constants.MONSTERLENGTH, constants.MONSTERLENGTH);
	    dynamicContext.stroke();
	    dynamicContext.fillStyle = "red";
	    dynamicContext.fillRect(this.position.x,
	                            this.position.y + constants.MONSTERLENGTH/3,
	                            constants.MONSTERLENGTH * this.currentHp/this.maxHp,
	                            constants.MONSTERLENGTH/3);
	    dynamicContext.closePath();
	
	}
	
	Monster.prototype.checkDeath = function() {
	    return this.currentHp <= 0 || this.position.end;
	};
	
	Monster.prototype.move = function(pathLines, dt) {
	    this.distanceTravelled += this.baseMs * dt;
	    this.position = utils.convertDistanceToCoordinates(this.distanceTravelled, pathLines);
	};
	
	// Can take in a positive or negative number
	Monster.prototype.updateHp = function(hpChange) {
	    this.currentHp += hpChange;
	
	    if (this.currentHp > this.maxHp) {
	        this.currentHp = this.maxHp;
	    }
	};
	
	module.exports = Monster;


/***/ },
/* 11 */
/***/ function(module, exports) {

	module.exports = {
	    basic: {
	        maxHp: 30,
	        baseMs: 50, // pixels per second
	        type: "normal", // Change this type later
	        bounty: 3
	    },
	    fast: {
	        maxHp: 30,
	        baseMs: 100, // pixels per second
	        type: "normal", // Change this type later
	        bounty: 4
	    },
	    tank: {
	        maxHp: 60,
	        baseMs: 30,
	        type: "normal",
	        bounty: 4
	    },
	    fire: {
	        maxHp: 30,
	        baseMs: 70,
	        type: "fire",
	        bounty: 4
	    },
	    ice: {
	        maxHp: 45,
	        baseMs: 40,
	        type: "ice",
	        bounty: 5
	    },
	    light: {
	        maxHp: 20,
	        baseMs: 100,
	        type: "light",
	        bounty: 4
	    },
	    boss1: {
	        maxHp: 500,
	        baseMs: 80,
	        type: "normal",
	        bounty: 20
	    },
	    boss2: {
	        maxHp: 1500,
	        baseMs: 80,
	        type: "fire",
	        bounty: 40
	    },
	    boss3: {
	        maxHp: 2500,
	        baseMs: 100,
	        type: "fire",
	        bounty: 100
	    },
	    boss4: {
	        maxHp: 4500,
	        baseMs: 85,
	        type: "fire",
	        bounty: 40
	    },
	    boss5: {
	        maxHp: 6000,
	        baseMs: 95,
	        type: "fire",
	        bounty: 40
	    }
	};


/***/ },
/* 12 */
/***/ function(module, exports) {

	var exportData = [],
	    currentLevel,
	    monsterLookup = [
	    {
	        type: "basic",
	        amount: 10
	    },
	    {
	        type: "fire",
	        amount: 10
	    },
	    {
	        type: "ice",
	        amount: 8
	    },
	    {
	        type: "light",
	        amount: 10
	    },
	    {
	        type: "tank",
	        amount: 12
	    },
	    {
	        type: "fast",
	        amount: 15
	    }
	];
	
	for (var i = 0; i < 50; i++) {
	    switch (i) {
	        case 10:
	            currentLevel = {
	                type: "boss1",
	                amount: 4
	            };
	            break;
	        case 20:
	            currentLevel = {
	                type: "boss2",
	                amount: 2
	            };
	            break;
	        case 30:
	            currentLevel = {
	                type: "boss3",
	                amount: 2
	            };
	            break;
	        case 40:
	            currentLevel = {
	                type: "boss4",
	                amount: 3
	            };
	            break;
	        case 50:
	            currentLevel = {
	                type: "boss5",
	                amount: 3
	            };
	            break;
	        default:
	        currentLevel = monsterLookup[i%6];
	    }
	    exportData.push(currentLevel)
	}
	module.exports = exportData;


/***/ },
/* 13 */
/***/ function(module, exports) {

	module.exports = {
	    path: [
	        {x: 0, y: 500},
	        {x: 75, y: 500},
	        {x: 75, y: 100},
	        {x: 225, y: 100},
	        {x: 225, y: 500},
	        {x: 375, y: 500},
	        {x: 375, y: 100},
	        {x: 525, y: 100},
	        {x: 525, y: 500},
	        {x: 675, y: 500},
	        {x: 675, y: 100},
	        {x: 825, y: 100},
	        {x: 825, y: 500},
	        {x: 900, y: 500}
	    ]
	}


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNDE3YjhjODg4Yjg0NTk1ODhlOGEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2VudHJ5LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9iYWNrZ3JvdW5kLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NsYXNzZXMvVG93ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2dhbWVEYXRhL3Rvd2VyZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2dhbWVEYXRhL2dhbWVDb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NsYXNzZXMvUHJvamVjdGlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NsYXNzZXMvR2FtZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY2xhc3Nlcy9Nb25zdGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9nYW1lRGF0YS9tb25zdGVyZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZ2FtZURhdGEvbGV2ZWxkYXRhLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9nYW1lRGF0YS9wYXRoZGF0YS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDSkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9DQUFtQztBQUNuQztBQUNBLG9DQUFtQztBQUNuQztBQUNBLG9DQUFtQztBQUNuQztBQUNBLG9DQUFtQztBQUNuQztBQUNBLG9DQUFtQztBQUNuQztBQUNBLG9DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDMUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkIsV0FBVztBQUN0QztBQUNBLHNCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQSwwQkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBLHVCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDOztBQUV2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsd0ZBQXVGO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBNkIsZUFBZTtBQUM1QyxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF3QztBQUN4QyxVQUFTO0FBQ1Qsb0NBQW1DLFdBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0EsMEVBQXlFOztBQUV6RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMvYUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBaUQ7QUFDakQ7QUFDQSxzQ0FBcUM7QUFDckMsMENBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDdnBCQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9COzs7QUFHcEIsb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGdEQUErQztBQUMvQyw0QkFBMkIsS0FBSztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQix3QkFBdUI7QUFDdkI7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBa0M7QUFDbEMsaUNBQWdDO0FBQ2hDOztBQUVBLDBCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsMkJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzlNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQTZCO0FBQzdCLHNCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSw4QkFBNkI7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBcUQ7QUFDckQsMERBQXlEO0FBQ3pELDBEQUF5RDtBQUN6RCw4REFBNkQ7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQyxXQUFXO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbURBQWtEO0FBQ2xEO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDBEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiLFVBQVM7O0FBRVQ7O0FBRUEsTUFBSztBQUNMO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDO0FBQzVDLGlFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQSx3RUFBdUUsV0FBVyw4QkFBOEI7QUFDaEg7QUFDQTtBQUNBO0FBQ0EsY0FBYTs7QUFFYjtBQUNBO0FBQ0EseURBQXdEO0FBQ3hELGNBQWE7QUFDYjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0RBQXFELFdBQVcscUNBQXFDO0FBQ3JHO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHFCQUFxQjtBQUN4Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLGlCQUFpQjs7QUFFeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0Esd0JBQXVCLGlCQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTs7QUFFQTs7Ozs7OztBQ3BjQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBLDhDQUE2QztBQUM3QyxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDbEVBO0FBQ0E7QUFDQSxVQUFTLGFBQWE7QUFDdEIsVUFBUyxjQUFjO0FBQ3ZCLFVBQVMsY0FBYztBQUN2QixVQUFTLGVBQWU7QUFDeEIsVUFBUyxlQUFlO0FBQ3hCLFVBQVMsZUFBZTtBQUN4QixVQUFTLGVBQWU7QUFDeEIsVUFBUyxlQUFlO0FBQ3hCLFVBQVMsZUFBZTtBQUN4QixVQUFTLGVBQWU7QUFDeEIsVUFBUyxlQUFlO0FBQ3hCLFVBQVMsZUFBZTtBQUN4QixVQUFTLGVBQWU7QUFDeEIsVUFBUztBQUNUO0FBQ0EiLCJmaWxlIjoibWFpbi5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCIvc3JjL2pzL1wiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDQxN2I4Yzg4OGI4NDU5NTg4ZThhIiwiLy8gQ2FudmFzXG5yZXF1aXJlKFwiLi9iYWNrZ3JvdW5kLmpzXCIpO1xuXG4vLyBVc2VyIGludGVyYWN0aW9uIGVsZW1lbnRzXG5yZXF1aXJlKFwiLi9pbnRlcmZhY2UuanNcIik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9lbnRyeS5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBiYWNrZ3JvdW5kIGNvbnRhaW5zIHRoZSBzdGF0aWMgY2FudmFzIGVsZW1lbnRzXG52YXIgYmFja2dyb3VuZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RhdGljXCIpO1xudmFyIGJhY2tncm91bmRDb250ZXh0ID0gYmFja2dyb3VuZC5nZXRDb250ZXh0KFwiMmRcIik7XG5cbi8vIFNldHRpbmdzIGZvciB0aGUgYmFja2dyb3VuZCAtIG1vdmUgb3V0IHRvIGEgc2VwYXJhdGUgZmlsZVxudmFyIHNldHRpbmdzID0ge1xuICAgIGJhY2tncm91bmRDb2xvcjogXCIjOENEMUU2XCIsXG4gICAgcGF0aENvbG9yOiBcImdyYXlcIlxufVxuXG4vLyBEcmF3aW5nIHRoZSBiYWNrZ3JvdW5kXG5iYWNrZ3JvdW5kQ29udGV4dC5maWxsU3R5bGUgPSBzZXR0aW5ncy5iYWNrZ3JvdW5kQ29sb3I7XG5iYWNrZ3JvdW5kQ29udGV4dC5maWxsUmVjdCgwLCAwLCBiYWNrZ3JvdW5kLndpZHRoLCBiYWNrZ3JvdW5kLmhlaWdodCk7XG5cbi8qIE1haW4gcGF0aCB3aWxsIGdvIGZyb20gWzAsIDUwMF0sIFs3NSwgNTAwXSwgWzc1LCAxMDBdLCBbMjI1LCAxMDBdLCBbMjI1LCA1MDBdLCBbMzc1LCA1MDBdLCBbMzc1LCAxMDBdLCBbNTI1LCAxMDBdLCBbNTI1LCA1MDBdLCBbNjc1LCA1MDBdLCBbNjc1LCAxMDBdLCBbODI1LCAxMDBdLCBbODI1LCA1MDBdLCBbOTAwLCA1MDBdICovXG5cbi8vIERyYXdpbmcgdGhlIHBhdGggLSB3aWR0aCBvZiB0aGUgcGF0aCBpcyA1MHB4XG5iYWNrZ3JvdW5kQ29udGV4dC5maWxsU3R5bGUgPSBzZXR0aW5ncy5wYXRoQ29sb3I7XG5cbmJhY2tncm91bmRDb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4vLyBGb3IgdGhlIGJvdHRvbSBwYXJ0IG9mIHRoZSBwYXRoXG5iYWNrZ3JvdW5kQ29udGV4dC5tb3ZlVG8oMCwgNTI1KTtcblxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDEwMCwgNTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygxMDAsIDEyNSk7IC8vIFRvcFxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDIwMCwgMTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygyMDAsIDUyNSk7IC8vIEJvdHRvbVxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDQwMCwgNTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg0MDAsIDEyNSk7IC8vIFRvcFxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDUwMCwgMTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg1MDAsIDUyNSk7IC8vIEJvdHRvbVxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDcwMCwgNTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg3MDAsIDEyNSk7IC8vIFRvcFxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDgwMCwgMTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg4MDAsIDUyNSk7IC8vIEJvdHRvbVxuXG4vL01pZGRsZSBzZWN0aW9uIHRvIHRoZSBzaWRlXG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oOTAwLCA1MjUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDkwMCwgNDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg4NTAsIDQ3NSk7XG5cbi8vIEZvciB0aGUgdG9wIHBhcnQgb2YgdGhlIHBhdGhcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg4NTAsIDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg2NTAsIDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg2NTAsIDQ3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNTUwLCA0NzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDU1MCwgNzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDM1MCwgNzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDM1MCwgNDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygyNTAsIDQ3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oMjUwLCA3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNTAsIDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg1MCwgNDc1KTtcblxuLy8gRW5kIHNlY3Rpb25cbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygwLCA0NzUpO1xuXG5iYWNrZ3JvdW5kQ29udGV4dC5maWxsKCk7XG4vLyBiYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oKTtcblxuLy8gZHJhdyBhIGdyaWQgKGZvciBkZXZlbG9wbWVudCBwdXJwb3NlcylcbnZhciB3aWR0aCA9IDkwMCwgaGVpZ2h0ID0gNjAwO1xuLy8gZHJhdyB2ZXJ0aWNhbCBsaW5lc1xuZm9yICh2YXIgaSA9IDA7IGkgPCB3aWR0aDsgaSArPSAyNSkge1xuICAgIGJhY2tncm91bmRDb250ZXh0Lm1vdmVUbyhpLCAwKTtcbiAgICBiYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oaSwgaGVpZ2h0KTtcbiAgICBiYWNrZ3JvdW5kQ29udGV4dC5zdHJva2UoKTtcbn1cbi8vIGRyYXcgaG9yaXpvbnRhbCBsaW5lc1xuZm9yICh2YXIgaSA9IDA7IGkgPCBoZWlnaHQ7IGkgKz0gMjUpIHtcbiAgICBiYWNrZ3JvdW5kQ29udGV4dC5tb3ZlVG8oMCwgaSk7XG4gICAgYmFja2dyb3VuZENvbnRleHQubGluZVRvKHdpZHRoLCBpKTtcbiAgICBiYWNrZ3JvdW5kQ29udGV4dC5zdHJva2UoKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2JhY2tncm91bmQuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gSW5pdGlhdGUgYWxsIHRoZSBjb21wb25lbnRzXG52YXIgVG93ZXIgPSByZXF1aXJlKFwiLi9jbGFzc2VzL1Rvd2VyLmpzXCIpLFxuICAgIEdhbWVFbmdpbmUgPSByZXF1aXJlKFwiLi9jbGFzc2VzL0dhbWUuanNcIik7XG5cbi8vIEltcG9ydCBhbmQgZGVjbGFyZSB1dGlsaXR5IGZ1bmN0aW9uc1xudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG5cbnZhciBjb25zdGFudHMgPSByZXF1aXJlKFwiLi9nYW1lRGF0YS9nYW1lQ29uc3RhbnRzLmpzXCIpLFxuICAgIHRvd2VyRGF0YSA9IHJlcXVpcmUoXCIuL2dhbWVEYXRhL3Rvd2VyZGF0YS5qc1wiKTtcblxuLy8gQ2FjaGUgcmV1c2VkIERPTSBlbGVtZW50c1xudmFyIGluZm9OYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbmZvLW5hbWVcIiksXG4gICAgaW5mb0ljb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImluZm8taWNvblwiKSxcbiAgICBpbmZvQm94MSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5mby1ib3gtMVwiKSxcbiAgICBpbmZvQm94MiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5mby1ib3gtMlwiKSxcbiAgICBpbmZvQm94MyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5mby1ib3gtM1wiKSxcbiAgICBpbmZvQm94NCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5mby1ib3gtNFwiKSxcbiAgICBsZXZlbEluZm8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxldmVsXCIpLFxuICAgIGdvbGRJbmZvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJnb2xkXCIpLFxuICAgIGxpdmVzSW5mbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibGl2ZXNcIiksXG4gICAgdG93ZXJDYXJkcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJ0b3dlci1jYXJkXCIpLFxuICAgIHRvd2VyQ2FyZExpc3QgPSBbXTtcblxuLy8gQ29udmVydCBmcm9tIG5vZGVsaXN0IHRvIGFycmF5XG50b3dlckNhcmRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodG93ZXJDYXJkcyk7XG5cbi8qXG5DcmVhdGUgc3RhdGUgdmFyaWFibGVzIC0gVGhlc2UgYXJlIG1vZGlmaWVkIG9uIHVzZXIgaW50ZXJhY3Rpb24gZXZlbnRzXG5TdGF0ZSB2YXJpYWJsZXNcbmFjdGl2ZUNhbnZhc0VsZW1lbnQgLSBDaGFuZ2VkIG9uIGEgbW91c2UgY2xpY2sgZXZlbnQgb24gYSBtb25zdGVyLCB0b3dlciBvciBub3RoaW5nXG5hY3RpdmVUb3dlclNlbGVjdGVkIC0gVGhlIG5hbWUgb2YgdGhlIHRvd2VyIHRoYXQgaXMgYmVpbmcgcGxhY2VkIGJ5IHRoZSB1c2VyXG5hY3RpdmVNZXNzYWdlIC0gTWVzc2FnZSBkaXNwbGF5ZWQgaW4gdGhlIGNhbnZhcyAoY2FuIGJlIHVzZWQgZm9yIG5ldyBsZXZlbHMsIGludmFsaWQgdG93ZXIgcGxhY2VtZW50cywgZXRjKVxuY2FudmFzTW91c2VQb3NpdGlvbiAtXG4gICAgb25DYW52YXMgLSBib29sZWFuIHRvIHJlcHJlc2VudCB3aGV0aGVyIHRoZSBtb3VzZSBpcyBjdXJyZW50bHkgb24gdGhlIGNhbnZhc1xuICAgIHRvd2VyUG9zaXRpb24gLSBvYmplY3Qgd2l0aCBhIGdyaWQgdmFsdWUgYW5kIGNvb3JkaW5hdGUgdmFsdWUgYW5kIHNpZGVzXG4gICAgICAgIGdyaWQgLSB0aGUgdG9wIGxlZnQgYmxvY2sgb2YgdGhlIHRvd2VyIGJlaW5nIHBsYWNlZCAtIHRvd2VycyBhcmUgYSAyeDIgZ3JpZFxuICAgICAgICBjb29yZGluYXRlIC0gdGhlIHRvcCBsZWZ0IGNvcm5lciBjb29yZGluYXRlXG4gICAgICAgIHNpZGVzIC0gNTAgcHhcbiAgICBtb3VzZVBvc2l0aW9uIC0gdGhlIGN1cnJlbnQgbW91c2UgY29vcmRpbmF0ZXNcbiovXG5cbnZhciBhY3RpdmVDYW52YXNFbGVtZW50ID0ge3R5cGU6IG51bGx9LFxuICAgIGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPSBudWxsLFxuICAgIGFjdGl2ZU1lc3NhZ2UgPSB7bWVzc2FnZTogbnVsbH0sXG4gICAgY2FudmFzTW91c2VQb3NpdGlvbiA9IHtcbiAgICAgICAgb25DYW52YXM6IGZhbHNlLFxuICAgICAgICB0b3dlclBvc2l0aW9uOiB7fSxcbiAgICAgICAgbW91c2VQb3NpdGlvbjoge31cbiAgICB9O1xuXG4vLyAgY3JlYXRlcyBnbG9iYWwgdmFyaWFibGVzXG5nYW1lID0gbmV3IEdhbWVFbmdpbmU7IC8vIFByaXZhdGl6ZSB0aGlzIGxhdGVyXG5keW5hbWljQ2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2R5bmFtaWMnKTtcbmR5bmFtaWNDb250ZXh0ID0gZHluYW1pY0NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4vLyBEZWNsYXJlIHRoZSBnYW1lIGxvb3BcbnZhciBsYXN0VGltZTtcbmZ1bmN0aW9uIGdhbWVMb29wKCkge1xuICAgIHZhciBub3cgPSBEYXRlLm5vdygpLFxuICAgICAgICBkdCA9IChub3cgLSBsYXN0VGltZSkgLyAxMDAwLjA7IC8vIENvbnZlcnQgdG8gc2Vjb25kc1xuXG4gICAgZ2FtZS5ydW5DeWNsZShkdCk7XG5cbiAgICBsYXN0VGltZSA9IG5vdztcbiAgICAvLyBSZW5kZXJzIG1ldGhvZHMgYmFzZWQgb24gc3RhdGUgdmFyaWFibGVzXG4gICAgZ2FtZS5yZW5kZXIoKTtcbiAgICB1cGRhdGVHYW1lRGVwZW5kZW50SW5mb3JtYXRpb24oKTtcbiAgICByZW5kZXJUb3dlclBsYWNlbWVudCgpO1xuICAgIHJlbmRlck1lc3NhZ2UoZHQpO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShnYW1lTG9vcCk7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PSBSZW5kZXIgZnVuY3Rpb25zID09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuZnVuY3Rpb24gdXBkYXRlR2FtZURlcGVuZGVudEluZm9ybWF0aW9uKCkge1xuICAgIGxpdmVzSW5mby5pbm5lckhUTUwgPSBnYW1lLnVzZXJMaXZlcztcbiAgICBnb2xkSW5mby5pbm5lckhUTUwgPSBnYW1lLnVzZXJHb2xkO1xuICAgIGxldmVsSW5mby5pbm5lckhUTUwgPSBnYW1lLmxldmVsO1xuXG4gICAgaWYgKGFjdGl2ZUNhbnZhc0VsZW1lbnQudHlwZSA9PT0gXCJtb25zdGVyXCIpIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtb25zdGVySHBcIikuaW5uZXJIVE1MID0gZ2FtZS5hY3RpdmVNb25zdGVyc1thY3RpdmVDYW52YXNFbGVtZW50LmluZGV4XS5jdXJyZW50SHA7XG4gICAgfSBlbHNlIGlmIChhY3RpdmVDYW52YXNFbGVtZW50LnR5cGUgPT09IFwidG93ZXJcIikge1xuICAgICAgICAvLyBBZGQgYW55IHJlbGV2YW50IHRvd2VyIGluZm9ybWF0aW9uIGhlcmVcbiAgICB9XG59XG5cbi8vIE1vdmVkIHRoaXMgb3V0c2lkZSBvZiB0aGUgZ2FtZUxvb3AsIHdpbGwgb25seSB1cGRhdGUgdGhlIHJlbGV2YW50IGRhdGEgd2hlbiBuZWNlc3NhcnlcbmZ1bmN0aW9uIHVwZGF0ZUluZm9ybWF0aW9uUGFuZWwoKSB7XG4gICAgaWYgKGFjdGl2ZUNhbnZhc0VsZW1lbnQudHlwZSA9PT0gXCJtb25zdGVyXCIpIHtcbiAgICAgICAgcmVuZGVyTW9uc3RlckluZm9ybWF0aW9uKGFjdGl2ZUNhbnZhc0VsZW1lbnQuaW5kZXgpO1xuICAgIH0gZWxzZSBpZiAoYWN0aXZlQ2FudmFzRWxlbWVudC50eXBlID09PSBcInRvd2VyXCIpIHtcbiAgICAgICAgcmVuZGVyVG93ZXJJbmZvcm1hdGlvbihhY3RpdmVDYW52YXNFbGVtZW50LmluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZW5kZXJEZWZhdWx0SW5mb3JtYXRpb24oKTtcbiAgICB9XG59XG5cbi8vIElEIHJlZmVycyB0byB0aGUgdHlwZSBvZiBtb25zdGVyIGFuZCBpbmRleCBpcyB0aGUgaW5kZXggb2YgdGhlIGFjdGl2ZSBtb25zdGVyIGluIHRoZSBhY3RpdmUgbW9uc3RlcidzIGFycmF5XG5mdW5jdGlvbiByZW5kZXJNb25zdGVySW5mb3JtYXRpb24oaW5kZXgpIHtcbiAgICB2YXIgY3VycmVudEhwID0gZ2FtZS5hY3RpdmVNb25zdGVyc1tpbmRleF0uY3VycmVudEhwLFxuICAgICAgICBtYXhIcCA9IGdhbWUuYWN0aXZlTW9uc3RlcnNbaW5kZXhdLm1heEhwLFxuICAgICAgICB0eXBlID0gZ2FtZS5hY3RpdmVNb25zdGVyc1tpbmRleF0udHlwZSxcbiAgICAgICAgaWQgPSBnYW1lLmFjdGl2ZU1vbnN0ZXJzW2luZGV4XS5pZDtcblxuICAgIGluZm9OYW1lLmlubmVySFRNTCA9IGlkO1xuICAgIC8vIENoYW5nZSBpY29uIHRvIGFjdGl2ZSBtb25zdGVyIC0gdXNlIGEgc3ByaXRlXG4gICAgaW5mb0JveDEuaW5uZXJIVE1MID0gXCJIUDogPHNwYW4gaWQ9J21vbnN0ZXJIcCc+XCIgKyBjdXJyZW50SHAgKyBcIjwvc3Bhbj4gLyBcIiArIG1heEhwO1xuICAgIGluZm9Cb3gyLmlubmVySFRNTCA9IFwiVHlwZTogXCIgKyB0eXBlO1xuICAgIGluZm9Cb3gzLmlubmVySFRNTCA9IFwiU3RyZW5ndGhzOiBBbGwgc29ydHMgbWF0ZVwiIDtcbiAgICBpbmZvQm94NC5pbm5lckhUTUwgPSBcIldlYWtuZXNzZXM6IER1Y2tzXCIgO1xufVxuXG4vLyBJRCByZWZlcnMgdG8gdGhlIHR5cGUgb2YgdG93ZXIgYW5kIGluZGV4IGlzIHRoZSBpbmRleCBvZiB0aGUgYWN0aXZlIHRvd2VyIGluIHRoZSBhY3RpdmUgdG93ZXIncyBhcnJheVxuLy8gVE9ETyBhZGQgbnVtYmVyIG9mIHRhcmdldHJzXG5mdW5jdGlvbiByZW5kZXJUb3dlckluZm9ybWF0aW9uKGluZGV4KSB7XG4gICAgdmFyIGlkID0gZ2FtZS50b3dlcnNbaW5kZXhdLmlkLFxuICAgICAgICBkYW1hZ2UgPSB0b3dlckRhdGFbaWRdLnByb2plY3RpbGUuZGFtYWdlLFxuICAgICAgICB0eXBlID0gdG93ZXJEYXRhW2lkXS5wcm9qZWN0aWxlLnR5cGUsXG4gICAgICAgIGVmZmVjdCA9IFwiXCIsXG4gICAgICAgIHJhbmdlID0gZ2FtZS50b3dlcnNbaW5kZXhdLnJhbmdlLFxuICAgICAgICBzcGVlZCA9IGdhbWUudG93ZXJzW2luZGV4XS5hdHRhY2tTcGVlZCxcbiAgICAgICAgdXBncmFkZUF2YWlsYWJsZSA9IHRvd2VyRGF0YVtpZF0udXBncmFkZS5sZW5ndGggIT09IDA7XG5cbiAgICBpZiAodG93ZXJEYXRhW2lkXS5wcm9qZWN0aWxlLmVmZmVjdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGVmZmVjdCA9IFwiTm9uZVwiXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdG93ZXJEYXRhW2lkXS5wcm9qZWN0aWxlLmVmZmVjdHMuZm9yRWFjaChmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlZmZlY3QgKz0gZSArIFwiIFwiO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBpbmZvTmFtZS5pbm5lckhUTUwgPSBpZDtcbiAgICAvLyBDaGFuZ2UgaWNvbiB0byB0b3dlciBtb25zdGVyIC0gdXNlIGEgc3ByaXRlXG4gICAgaW5mb0JveDEuaW5uZXJIVE1MID0gXCJEYW1hZ2U6IFwiICsgZGFtYWdlICsgXCIgPGJyPlJhbmdlOiBcIiArIHJhbmdlICsgXCIgPGJyPkVmZmVjdDogXCIgKyBlZmZlY3Q7XG4gICAgaW5mb0JveDIuaW5uZXJIVE1MID0gXCJBdHRhY2sgU3BlZWQ6IFwiICsgc3BlZWQgKyBcIiA8YnI+VHlwZTogXCIgKyB0eXBlO1xuICAgIGluZm9Cb3gzLmlubmVySFRNTCA9IHVwZ3JhZGVBdmFpbGFibGUgPyBcIjxhIGNsYXNzPSd3YXZlcy1lZmZlY3Qgd2F2ZXMtbGlnaHQgYnRuIHJlZCcgaWQ9J3VwZ3JhZGVCdXR0b24nPlVwZ3JhZGU8L2E+XCIgOiBcIlwiO1xuICAgIGluZm9Cb3g0LmlubmVySFRNTCA9IFwiPGEgY2xhc3M9J3dhdmVzLWVmZmVjdCB3YXZlcy1saWdodCBidG4gcmVkJyBpZD0nc2VsbEJ1dHRvbic+U2VsbDwvYT5cIjtcbn1cblxuZnVuY3Rpb24gcmVuZGVyRGVmYXVsdEluZm9ybWF0aW9uKCkge1xuICAgIGluZm9OYW1lLmlubmVySFRNTCA9IFwiQXdlc29tZSBURFwiO1xuICAgIC8vIENoYW5nZSBpY29uIHRvIGRlZmF1bHQgaW1hZ2UgLSB1c2UgYSBzcHJpdGVcbiAgICBpbmZvQm94MS5pbm5lckhUTUwgPSBcIlRoaXMgaXMgc29tZSB0ZXh0XCI7XG4gICAgaW5mb0JveDIuaW5uZXJIVE1MID0gXCJUaGlzIGlzIGRpZmZlcmVudCB0ZXh0XCI7XG4gICAgaW5mb0JveDMuaW5uZXJIVE1MID0gXCJUaGlzIGlzID8/PyB0ZXh0XCIgO1xuICAgIGluZm9Cb3g0LmlubmVySFRNTCA9IFwiVGhpcyAxMjMxMjQxMjM1XCIgO1xufVxuXG5mdW5jdGlvbiByZW5kZXJNZXNzYWdlKGR0KSB7XG4gICAgaWYgKGFjdGl2ZU1lc3NhZ2UubWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZHluYW1pY0NvbnRleHQuZ2xvYmFsQWxwaGEgPSBhY3RpdmVNZXNzYWdlLnRpbWVyID4gMCA/IGFjdGl2ZU1lc3NhZ2UudGltZXIgOiAwOyAvLyBTZXRzIHRyYW5zcGFyZW5jeSB0byAwIGlmIGEgbmVnYXRpdmUgbnVtYmVyXG4gICAgICAgIGR5bmFtaWNDb250ZXh0LmZvbnQgPSBjb25zdGFudHMuTUVTU0FHRUZPTlQ7XG4gICAgICAgIGR5bmFtaWNDb250ZXh0LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIGR5bmFtaWNDb250ZXh0LmZpbGxTdHlsZSA9IGNvbnN0YW50cy5NRVNTQUdFQ09MT1I7XG4gICAgICAgIGR5bmFtaWNDb250ZXh0LmZpbGxUZXh0KGFjdGl2ZU1lc3NhZ2UubWVzc2FnZSwgY29uc3RhbnRzLkNBTlZBU1dJRFRIIC8gMiwgNTApO1xuICAgICAgICBkeW5hbWljQ29udGV4dC5nbG9iYWxBbHBoYSA9IDE7XG5cbiAgICAgICAgaWYgKGFjdGl2ZU1lc3NhZ2UudGltZXIgPD0gMCkge1xuICAgICAgICAgICAgYWN0aXZlTWVzc2FnZSA9IHttZXNzYWdlOiBudWxsfTsgLy8gUmVzZXQgbWVzc2FnZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWN0aXZlTWVzc2FnZS50aW1lciAtPSBkdDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyVG93ZXJQbGFjZW1lbnQoKSB7XG4gICAgaWYgKGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPT09IG51bGwgfHxcbiAgICAgICAgIWNhbnZhc01vdXNlUG9zaXRpb24ub25DYW52YXMpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgfTtcblxuICAgIHZhciBjb29yZGluYXRlcyA9IGNhbnZhc01vdXNlUG9zaXRpb24udG93ZXJQb3NpdGlvbi5jb29yZGluYXRlcztcbiAgICBkeW5hbWljQ29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBkeW5hbWljQ29udGV4dC5nbG9iYWxBbHBoYSA9IDAuNTtcblxuICAgIC8vIERyYXcgZ3JpZCB2YWxpZGF0aW9uIHBsYWNlbWVudFxuICAgIGlmIChnYW1lLnZhbGlkYXRlVG93ZXJQbGFjZW1lbnQoY2FudmFzTW91c2VQb3NpdGlvbi50b3dlclBvc2l0aW9uLmdyaWQpKSB7XG4gICAgICAgIGR5bmFtaWNDb250ZXh0LmZpbGxTdHlsZSA9IFwiZ3JlZW5cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkeW5hbWljQ29udGV4dC5maWxsU3R5bGUgPSBcInJlZFwiO1xuICAgIH1cbiAgICBkeW5hbWljQ29udGV4dC5maWxsUmVjdChjb29yZGluYXRlcy54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzLnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRzLlRPV0VSTEVOR1RILFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50cy5UT1dFUkxFTkdUSFxuICAgICApO1xuXG4gICAgIC8vIERyYXcgdG93ZXJcbiAgICBkeW5hbWljQ29udGV4dC5nbG9iYWxBbHBoYSA9IDAuNztcbiAgICBkeW5hbWljQ29udGV4dC5hcmMoY29vcmRpbmF0ZXMueCArIGNvbnN0YW50cy5UT1dFUkxFTkdUSCAvIDIsXG4gICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzLnkgKyBjb25zdGFudHMuVE9XRVJMRU5HVEggLyAyLFxuICAgICAgICAgICAgICAgICAgICAgICBjb25zdGFudHMuVE9XRVJMRU5HVEggKiAwLjYsXG4gICAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgICAgIDIgKiBNYXRoLlBJLFxuICAgICAgICAgICAgICAgICAgICAgICBmYWxzZVxuICAgICApO1xuICAgIGR5bmFtaWNDb250ZXh0LmZpbGxTdHlsZSA9ICdncmF5JztcbiAgICBkeW5hbWljQ29udGV4dC5maWxsKCk7XG5cbiAgICBkeW5hbWljQ29udGV4dC5nbG9iYWxBbHBoYSA9IDE7XG4gICAgZHluYW1pY0NvbnRleHQuY2xvc2VQYXRoKCk7XG59XG5cbi8qID09PT09PT09PT09PT09PT0gVUkgRXZlbnQgTGlzdGVuZXJzID09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibWFpbk1vZGFsXCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBtb2RhbENsaWNrKTtcblxuLypcblRoZXNlIGV2ZW50IGxpc3RlbmVycyBjb250cm9sIHRoZSBhcHBsaWNhdGlvbiBieSBpbnRlcmFjdGluZyB3aXRoIHRoZSBnYW1lXG5vYmplY3QgYW5kIGJ5IGNoYW5naW5nIHRoZSBzdGF0ZSB2YXJpYWJsZXMgKHdoaWNoIHRoZSByZW5kZXIgZnVuY3Rpb25zIHVzZVxudG8gcmVhZClcbiovXG50b3dlckNhcmRzLmZvckVhY2goZnVuY3Rpb24odG93ZXJDYXJkLCBpKSB7XG4gICAgdG93ZXJDYXJkTGlzdC5wdXNoKHRvd2VyQ2FyZC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRvd2VyXCIpKTtcbiAgICB0b3dlckNhcmQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRvd2VyQ2FyZENsaWNrKTtcbn0pO1xuXG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImR5bmFtaWNcIikub25tb3VzZW1vdmUgPSBvbkNhbnZhc01vdXNlTW92ZW1lbnQ7XG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImR5bmFtaWNcIikuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGNhbnZhc0NsaWNrKTtcblxuZG9jdW1lbnQub25rZXlkb3duID0gZnVuY3Rpb24oZSkge1xuICAgIGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgIGNhbmNlbFRvd2VyUGxhY2VtZW50KCk7XG4gICAgfVxufVxuXG4vLyB1cGRhdGVzIGFjdGl2ZUNhbnZhc0VsZW1lbnQgd2hlbiBtb25zdGVyIGRlYXRoIG9yIHRvd2VyIHJlbW92ZWQgYWZmZWN0cyB0aGUgY3VycmVudCBzZWxlY3RlZCB0YXJnZXRcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1bml0UmVtb3ZlZFwiLCBmdW5jdGlvbihlKSB7XG4gICAgLy8gVXBkYXRlcyBpZiB0aGUgYWN0aXZlIGVsZW1lbnQgaXMgdGhlIHNhbWUgYXMgdGhlIHR5cGUgb2YgdW5pdCByZW1vdmVkXG4gICAgaWYgKGFjdGl2ZUNhbnZhc0VsZW1lbnQudHlwZSA9PT0gZS5kZXRhaWwuZWxlbWVudCkge1xuICAgICAgICBpZiAoZS5kZXRhaWwuaW5kZXggPCBhY3RpdmVDYW52YXNFbGVtZW50LmluZGV4KSB7XG4gICAgICAgICAgICBhY3RpdmVDYW52YXNFbGVtZW50LmluZGV4LS07IC8vIFVwZGF0ZSBwb3NpdGlvbmluZyBpbiBlbGVtZW50XG4gICAgICAgIH0gZWxzZSBpZiAoZS5kZXRhaWwuaW5kZXggPT09IGFjdGl2ZUNhbnZhc0VsZW1lbnQuaW5kZXgpIHtcbiAgICAgICAgICAgIGFjdGl2ZUNhbnZhc0VsZW1lbnQgPSB7dHlwZTogbnVsbH0gLy8gUmVzZXRcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVJbmZvcm1hdGlvblBhbmVsKCk7XG4gICAgfVxufSk7XG5cbi8vIEFkZHMgZXZlbnQgbGlzdGVuZXJzIG9ubHkgdG8gdGhlIGluZm8gYm94XG5kb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwic2lkZS1zZWN0aW9uIGxlZnRcIilbMF0uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoYWN0aXZlQ2FudmFzRWxlbWVudC50eXBlID09PSBcInRvd2VyXCIpIHtcbiAgICAgICAgaWYgKGUudGFyZ2V0LmlkID09PSBcInVwZ3JhZGVCdXR0b25cIikge1xuICAgICAgICAgICAgc2hvd1VwZ3JhZGVPcHRpb25zKGFjdGl2ZUNhbnZhc0VsZW1lbnQuaW5kZXgpO1xuICAgICAgICB9IGVsc2UgaWYgKGUudGFyZ2V0LmlkID09PSBcInNlbGxCdXR0b25cIikge1xuICAgICAgICAgICAgc2VsbFRvd2VyKCk7XG4gICAgICAgIH1cbiAgICB9XG59KVxuXG4vKiA9PT09PT09PT09PT09PT09PT09IFVJIEZ1bmN0aW9ucyA9PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5mdW5jdGlvbiBtb2RhbENsaWNrKGUpIHtcbiAgICB2YXIgY2xpY2tUYXJnZXQgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWFjdGlvblwiKTtcblxuICAgIHN3aXRjaCAoY2xpY2tUYXJnZXQpIHtcbiAgICAgICAgY2FzZSBcInN0YXJ0XCI6XG4gICAgICAgICAgICBzdGFydEdhbWUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW5mb3JtYXRpb25cIjpcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic2hvdyBpbmZvcm1hdGlvbiBjb250YWluZXIgaGVyZVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidXBncmFkZVwiOlxuICAgICAgICAgICAgdmFyIHVwZ3JhZGVOYW1lID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS11cGdyYWRlbmFtZVwiKTtcbiAgICAgICAgICAgIHVwZ3JhZGVUb3dlcihhY3RpdmVDYW52YXNFbGVtZW50LmluZGV4LCB1cGdyYWRlTmFtZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJtYWluTW9kYWxcIikuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJtb2RhbC1iYWNrZ3JvdW5kXCIpWzBdLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbn1cblxuZnVuY3Rpb24gc3RhcnRHYW1lKCkge1xuICAgIGdhbWUuZ2FtZVN0YXJ0KCk7XG4gICAgLy8gU2V0cyB1cCBnYW1lIGxvb3AgYW5kIHJlbmRlciBsb29wXG4gICAgbGFzdFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGdhbWVMb29wKCk7XG59XG5cbi8qIENsaWNrIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSB0b3dlciBjYXJkc1xuVXNlZCB0byBjb250cm9sIHdoYXQgdG93ZXIgaXMgYmVpbmcgYWN0aXZlbHkgcGxhY2VkIG9uIHRoZSBjYW52YXNcbjQgcG9zc2libGUgZmxvd3MgYmFzZWQgb24gdGhlIHN0YXRlIG9mIHRoZSBpbnRlcmZhY2VcbjEpIFRoZSB0b3dlciB0aGF0IHdhcyBjbGlja2VkIGlzIGN1cnJlbnRseSBkaXNhYmxlZDpcbiAgICAtPiBmdW5jdGlvbiByZXR1cm5zXG4yKSBObyB0b3dlcnMgYXJlIGFjdGl2ZWx5IGJlaW5nIHBsYWNlZFxuICAgIC0+IHRoZSBjbGlja2VkIHRvd2VyIGNhcmQgbm93IGJlY29tZXMgdGhlIGFjdGl2ZSB0b3dlciBiZWluZyBwbGFjZWRcbjMpIFRoZSBjbGlja2VkIHRvd2VyIGlzIHRoZSBzYW1lIGFzIHRoZSB0b3dlciBhY3RpdmVseSBiZWluZyBwbGFjZWRcbiAgICAtPiB0aGUgc3RhdGUgaXMgcmVzZXQgc28gdGhhdCBubyB0b3dlcnMgYXJlIGFjdGl2ZWx5IGJlaW5nIHBsYWNlZFxuNCkgVGhlIGNsaWNrZWQgdG93ZXIgaXMgZGlmZmVyZW50IGZyb20gdGhlIHRvd2VyIGFjdGl2ZWx5IGJlaW5nIHBsYWNlZFxuICAgIC0+IHRoZSBzdGF0ZSBpcyBjaGFuZ2VkIHRvIHRoZSBjbGlja2VkIHRvd2VyIGJlY29taW5nIHRoZSBhY3RpdmUgdG93ZXJcbiovXG5mdW5jdGlvbiB0b3dlckNhcmRDbGljaygpIHtcblxuICAgIHZhciB0b3dlck5hbWUgPSB0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtdG93ZXJcIiksXG4gICAgICAgIG9sZFRvd2VySW5kZXggPSB0b3dlckNhcmRMaXN0LmluZGV4T2YoYWN0aXZlVG93ZXJTZWxlY3RlZCksXG4gICAgICAgIG5ld1Rvd2VySW5kZXggPSB0b3dlckNhcmRMaXN0LmluZGV4T2YodG93ZXJOYW1lKTtcblxuICAgIGlmICgvZGlzYWJsZWQvaS50ZXN0KHRoaXMuY2xhc3NOYW1lKSkge1xuICAgICAgICByZXR1cm47XG5cbiAgICB9IGVsc2UgaWYgKGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPT09IG51bGwpIHtcbiAgICAgICAgYWN0aXZlVG93ZXJTZWxlY3RlZCA9IHRvd2VyTmFtZTtcbiAgICAgICAgdXRpbHMuYWRkQ2xhc3ModG93ZXJDYXJkc1tuZXdUb3dlckluZGV4XSwgXCJhY3RpdmVcIik7XG4gICAgICAgIGNhbnZhc01vdXNlUG9zaXRpb24ub25DYW52YXMgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPT09IHRvd2VyTmFtZSkge1xuICAgICAgICBjYW5jZWxUb3dlclBsYWNlbWVudCgpO1xuICAgICAgICBjYW52YXNNb3VzZVBvc2l0aW9uLm9uQ2FudmFzID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdXRpbHMucmVtb3ZlQ2xhc3ModG93ZXJDYXJkc1tvbGRUb3dlckluZGV4XSwgXCJhY3RpdmVcIik7XG4gICAgICAgIGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPSB0b3dlck5hbWU7XG4gICAgICAgIHV0aWxzLmFkZENsYXNzKHRvd2VyQ2FyZHNbbmV3VG93ZXJJbmRleF0sIFwiYWN0aXZlXCIpO1xuICAgICAgICBjYW52YXNNb3VzZVBvc2l0aW9uLm9uQ2FudmFzID0gZmFsc2U7XG4gICAgfVxufVxuXG4vKlxuQ2FsbGVkIGZyb20gdG93ZXJDYXJkQ2xpY2sgKHdoZW4gY2xpY2tpbmcgdGhlIGFjdGl2ZSB0b3dlciBjYXJkKSBhbmQgb24gYW4gZXNjYXBlIGtleSBwcmVzc1xuUmVzZXRzIHRoZSBhY3RpdmUgdG93ZXIgcGxhY2VtZW50IHN0YXRlIHRvIG51bGxcbiovXG5mdW5jdGlvbiBjYW5jZWxUb3dlclBsYWNlbWVudCgpIHtcbiAgICB1dGlscy5yZW1vdmVDbGFzcyh0b3dlckNhcmRzW3Rvd2VyQ2FyZExpc3QuaW5kZXhPZihhY3RpdmVUb3dlclNlbGVjdGVkKV0sIFwiYWN0aXZlXCIpO1xuICAgIGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPSBudWxsO1xufVxuXG4vKiBNb3VzZSBtb3ZlIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSBjYW52YXNcbklmIHRoZSBhY3RpdmUgdG93ZXIgc2VsZWN0ZWQgc3RhdGUgKGEgdG93ZXIgaXMgYmVpbmcgcGxhY2VkIGJ5IHRoZSB1c2VyKTpcbiAgICAtPiB1cGRhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBtb3VzZSBvbiB0aGUgY2FudmFzICh1c2VkIGJ5IHRoZSByZW5kZXJUb3dlclBsYWNlbWVudCBmdW5jdGlvbilcbm90aGVyd2lzZTpcbiAgICAtPiBkbyBub3RoaW5nXG4qL1xuZnVuY3Rpb24gb25DYW52YXNNb3VzZU1vdmVtZW50KGUpIHtcbiAgICBpZiAoYWN0aXZlVG93ZXJTZWxlY3RlZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm5cbiAgICB9O1xuXG4gICAgdmFyIGNhbnZhc0NvbnRhaW5lciA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIHBvc2l0aW9uID0ge307XG5cbiAgICBwb3NpdGlvbi54ID0gZS5jbGllbnRYIC0gY2FudmFzQ29udGFpbmVyLmxlZnQ7XG4gICAgcG9zaXRpb24ueSA9IGUuY2xpZW50WSAtIGNhbnZhc0NvbnRhaW5lci50b3A7XG4gICAgY2FudmFzTW91c2VQb3NpdGlvbi5tb3VzZVBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgY2FudmFzTW91c2VQb3NpdGlvbi50b3dlclBvc2l0aW9uID0gdXRpbHMuY29udmVydFBvc2l0aW9uVG9Ub3dlcihwb3NpdGlvbik7XG4gICAgY2FudmFzTW91c2VQb3NpdGlvbi5vbkNhbnZhcyA9IHRydWU7XG59O1xuXG5cbi8qIENsaWNrIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSBjYW52YXNcbkhhbmRsZXMgdHdvIHBvc3NpYmxlIGNhbnZhcyBjbGljayBzY2VuYXJpb3NcbjEpIEEgdG93ZXIgaXMgc2VsZWN0ZWQgYW5kIGlzIGFjdGl2ZWx5IGJlaW5nIHBsYWNlZFxuICAgIC0+IENsaWNraW5nIHdpbGwgdmFsaWRhdGUgdGhlIHRvd2VyIHBsYWNlbWVudCBhbmQgY2hlY2sgdGhlIHVzZXIncyBnb2xkXG4gICAgaWYgYm90aCBhcmUgdmFsaWQsIHdpbGwgdG93ZXIgd2lsbCBiZSBwbGFjZWQgKGJ5IGdhbWUgb2JqZWN0KVxuICAgIG90aGVyd2lzZSwgYW4gZXJyb3IgbWVzc2FnZSB3aWxsIHNob3cgdXBcbjIpIEEgdG93ZXIgaXMgbm90IHNlbGVjdGVkIGFuZCBpcyBub3QgYmVpbmcgcGxhY2VkXG4gICAgLT4gV2lsbCBjaGVjayB3aGV0aGVyIHRoZSBjbGljayBwb3NpdGlvbiBvdmVybGFwcyB3aXRoIHRoZSBib3VuZGluZ1xuICAgIHJlY3RhbmdsZSBvZiBtb25zdGVyIG9yIHRvd2VyIC0gaWYgc28sIGl0IHdpbGwgcmV0dXJuIHRoZSBpbmZvcm1hdGlvblxuICAgIGluIHRoZSBpbmZvcm1hdGlvbiBjb250YWluZXJcbiovXG5mdW5jdGlvbiBjYW52YXNDbGljayhlKSB7XG4gICAgLy8gR2V0IGNsaWNrIGxvY2F0aW9uIHJlbGF0aXZlIHRvIHRoZSBjYW52YXMgZWxlbWVudFxuICAgIHZhciBjYW52YXNDb250YWluZXIgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICBwb3NpdGlvbiA9IHt9LFxuICAgICAgICB0b3dlckdyaWRQb3NpdGlvbiA9IGNhbnZhc01vdXNlUG9zaXRpb24udG93ZXJQb3NpdGlvbi5ncmlkLFxuICAgICAgICB0b3dlckNvb3JkaW5hdGVzID0gY2FudmFzTW91c2VQb3NpdGlvbi50b3dlclBvc2l0aW9uLmNvb3JkaW5hdGVzOyAvLyBQYXNzZXMgaW4gZ3JpZCBibG9ja3MgLSB0aGlzIGlzIHRoZSB0b3BMZWZ0IGJsb2NrXG5cbiAgICBwb3NpdGlvbi54ID0gZS5jbGllbnRYIC0gY2FudmFzQ29udGFpbmVyLmxlZnQ7XG4gICAgcG9zaXRpb24ueSA9IGUuY2xpZW50WSAtIGNhbnZhc0NvbnRhaW5lci50b3A7XG5cbiAgICAvLyBSdW5zIGlmIHRoZSB1c2VyIGlzIHBsYWNpbmcgYSB0b3dlclxuICAgIGlmIChhY3RpdmVUb3dlclNlbGVjdGVkICE9PSBudWxsKSB7XG4gICAgICAgIHZhciB0b3dlck5hbWUgPSBhY3RpdmVUb3dlclNlbGVjdGVkLFxuICAgICAgICAgICAgdG93ZXJQbGFjZWQgPSBnYW1lLnBsYWNlVG93ZXIodG93ZXJOYW1lLCB0b3dlckdyaWRQb3NpdGlvbiwgdG93ZXJDb29yZGluYXRlcyk7XG5cbiAgICAgICAgLy8gSWYgdGhlIHRvd2VyIHdhcyBub3QgcGxhY2VkLCBzaG93IGFuIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgaWYgKCF0b3dlclBsYWNlZC5wbGFjZWQpIHtcbiAgICAgICAgICAgIGFjdGl2ZU1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogdG93ZXJQbGFjZWQubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB0aW1lcjogY29uc3RhbnRzLk1FU1NBR0VEVVJBVElPTiAvLyBzZWNvbmRzXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB1dGlscy5yZW1vdmVDbGFzcyh0b3dlckNhcmRzW3Rvd2VyQ2FyZExpc3QuaW5kZXhPZihhY3RpdmVUb3dlclNlbGVjdGVkKV0sIFwiYWN0aXZlXCIpO1xuICAgICAgICBhY3RpdmVUb3dlclNlbGVjdGVkID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVc2VyIGlzIG5vdCBydW5uaW5nIGEgdG93ZXIgcGxhY2VtZW50XG4gICAgICAgIGFjdGl2ZUNhbnZhc0VsZW1lbnQgPSBnYW1lLmNoZWNrQ2xpY2tMb2NhdGlvbihwb3NpdGlvbik7XG4gICAgICAgIHVwZGF0ZUluZm9ybWF0aW9uUGFuZWwoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNlbGxUb3dlcigpIHtcbiAgICBnYW1lLnNlbGxUb3dlcihhY3RpdmVDYW52YXNFbGVtZW50LmluZGV4KTtcbiAgICB1cGRhdGVJbmZvcm1hdGlvblBhbmVsKCk7XG59XG5cbi8vIEF0IHRoZSBtb21lbnQgZXhwZWN0cyBvbmx5IHRvd2VycyB3aXRoIHVwZ3JhZGVzIHNob3VsZCBiZSBhYmxlIHRvIGFjY2VzcyB0aGlzXG5mdW5jdGlvbiBzaG93VXBncmFkZU9wdGlvbnModG93ZXJJbmRleCkge1xuICAgIC8vIEZpZ3VyZSBvdXQgd2hlcmUgdG8gc2hvdyB0aGUgdXBncmFkZSBjb250aWFuZXJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1haW5Nb2RhbFwiKS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJtb2RhbC1iYWNrZ3JvdW5kXCIpWzBdLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG5cbiAgICB2YXIgdG93ZXJJZCA9IGdhbWUudG93ZXJzW3Rvd2VySW5kZXhdLmlkLFxuICAgICAgICB1cGdyYWRlcyA9IHRvd2VyRGF0YVt0b3dlcklkXS51cGdyYWRlO1xuXG4gICAgLy8gVG9kbyBtb3ZlIEhUTUwgb3V0IGludG8gYSB0ZW1wbGF0ZVxuICAgIHZhciB0aXRsZSA9IFwiVXBncmFkZSBUb3dlclwiLFxuICAgICAgICBjb250ZW50ID0gXCJcIjtcblxuICAgIHVwZ3JhZGVzLmZvckVhY2goZnVuY3Rpb24odXBncmFkZU9iaikge1xuICAgICAgICB2YXIgdG93ZXJEYXRhT2JqZWN0ID0gdG93ZXJEYXRhW3VwZ3JhZGVPYmoubmFtZV07XG4gICAgICAgIGNvbnRlbnQgKz0gXCI8YSBjbGFzcz0nd2F2ZXMtZWZmZWN0IHdhdmVzLWxpZ2h0IGJ0bi1sYXJnZSByZWQnIGRhdGEtYWN0aW9uPSd1cGdyYWRlJyBkYXRhLXVwZ3JhZGVuYW1lPSdcIiArIHVwZ3JhZGVPYmoubmFtZSArIFwiJz5cIiArIHVwZ3JhZGVPYmoubmFtZSArIFwiIFVwZ3JhZGU8L2E+XCI7XG4gICAgfSk7XG5cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1haW5Nb2RhbFRpdGxlXCIpLmlubmVySFRNTCA9IHRpdGxlO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibWFpbk1vZGFsQ29udGVudFwiKS5pbm5lckhUTUwgPSBjb250ZW50O1xuXG59XG5cbmZ1bmN0aW9uIHVwZ3JhZGVUb3dlcih0b3dlckluZGV4LCB1cGdyYWRlTmFtZSkge1xuICAgdmFyIHVwZ3JhZGVkID0gZ2FtZS51cGdyYWRlVG93ZXIodG93ZXJJbmRleCwgdXBncmFkZU5hbWUpO1xuICAgIGlmICh1cGdyYWRlZCkge1xuICAgICAgICB1cGRhdGVJbmZvcm1hdGlvblBhbmVsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aXZlTWVzc2FnZSA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNvbnN0YW50cy5NRVNTQUdFTk9URU5PVUdIR09MRCxcbiAgICAgICAgICAgIHRpbWVyOiBjb25zdGFudHMuTUVTU0FHRURVUkFUSU9OIC8vIHNlY29uZHNcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2ludGVyZmFjZS5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgdG93ZXJEYXRhID0gcmVxdWlyZShcIi4uL2dhbWVEYXRhL3Rvd2VyZGF0YS5qc1wiKSxcbiAgICB1dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy5qc1wiKSxcbiAgICBQcm9qZWN0aWxlID0gcmVxdWlyZShcIi4vUHJvamVjdGlsZXMuanNcIiksXG4gICAgY29uc3RhbnRzID0gcmVxdWlyZShcIi4uL2dhbWVEYXRhL2dhbWVDb25zdGFudHMuanNcIik7XG5cbi8vIFBvc2l0aW9uIHJlZmVycyB0byB0aGUgdXBwZXIgbGVmdCBjb3JuZXIgb2YgdGhlIGVsZW1lbnRzXG4vLyBUb3dlciB3aWR0aCAtIDUwIHggNTBcbnZhciBUb3dlciA9IGZ1bmN0aW9uKHBvc2l0aW9uLCBpZCkge1xuICAgIGlmICh0b3dlckRhdGFbaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0b3dlciBuYW1lLCBjaGVjayBodG1sIGRhdGFhdHRyaWJ1dGUgb3IgdG93ZXJkYXRhXCIpXG4gICAgfVxuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmF0dGFja1NwZWVkID0gdG93ZXJEYXRhW2lkXS5hdHRhY2tTcGVlZDsgLy8gQXR0YWNrIHNwZWVkXG4gICAgdGhpcy5jb29sZG93biA9IDA7XG4gICAgdGhpcy5yYW5nZSA9IHRvd2VyRGF0YVtpZF0ucmFuZ2U7IC8vIFJhbmdlIG9mIHRoZSB0b3dlclxuICAgIHRoaXMuZWZmZWN0cyA9IHRvd2VyRGF0YVtpZF0uZWZmZWN0czsgLy8gU3BlY2lhbCBlZmZlY3QgKGUuZy4gc2xvdywgc3BsYXNoLCBldGMpXG4gICAgdGhpcy5nb2xkQ29zdCA9IHRvd2VyRGF0YVtpZF0uZ29sZENvc3Q7XG4gICAgdGhpcy50b3RhbENvc3QgPSB0b3dlckRhdGFbaWRdLnRvdGFsQ29zdDtcbiAgICB0aGlzLnVwZ3JhZGUgPSB0b3dlckRhdGFbaWRdLnVwZ3JhZGU7XG4gICAgdGhpcy50YXJnZXRzID0gdG93ZXJEYXRhW2lkXS50YXJnZXRzO1xuICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjsgLy8gb2JqZWN0IHdpdGggeCBhbmQgeSBjb29yZGluYXRlcyAtIHJlZmVyZW5jZXMgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgdG93ZXJcbiAgICB0aGlzLnBvc2l0aW9uLnNpZGVMZW5ndGggPSBjb25zdGFudHMuVE9XRVJMRU5HVEg7XG59XG4vLyBNZXRob2QgdGhlIGdhbWUgb2JqZWN0IHVzZXMgdG8gcnVuIHRvd2Vyc1xuVG93ZXIucHJvdG90eXBlLnJ1bkN5Y2xlID0gZnVuY3Rpb24oYWN0aXZlTW9uc3RlcnMsIGR0KSB7XG4gICAgdmFyIHRhcmdldE1vbnN0ZXIgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuY29vbGRvd24gPCAwKSB7XG4gICAgICAgIC8vIENyZWF0ZXMgcHJvamVjdGlsZXMgdXAgdG8gdGhlIG51bWJlciBvZiB0YXJnZXRzIHNwZWNpZmllZCBieSB0aGUgdG93ZXJcbiAgICAgICAgdmFyIGZpcmVkU2hvdHMgPSAwO1xuICAgICAgICBhY3RpdmVNb25zdGVycy5mb3JFYWNoKGZ1bmN0aW9uKG1vbnN0ZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrSW5SYW5nZShtb25zdGVyLnBvc2l0aW9uKSAmJiAoZmlyZWRTaG90cyA8IHRoaXMudGFyZ2V0cykpIHtcbiAgICAgICAgICAgICAgICBtb25zdGVyLnByb2plY3RpbGVzLnB1c2gobmV3IFByb2plY3RpbGUodGhpcy5pZCwgdGhpcy5wb3NpdGlvbikpO1xuICAgICAgICAgICAgICAgIGZpcmVkU2hvdHMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLmNvb2xkb3duID0gdGhpcy5hdHRhY2tTcGVlZDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb29sZG93biA+PSAwKSB7XG4gICAgICAgIHRoaXMuY29vbGRvd24gLT0gZHQ7XG4gICAgfVxufVxuXG4vLyBUYWtlcyBpbiBhIG1vbnN0ZXIncyBwb3NpdGlvbiBhbmQgY2hlY2tzIHdoZXRoZXIgdGhhdCBpcyBpbiByYW5nZSBiYXNlZCBvbiB0aGUgcmFuZ2UgLSByZXR1cm5zIHRydWUgb3IgZmFsc2UgaWYgaW4gcmFuZ2Ugd2hpY2ggY2FuIGJlIHVzZWQgdG9cblRvd2VyLnByb3RvdHlwZS5jaGVja0luUmFuZ2UgPSBmdW5jdGlvbihtb25zdGVyUG9zaXRpb24pIHtcbiAgICAvLyB1c2luZyBzcXJ0KCh4Mi14MSleMiAtICh5Mi15MSleMilcbiAgICB2YXIgbW9uc3RlckRpc3RhbmNlID0gdXRpbHMuZ2V0UG9zaXRpb25EaWZmZXJlbmNlKG1vbnN0ZXJQb3NpdGlvbiwgdGhpcy5wb3NpdGlvbik7XG5cbiAgIGlmIChtb25zdGVyRGlzdGFuY2UgPD0gdGhpcy5yYW5nZSkge1xuICAgICAgIHJldHVybiB0cnVlO1xuICAgfSBlbHNlIHtcbiAgICAgICByZXR1cm4gZmFsc2U7XG4gICB9XG59XG5cbi8vIFRPRE8gZmlndXJlIG91dCBhIGJldHRlciB3YXkgdG8gcmVuZGVyIHRvd2Vyc1xuVG93ZXIucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbigpIHtcbiAgICBkeW5hbWljQ29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBkeW5hbWljQ29udGV4dC5maWxsU3R5bGUgPSBcImdyZWVuXCI7XG4gICAgZHluYW1pY0NvbnRleHQuZmlsbFJlY3QodGhpcy5wb3NpdGlvbi54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24ueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdGFudHMuVE9XRVJMRU5HVEgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRzLlRPV0VSTEVOR1RIKTtcbiAgICBkeW5hbWljQ29udGV4dC5jbG9zZVBhdGgoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUb3dlcjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2NsYXNzZXMvVG93ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gVGhpcyBzaG91bGQgcHJvYmFibHkgYmUgaW4gYSBkYXRhYmFzZVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLy8gQmFzaWMgdG93ZXIgdHJlZSBoZXJlXG4gICAgYmFzaWM6IHtcbiAgICAgICAgcHJvamVjdGlsZToge1xuICAgICAgICAgICAgZGFtYWdlOiA1LFxuICAgICAgICAgICAgdHJhdmVsVGltZTogMC41LCAvLyB0aW1lIGluIHNlY29uZHMgYmVmb3JlIGltcGFjdFxuICAgICAgICAgICAgc3ByaXRlOiBcIlRPRE9cIiwgLy8gY2hhbmdlIHRoaXMgdG8gaGF2ZSBhbmltYXRpb25zXG4gICAgICAgICAgICB0eXBlOiBcIm5vcm1hbFwiLCAvL1xuICAgICAgICAgICAgZWZmZWN0czogW11cbiAgICAgICAgfSxcbiAgICAgICAgc3ByaXRlOiBcIlRPRE9cIixcbiAgICAgICAgdGFyZ2V0czogMSxcbiAgICAgICAgYXR0YWNrU3BlZWQ6IDEsIC8vIDEgc2Vjb25kIHBlciBhdHRhY2tcbiAgICAgICAgcmFuZ2U6IDMwMCxcbiAgICAgICAgZ29sZENvc3Q6IDEwLFxuICAgICAgICB0b3RhbENvc3Q6IDEwLCAvLyBVc2VkIGZvciB1cGdyYWRlZCB0b3dlcnNcbiAgICAgICAgdXBncmFkZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiYWR2YW5jZWRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIm11bHRpc2hvdFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIGFkdmFuY2VkOiB7XG4gICAgICAgIHByb2plY3RpbGU6IHtcbiAgICAgICAgICAgIGRhbWFnZTogMTUsXG4gICAgICAgICAgICB0cmF2ZWxUaW1lOiAwLjUsIC8vIHRpbWUgaW4gc2Vjb25kcyBiZWZvcmUgaW1wYWN0XG4gICAgICAgICAgICBzcHJpdGU6IFwiVE9ET1wiLCAvLyBjaGFuZ2UgdGhpcyB0byBoYXZlIGFuaW1hdGlvbnNcbiAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsXCIsXG4gICAgICAgICAgICBlZmZlY3RzOiBbXVxuICAgICAgICB9LFxuICAgICAgICBzcHJpdGU6IFwiVE9ET1wiLFxuICAgICAgICB0YXJnZXRzOiAxLFxuICAgICAgICBhdHRhY2tTcGVlZDogMC44LFxuICAgICAgICByYW5nZTogNDAwLFxuICAgICAgICBnb2xkQ29zdDogMjAsXG4gICAgICAgIHRvdGFsQ29zdDogMzAsXG4gICAgICAgIHVwZ3JhZGU6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImV4cGVydFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIGV4cGVydDoge1xuICAgICAgICBwcm9qZWN0aWxlOiB7XG4gICAgICAgICAgICBkYW1hZ2U6IDQ1LFxuICAgICAgICAgICAgdHJhdmVsVGltZTogMC41LCAvLyB0aW1lIGluIHNlY29uZHMgYmVmb3JlIGltcGFjdFxuICAgICAgICAgICAgc3ByaXRlOiBcIlRPRE9cIiwgLy8gY2hhbmdlIHRoaXMgdG8gaGF2ZSBhbmltYXRpb25zXG4gICAgICAgICAgICB0eXBlOiBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgZWZmZWN0czogW11cbiAgICAgICAgfSxcbiAgICAgICAgc3ByaXRlOiBcIlRPRE9cIixcbiAgICAgICAgdGFyZ2V0czogMSxcbiAgICAgICAgYXR0YWNrU3BlZWQ6IDAuOCxcbiAgICAgICAgcmFuZ2U6IDQwMCxcbiAgICAgICAgZ29sZENvc3Q6IDYwLFxuICAgICAgICB0b3RhbENvc3Q6IDkwLFxuICAgICAgICB1cGdyYWRlOiBbXVxuICAgIH0sXG4gICAgbXVsdGlzaG90OiB7XG4gICAgICAgIHByb2plY3RpbGU6IHtcbiAgICAgICAgICAgIGRhbWFnZTogNSxcbiAgICAgICAgICAgIHRyYXZlbFRpbWU6IDAuNSwgLy8gdGltZSBpbiBzZWNvbmRzIGJlZm9yZSBpbXBhY3RcbiAgICAgICAgICAgIHNwcml0ZTogXCJUT0RPXCIsIC8vIGNoYW5nZSB0aGlzIHRvIGhhdmUgYW5pbWF0aW9uc1xuICAgICAgICAgICAgdHlwZTogXCJub3JtYWxcIixcbiAgICAgICAgICAgIGVmZmVjdHM6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIHNwcml0ZTogXCJUT0RPXCIsXG4gICAgICAgIHRhcmdldHM6IDMsXG4gICAgICAgIGF0dGFja1NwZWVkOiAwLjgsXG4gICAgICAgIHJhbmdlOiA0MDAsXG4gICAgICAgIGdvbGRDb3N0OiAyMCxcbiAgICAgICAgdG90YWxDb3N0OiAzMCxcbiAgICAgICAgdXBncmFkZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiZXhwZXJ0TXVsdGlzaG90XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAgZXhwZXJ0TXVsdGlzaG90OiB7XG4gICAgICAgIHByb2plY3RpbGU6IHtcbiAgICAgICAgICAgIGRhbWFnZTogMzAsXG4gICAgICAgICAgICB0cmF2ZWxUaW1lOiAwLjUsIC8vIHRpbWUgaW4gc2Vjb25kcyBiZWZvcmUgaW1wYWN0XG4gICAgICAgICAgICBzcHJpdGU6IFwiVE9ET1wiLCAvLyBjaGFuZ2UgdGhpcyB0byBoYXZlIGFuaW1hdGlvbnNcbiAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsXCIsXG4gICAgICAgICAgICBlZmZlY3RzOiBbXVxuICAgICAgICB9LFxuICAgICAgICBzcHJpdGU6IFwiVE9ET1wiLFxuICAgICAgICB0YXJnZXRzOiA0LFxuICAgICAgICBhdHRhY2tTcGVlZDogMC44LFxuICAgICAgICByYW5nZTogNDAwLFxuICAgICAgICBnb2xkQ29zdDogMTAwLFxuICAgICAgICB0b3RhbENvc3Q6IDEzMCxcbiAgICAgICAgdXBncmFkZTogW11cbiAgICB9LFxuXG4gICAgLy8gSGVhdnkgdG93ZXIgdHJlZSBoZXJlXG4gICAgaGVhdnk6IHtcbiAgICAgICAgcHJvamVjdGlsZToge1xuICAgICAgICAgICAgZGFtYWdlOiAxNSxcbiAgICAgICAgICAgIHRyYXZlbFRpbWU6IDAuOCwgLy8gdGltZSBpbiBzZWNvbmRzIGJlZm9yZSBpbXBhY3RcbiAgICAgICAgICAgIHNwcml0ZTogXCJUT0RPXCIsIC8vIGNoYW5nZSB0aGlzIHRvIGhhdmUgYW5pbWF0aW9uc1xuICAgICAgICAgICAgdHlwZTogXCJub3JtYWxcIixcbiAgICAgICAgICAgIGVmZmVjdHM6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIHNwcml0ZTogXCJUT0RPXCIsXG4gICAgICAgIHRhcmdldHM6IDEsXG4gICAgICAgIGF0dGFja1NwZWVkOiAyLFxuICAgICAgICByYW5nZTogMjUwLFxuICAgICAgICBnb2xkQ29zdDogMTAsXG4gICAgICAgIHRvdGFsQ29zdDogMTAsXG4gICAgICAgIHVwZ3JhZGU6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcInNpZWdlXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJjYW5ub25cIlxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICBzaWVnZToge1xuICAgICAgICBwcm9qZWN0aWxlOiB7XG4gICAgICAgICAgICBkYW1hZ2U6IDQwLFxuICAgICAgICAgICAgdHJhdmVsVGltZTogMC42LCAvLyB0aW1lIGluIHNlY29uZHMgYmVmb3JlIGltcGFjdFxuICAgICAgICAgICAgc3ByaXRlOiBcIlRPRE9cIiwgLy8gY2hhbmdlIHRoaXMgdG8gaGF2ZSBhbmltYXRpb25zXG4gICAgICAgICAgICB0eXBlOiBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgZWZmZWN0czogW11cbiAgICAgICAgfSxcbiAgICAgICAgc3ByaXRlOiBcIlRPRE9cIixcbiAgICAgICAgdGFyZ2V0czogMSxcbiAgICAgICAgYXR0YWNrU3BlZWQ6IDIsXG4gICAgICAgIHJhbmdlOiAzNTAsXG4gICAgICAgIGdvbGRDb3N0OiAzMCxcbiAgICAgICAgdG90YWxDb3N0OiA0MCxcbiAgICAgICAgdXBncmFkZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiZGVtb2xpdGlvblwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiZXhwbG9zaW9uXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAgZGVtb2xpdGlvbjoge1xuICAgICAgICBwcm9qZWN0aWxlOiB7XG4gICAgICAgICAgICBkYW1hZ2U6IDEwMCxcbiAgICAgICAgICAgIHRyYXZlbFRpbWU6IDAuNiwgLy8gdGltZSBpbiBzZWNvbmRzIGJlZm9yZSBpbXBhY3RcbiAgICAgICAgICAgIHNwcml0ZTogXCJUT0RPXCIsIC8vIGNoYW5nZSB0aGlzIHRvIGhhdmUgYW5pbWF0aW9uc1xuICAgICAgICAgICAgdHlwZTogXCJub3JtYWxcIixcbiAgICAgICAgICAgIGVmZmVjdHM6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIHNwcml0ZTogXCJUT0RPXCIsXG4gICAgICAgIHRhcmdldHM6IDEsXG4gICAgICAgIGF0dGFja1NwZWVkOiAxLjUsXG4gICAgICAgIHJhbmdlOiA1MDAsXG4gICAgICAgIGdvbGRDb3N0OiAxMDAsXG4gICAgICAgIHRvdGFsQ29zdDogMTQwLFxuICAgICAgICB1cGdyYWRlOiBbXVxuICAgIH0sXG4gICAgZXhwbG9zaW9uOiB7XG4gICAgICAgIHByb2plY3RpbGU6IHtcbiAgICAgICAgICAgIGRhbWFnZTogNjAsXG4gICAgICAgICAgICB0cmF2ZWxUaW1lOiAwLjYsIC8vIHRpbWUgaW4gc2Vjb25kcyBiZWZvcmUgaW1wYWN0XG4gICAgICAgICAgICBzcHJpdGU6IFwiVE9ET1wiLCAvLyBjaGFuZ2UgdGhpcyB0byBoYXZlIGFuaW1hdGlvbnNcbiAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsXCIsXG4gICAgICAgICAgICBlZmZlY3RzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNwbGFzaFwiLFxuICAgICAgICAgICAgICAgICAgICByYWRpdXM6IDIwMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgc3ByaXRlOiBcIlRPRE9cIixcbiAgICAgICAgdGFyZ2V0czogMSxcbiAgICAgICAgYXR0YWNrU3BlZWQ6IDEuNSxcbiAgICAgICAgcmFuZ2U6IDUwMCxcbiAgICAgICAgZ29sZENvc3Q6IDEwMCxcbiAgICAgICAgdG90YWxDb3N0OiAxNDAsXG4gICAgICAgIHVwZ3JhZGU6IFtdXG4gICAgfSxcbiAgICBjYW5ub246IHtcbiAgICAgICAgcHJvamVjdGlsZToge1xuICAgICAgICAgICAgZGFtYWdlOiAyMCxcbiAgICAgICAgICAgIHRyYXZlbFRpbWU6IDAuNiwgLy8gdGltZSBpbiBzZWNvbmRzIGJlZm9yZSBpbXBhY3RcbiAgICAgICAgICAgIHNwcml0ZTogXCJUT0RPXCIsIC8vIGNoYW5nZSB0aGlzIHRvIGhhdmUgYW5pbWF0aW9uc1xuICAgICAgICAgICAgdHlwZTogXCJub3JtYWxcIixcbiAgICAgICAgICAgIGVmZmVjdHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYW1wbGlmeVwiLFxuICAgICAgICAgICAgICAgICAgICBhbW91bnQ6IDEuNSAvLyBkYW1hZ2UgbXVsdGlwbGllclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgc3ByaXRlOiBcIlRPRE9cIixcbiAgICAgICAgdGFyZ2V0czogMSxcbiAgICAgICAgYXR0YWNrU3BlZWQ6IDEsXG4gICAgICAgIHJhbmdlOiAzNTAsXG4gICAgICAgIGdvbGRDb3N0OiAzMCxcbiAgICAgICAgdG90YWxDb3N0OiA0MCxcbiAgICAgICAgdXBncmFkZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwic2hyYXBuZWxcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImFydGlsbGVyeVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHNocmFwbmVsOiB7XG4gICAgICAgIHByb2plY3RpbGU6IHtcbiAgICAgICAgICAgIGRhbWFnZTogNDAsXG4gICAgICAgICAgICB0cmF2ZWxUaW1lOiAwLjYsIC8vIHRpbWUgaW4gc2Vjb25kcyBiZWZvcmUgaW1wYWN0XG4gICAgICAgICAgICBzcHJpdGU6IFwiVE9ET1wiLCAvLyBjaGFuZ2UgdGhpcyB0byBoYXZlIGFuaW1hdGlvbnNcbiAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsXCIsXG4gICAgICAgICAgICBlZmZlY3RzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFtcGxpZnlcIixcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50OiAxLjUgLy8gZGFtYWdlIG11bHRpcGxpZXJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHNwcml0ZTogXCJUT0RPXCIsXG4gICAgICAgIHRhcmdldHM6IDMsXG4gICAgICAgIGF0dGFja1NwZWVkOiAxLFxuICAgICAgICByYW5nZTogMzUwLFxuICAgICAgICBnb2xkQ29zdDogODAsXG4gICAgICAgIHRvdGFsQ29zdDogMTIwLFxuICAgICAgICB1cGdyYWRlOiBbXVxuICAgIH0sXG4gICAgYXJ0aWxsZXJ5OiB7XG4gICAgICAgIHByb2plY3RpbGU6IHtcbiAgICAgICAgICAgIGRhbWFnZTogNzAsXG4gICAgICAgICAgICB0cmF2ZWxUaW1lOiAwLjMsIC8vIHRpbWUgaW4gc2Vjb25kcyBiZWZvcmUgaW1wYWN0XG4gICAgICAgICAgICBzcHJpdGU6IFwiVE9ET1wiLCAvLyBjaGFuZ2UgdGhpcyB0byBoYXZlIGFuaW1hdGlvbnNcbiAgICAgICAgICAgIHR5cGU6IFwibm9ybWFsXCIsXG4gICAgICAgICAgICBlZmZlY3RzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFtcGxpZnlcIixcbiAgICAgICAgICAgICAgICAgICAgYW1vdW50OiAyIC8vIGRhbWFnZSBtdWx0aXBsaWVyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBzcHJpdGU6IFwiVE9ET1wiLFxuICAgICAgICB0YXJnZXRzOiAxLFxuICAgICAgICBhdHRhY2tTcGVlZDogMSxcbiAgICAgICAgcmFuZ2U6IDYwMCxcbiAgICAgICAgZ29sZENvc3Q6IDExMCxcbiAgICAgICAgdG90YWxDb3N0OiAxNTAsXG4gICAgICAgIHVwZ3JhZGU6IFtdXG4gICAgfSxcblxuICAgIC8vIEZpcmUgdG93ZXIgdHJlZSBoZXJlXG4gICAgZmlyZToge1xuICAgICAgICBwcm9qZWN0aWxlOiB7XG4gICAgICAgICAgICBkYW1hZ2U6IDEwLFxuICAgICAgICAgICAgdHJhdmVsVGltZTogMC4zLCAvLyB0aW1lIGluIHNlY29uZHMgYmVmb3JlIGltcGFjdFxuICAgICAgICAgICAgc3ByaXRlOiBcIlRPRE9cIiwgLy8gY2hhbmdlIHRoaXMgdG8gaGF2ZSBhbmltYXRpb25zXG4gICAgICAgICAgICB0eXBlOiBcImZpcmVcIixcbiAgICAgICAgICAgIGVmZmVjdHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZG90XCIsXG4gICAgICAgICAgICAgICAgICAgIGRwczogNVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgc3ByaXRlOiBcIlRPRE9cIixcbiAgICAgICAgdGFyZ2V0czogMSxcbiAgICAgICAgYXR0YWNrU3BlZWQ6IDAuNixcbiAgICAgICAgcmFuZ2U6IDMwMCxcbiAgICAgICAgZ29sZENvc3Q6IDMwLFxuICAgICAgICB0b3RhbENvc3Q6IDMwLFxuICAgICAgICB1cGdyYWRlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJicm9pbGVyXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJmbGFtZXRocm93ZXJcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICBicm9pbGVyOiB7XG4gICAgICAgIHByb2plY3RpbGU6IHtcbiAgICAgICAgICAgIGRhbWFnZTogOCxcbiAgICAgICAgICAgIHRyYXZlbFRpbWU6IDAuMDEsIC8vIHRpbWUgaW4gc2Vjb25kcyBiZWZvcmUgaW1wYWN0XG4gICAgICAgICAgICBzcHJpdGU6IFwiVE9ET1wiLCAvLyBjaGFuZ2UgdGhpcyB0byBoYXZlIGFuaW1hdGlvbnNcbiAgICAgICAgICAgIHR5cGU6IFwiZmlyZVwiLFxuICAgICAgICAgICAgZWZmZWN0czogW11cbiAgICAgICAgfSxcbiAgICAgICAgc3ByaXRlOiBcIlRPRE9cIixcbiAgICAgICAgdGFyZ2V0czogMzAsXG4gICAgICAgIGF0dGFja1NwZWVkOiAwLjIsXG4gICAgICAgIHJhbmdlOiAzMDAsXG4gICAgICAgIGdvbGRDb3N0OiA2MCxcbiAgICAgICAgdG90YWxDb3N0OiA5MCxcbiAgICAgICAgdXBncmFkZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwidm9sY2Fub1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiaW5mZXJub1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHZvbGNhbm86IHtcbiAgICAgICAgcHJvamVjdGlsZToge1xuICAgICAgICAgICAgZGFtYWdlOiAyMCxcbiAgICAgICAgICAgIHRyYXZlbFRpbWU6IDAuMDEsIC8vIHRpbWUgaW4gc2Vjb25kcyBiZWZvcmUgaW1wYWN0XG4gICAgICAgICAgICBzcHJpdGU6IFwiVE9ET1wiLCAvLyBjaGFuZ2UgdGhpcyB0byBoYXZlIGFuaW1hdGlvbnNcbiAgICAgICAgICAgIHR5cGU6IFwiZmlyZVwiLFxuICAgICAgICAgICAgZWZmZWN0czogW11cbiAgICAgICAgfSxcbiAgICAgICAgc3ByaXRlOiBcIlRPRE9cIixcbiAgICAgICAgdGFyZ2V0czogMzAsXG4gICAgICAgIGF0dGFja1NwZWVkOiAwLjIsXG4gICAgICAgIHJhbmdlOiAzMDAsXG4gICAgICAgIGdvbGRDb3N0OiAxMTAsXG4gICAgICAgIHRvdGFsQ29zdDogMjAwLFxuICAgICAgICB1cGdyYWRlOiBbXVxuICAgIH0sXG4gICAgaW5mZXJubzoge1xuICAgICAgICBwcm9qZWN0aWxlOiB7XG4gICAgICAgICAgICBkYW1hZ2U6IDE1LFxuICAgICAgICAgICAgdHJhdmVsVGltZTogMC4wMSwgLy8gdGltZSBpbiBzZWNvbmRzIGJlZm9yZSBpbXBhY3RcbiAgICAgICAgICAgIHNwcml0ZTogXCJUT0RPXCIsIC8vIGNoYW5nZSB0aGlzIHRvIGhhdmUgYW5pbWF0aW9uc1xuICAgICAgICAgICAgdHlwZTogXCJmaXJlXCIsXG4gICAgICAgICAgICBlZmZlY3RzOiBbXVxuICAgICAgICB9LFxuICAgICAgICBzcHJpdGU6IFwiVE9ET1wiLFxuICAgICAgICB0YXJnZXRzOiAzMCxcbiAgICAgICAgYXR0YWNrU3BlZWQ6IDAuMixcbiAgICAgICAgcmFuZ2U6IDUwMCxcbiAgICAgICAgZ29sZENvc3Q6IDExMCxcbiAgICAgICAgdG90YWxDb3N0OiAyMDAsXG4gICAgICAgIHVwZ3JhZGU6IFtdXG4gICAgfSxcbiAgICBmbGFtZXRocm93ZXI6IHtcbiAgICAgICAgcHJvamVjdGlsZToge1xuICAgICAgICAgICAgZGFtYWdlOiAyMCxcbiAgICAgICAgICAgIHRyYXZlbFRpbWU6IDAuMDEsIC8vIHRpbWUgaW4gc2Vjb25kcyBiZWZvcmUgaW1wYWN0XG4gICAgICAgICAgICBzcHJpdGU6IFwiVE9ET1wiLCAvLyBjaGFuZ2UgdGhpcyB0byBoYXZlIGFuaW1hdGlvbnNcbiAgICAgICAgICAgIHR5cGU6IFwiZmlyZVwiLFxuICAgICAgICAgICAgZWZmZWN0czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJkb3RcIixcbiAgICAgICAgICAgICAgICAgICAgZHBzOiAxMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgc3ByaXRlOiBcIlRPRE9cIixcbiAgICAgICAgdGFyZ2V0czogMSxcbiAgICAgICAgYXR0YWNrU3BlZWQ6IDAuNSxcbiAgICAgICAgcmFuZ2U6IDMwMCxcbiAgICAgICAgZ29sZENvc3Q6IDYwLFxuICAgICAgICB0b3RhbENvc3Q6IDkwLFxuICAgICAgICB1cGdyYWRlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJuYXBhbG1cIlxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICBuYXBhbG06IHtcbiAgICAgICAgcHJvamVjdGlsZToge1xuICAgICAgICAgICAgZGFtYWdlOiA1MCxcbiAgICAgICAgICAgIHRyYXZlbFRpbWU6IDAuMDEsIC8vIHRpbWUgaW4gc2Vjb25kcyBiZWZvcmUgaW1wYWN0XG4gICAgICAgICAgICBzcHJpdGU6IFwiVE9ET1wiLCAvLyBjaGFuZ2UgdGhpcyB0byBoYXZlIGFuaW1hdGlvbnNcbiAgICAgICAgICAgIHR5cGU6IFwiZmlyZVwiLFxuICAgICAgICAgICAgZWZmZWN0czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJkb3RcIixcbiAgICAgICAgICAgICAgICAgICAgZHBzOiAzMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgc3ByaXRlOiBcIlRPRE9cIixcbiAgICAgICAgdGFyZ2V0czogMSxcbiAgICAgICAgYXR0YWNrU3BlZWQ6IDAuNSxcbiAgICAgICAgcmFuZ2U6IDQwMCxcbiAgICAgICAgZ29sZENvc3Q6IDkwLFxuICAgICAgICB0b3RhbENvc3Q6IDE1MCxcbiAgICAgICAgdXBncmFkZTogW11cbiAgICB9LFxuXG4gICAgLy8gSWNlIHN0YXJ0cyBoZXJlXG4gICAgaWNlOiB7XG4gICAgICAgIHByb2plY3RpbGU6IHtcbiAgICAgICAgICAgIGRhbWFnZTogMTAsXG4gICAgICAgICAgICB0cmF2ZWxUaW1lOiAwLjgsIC8vIHRpbWUgaW4gc2Vjb25kcyBiZWZvcmUgaW1wYWN0XG4gICAgICAgICAgICBzcHJpdGU6IFwiVE9ET1wiLCAvLyBjaGFuZ2UgdGhpcyB0byBoYXZlIGFuaW1hdGlvbnNcbiAgICAgICAgICAgIHR5cGU6IFwiaWNlXCIsXG4gICAgICAgICAgICBlZmZlY3RzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNsb3dcIixcbiAgICAgICAgICAgICAgICAgICAgc2xvdzogMC4zIC8vIGRlY2ltYWwgb2YgaG93IHNsb3cgLSBoaWdoZXIgaXMgbW9yZSBzbG93XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICBzcHJpdGU6IFwiVE9ET1wiLFxuICAgICAgICB0YXJnZXRzOiAxLFxuICAgICAgICBhdHRhY2tTcGVlZDogMC44LFxuICAgICAgICByYW5nZTogMzAwLFxuICAgICAgICBnb2xkQ29zdDogMzAsXG4gICAgICAgIHRvdGFsQ29zdDogMzAsXG4gICAgICAgIHVwZ3JhZGU6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImJsaXp6YXJkXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJmcm9zdFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIGJsaXp6YXJkOiB7XG4gICAgICAgIHByb2plY3RpbGU6IHtcbiAgICAgICAgICAgIGRhbWFnZTogNSxcbiAgICAgICAgICAgIHRyYXZlbFRpbWU6IDAuMiwgLy8gdGltZSBpbiBzZWNvbmRzIGJlZm9yZSBpbXBhY3RcbiAgICAgICAgICAgIHNwcml0ZTogXCJUT0RPXCIsIC8vIGNoYW5nZSB0aGlzIHRvIGhhdmUgYW5pbWF0aW9uc1xuICAgICAgICAgICAgdHlwZTogXCJpY2VcIixcbiAgICAgICAgICAgIGVmZmVjdHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2xvd1wiLFxuICAgICAgICAgICAgICAgICAgICBzbG93OiAwLjQgLy8gZGVjaW1hbCBvZiBob3cgc2xvdyAtIGhpZ2hlciBpcyBtb3JlIHNsb3dcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHNwcml0ZTogXCJUT0RPXCIsXG4gICAgICAgIHRhcmdldHM6IDMwLFxuICAgICAgICBhdHRhY2tTcGVlZDogMC44LFxuICAgICAgICByYW5nZTogMzAwLFxuICAgICAgICBnb2xkQ29zdDogNzAsXG4gICAgICAgIHRvdGFsQ29zdDogMTAwLFxuICAgICAgICB1cGdyYWRlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJhcmN0aWNcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICBhcmN0aWM6IHtcbiAgICAgICAgcHJvamVjdGlsZToge1xuICAgICAgICAgICAgZGFtYWdlOiAxMixcbiAgICAgICAgICAgIHRyYXZlbFRpbWU6IDAuMiwgLy8gdGltZSBpbiBzZWNvbmRzIGJlZm9yZSBpbXBhY3RcbiAgICAgICAgICAgIHNwcml0ZTogXCJUT0RPXCIsIC8vIGNoYW5nZSB0aGlzIHRvIGhhdmUgYW5pbWF0aW9uc1xuICAgICAgICAgICAgdHlwZTogXCJpY2VcIixcbiAgICAgICAgICAgIGVmZmVjdHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2xvd1wiLFxuICAgICAgICAgICAgICAgICAgICBzbG93OiAwLjUgLy8gZGVjaW1hbCBvZiBob3cgc2xvdyAtIGhpZ2hlciBpcyBtb3JlIHNsb3dcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHNwcml0ZTogXCJUT0RPXCIsXG4gICAgICAgIHRhcmdldHM6IDMwLFxuICAgICAgICBhdHRhY2tTcGVlZDogMC44LFxuICAgICAgICByYW5nZTogNDAwLFxuICAgICAgICBnb2xkQ29zdDogNzAsXG4gICAgICAgIHRvdGFsQ29zdDogMTcwLFxuICAgICAgICB1cGdyYWRlOiBbXVxuICAgIH0sXG4gICAgZnJvc3Q6IHtcbiAgICAgICAgcHJvamVjdGlsZToge1xuICAgICAgICAgICAgZGFtYWdlOiAyNSxcbiAgICAgICAgICAgIHRyYXZlbFRpbWU6IDAuNiwgLy8gdGltZSBpbiBzZWNvbmRzIGJlZm9yZSBpbXBhY3RcbiAgICAgICAgICAgIHNwcml0ZTogXCJUT0RPXCIsIC8vIGNoYW5nZSB0aGlzIHRvIGhhdmUgYW5pbWF0aW9uc1xuICAgICAgICAgICAgdHlwZTogXCJpY2VcIixcbiAgICAgICAgICAgIGVmZmVjdHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2xvd1wiLFxuICAgICAgICAgICAgICAgICAgICBzbG93OiAwLjUgLy8gZGVjaW1hbCBvZiBob3cgc2xvdyAtIGhpZ2hlciBpcyBtb3JlIHNsb3dcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHNwcml0ZTogXCJUT0RPXCIsXG4gICAgICAgIHRhcmdldHM6IDEsXG4gICAgICAgIGF0dGFja1NwZWVkOiAwLjgsXG4gICAgICAgIHJhbmdlOiAzMDAsXG4gICAgICAgIGdvbGRDb3N0OiA2MCxcbiAgICAgICAgdG90YWxDb3N0OiA5MCxcbiAgICAgICAgdXBncmFkZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwidHVuZHJhXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJwZXJtYWZyb3N0XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAgdHVuZHJhOiB7XG4gICAgICAgIHByb2plY3RpbGU6IHtcbiAgICAgICAgICAgIGRhbWFnZTogNDAsXG4gICAgICAgICAgICB0cmF2ZWxUaW1lOiAwLjYsIC8vIHRpbWUgaW4gc2Vjb25kcyBiZWZvcmUgaW1wYWN0XG4gICAgICAgICAgICBzcHJpdGU6IFwiVE9ET1wiLCAvLyBjaGFuZ2UgdGhpcyB0byBoYXZlIGFuaW1hdGlvbnNcbiAgICAgICAgICAgIHR5cGU6IFwiaWNlXCIsXG4gICAgICAgICAgICBlZmZlY3RzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNsb3dcIixcbiAgICAgICAgICAgICAgICAgICAgc2xvdzogMC42NSAvLyBkZWNpbWFsIG9mIGhvdyBzbG93IC0gaGlnaGVyIGlzIG1vcmUgc2xvd1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgc3ByaXRlOiBcIlRPRE9cIixcbiAgICAgICAgdGFyZ2V0czogMSxcbiAgICAgICAgYXR0YWNrU3BlZWQ6IDAuOCxcbiAgICAgICAgcmFuZ2U6IDQwMCxcbiAgICAgICAgZ29sZENvc3Q6IDkwLFxuICAgICAgICB0b3RhbENvc3Q6IDE4MCxcbiAgICAgICAgdXBncmFkZTogW11cbiAgICB9LFxuICAgIHBlcm1hZnJvc3Q6IHtcbiAgICAgICAgcHJvamVjdGlsZToge1xuICAgICAgICAgICAgZGFtYWdlOiAzMCxcbiAgICAgICAgICAgIHRyYXZlbFRpbWU6IDAuNiwgLy8gdGltZSBpbiBzZWNvbmRzIGJlZm9yZSBpbXBhY3RcbiAgICAgICAgICAgIHNwcml0ZTogXCJUT0RPXCIsIC8vIGNoYW5nZSB0aGlzIHRvIGhhdmUgYW5pbWF0aW9uc1xuICAgICAgICAgICAgdHlwZTogXCJpY2VcIixcbiAgICAgICAgICAgIGVmZmVjdHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnJlZXplXCIsXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAxLFxuICAgICAgICAgICAgICAgICAgICBjaGFuY2U6IDAuMlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgc3ByaXRlOiBcIlRPRE9cIixcbiAgICAgICAgdGFyZ2V0czogMSxcbiAgICAgICAgYXR0YWNrU3BlZWQ6IDAuOCxcbiAgICAgICAgcmFuZ2U6IDQwMCxcbiAgICAgICAgZ29sZENvc3Q6IDEyMCxcbiAgICAgICAgdG90YWxDb3N0OiAyMTAsXG4gICAgICAgIHVwZ3JhZGU6IFtdXG4gICAgfSxcbiAgICAvLyBMaWdodCB0b3dlciB0cmVlIGhlcmVcbiAgICBsaWdodDoge1xuICAgICAgICBwcm9qZWN0aWxlOiB7XG4gICAgICAgICAgICBkYW1hZ2U6IDUsXG4gICAgICAgICAgICB0cmF2ZWxUaW1lOiAwLjEsIC8vIHRpbWUgaW4gc2Vjb25kcyBiZWZvcmUgaW1wYWN0XG4gICAgICAgICAgICBzcHJpdGU6IFwiVE9ET1wiLCAvLyBjaGFuZ2UgdGhpcyB0byBoYXZlIGFuaW1hdGlvbnNcbiAgICAgICAgICAgIHR5cGU6IFwibGlnaHRcIixcbiAgICAgICAgICAgIGVmZmVjdHM6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIHNwcml0ZTogXCJUT0RPXCIsXG4gICAgICAgIHRhcmdldHM6IDEsXG4gICAgICAgIGF0dGFja1NwZWVkOiAwLjQsXG4gICAgICAgIHJhbmdlOiA1MDAsXG4gICAgICAgIGdvbGRDb3N0OiAzMCxcbiAgICAgICAgdG90YWxDb3N0OiAzMCxcbiAgICAgICAgdXBncmFkZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwibGFzZXJcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImVsZWN0cmljXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAgbGFzZXI6IHtcbiAgICAgICAgcHJvamVjdGlsZToge1xuICAgICAgICAgICAgZGFtYWdlOiAxNSxcbiAgICAgICAgICAgIHRyYXZlbFRpbWU6IDAuMSwgLy8gdGltZSBpbiBzZWNvbmRzIGJlZm9yZSBpbXBhY3RcbiAgICAgICAgICAgIHNwcml0ZTogXCJUT0RPXCIsIC8vIGNoYW5nZSB0aGlzIHRvIGhhdmUgYW5pbWF0aW9uc1xuICAgICAgICAgICAgdHlwZTogXCJsaWdodFwiLFxuICAgICAgICAgICAgZWZmZWN0czogW11cbiAgICAgICAgfSxcbiAgICAgICAgc3ByaXRlOiBcIlRPRE9cIixcbiAgICAgICAgdGFyZ2V0czogMSxcbiAgICAgICAgYXR0YWNrU3BlZWQ6IDAuMyxcbiAgICAgICAgcmFuZ2U6IDYwMCxcbiAgICAgICAgZ29sZENvc3Q6IDYwLFxuICAgICAgICB0b3RhbENvc3Q6IDkwLFxuICAgICAgICB1cGdyYWRlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJwcmlzbVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIHByaXNtOiB7XG4gICAgICAgIHByb2plY3RpbGU6IHtcbiAgICAgICAgICAgIGRhbWFnZTogNTAsXG4gICAgICAgICAgICB0cmF2ZWxUaW1lOiAwLjEsIC8vIHRpbWUgaW4gc2Vjb25kcyBiZWZvcmUgaW1wYWN0XG4gICAgICAgICAgICBzcHJpdGU6IFwiVE9ET1wiLCAvLyBjaGFuZ2UgdGhpcyB0byBoYXZlIGFuaW1hdGlvbnNcbiAgICAgICAgICAgIHR5cGU6IFwibGlnaHRcIixcbiAgICAgICAgICAgIGVmZmVjdHM6IFtdXG4gICAgICAgIH0sXG4gICAgICAgIHNwcml0ZTogXCJUT0RPXCIsXG4gICAgICAgIHRhcmdldHM6IDEsXG4gICAgICAgIGF0dGFja1NwZWVkOiAwLjIsXG4gICAgICAgIHJhbmdlOiA2MDAsXG4gICAgICAgIGdvbGRDb3N0OiAxODAsXG4gICAgICAgIHRvdGFsQ29zdDogMjcwLFxuICAgICAgICB1cGdyYWRlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJwcmlzbVwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9LFxuICAgIGVsZWN0cmljOiB7XG4gICAgICAgIHByb2plY3RpbGU6IHtcbiAgICAgICAgICAgIGRhbWFnZTogMTUsXG4gICAgICAgICAgICB0cmF2ZWxUaW1lOiAwLjEsIC8vIHRpbWUgaW4gc2Vjb25kcyBiZWZvcmUgaW1wYWN0XG4gICAgICAgICAgICBzcHJpdGU6IFwiVE9ET1wiLCAvLyBjaGFuZ2UgdGhpcyB0byBoYXZlIGFuaW1hdGlvbnNcbiAgICAgICAgICAgIHR5cGU6IFwibGlnaHRcIixcbiAgICAgICAgICAgIGVmZmVjdHM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYm91bmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlOiAzMDAsXG4gICAgICAgICAgICAgICAgICAgIGJvdW5jZXM6IDJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgIH0sXG4gICAgICAgIHNwcml0ZTogXCJUT0RPXCIsXG4gICAgICAgIHRhcmdldHM6IDEsXG4gICAgICAgIGF0dGFja1NwZWVkOiAwLjYsXG4gICAgICAgIHJhbmdlOiA0MDAsXG4gICAgICAgIGdvbGRDb3N0OiA2MCxcbiAgICAgICAgdG90YWxDb3N0OiA5MCxcbiAgICAgICAgdXBncmFkZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwibGlnaHRuaW5nXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJnZW5lcmF0b3JcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgfSxcbiAgICBsaWdodG5pbmc6IHtcbiAgICAgICAgcHJvamVjdGlsZToge1xuICAgICAgICAgICAgZGFtYWdlOiAzNSxcbiAgICAgICAgICAgIHRyYXZlbFRpbWU6IDAuMSwgLy8gdGltZSBpbiBzZWNvbmRzIGJlZm9yZSBpbXBhY3RcbiAgICAgICAgICAgIHNwcml0ZTogXCJUT0RPXCIsIC8vIGNoYW5nZSB0aGlzIHRvIGhhdmUgYW5pbWF0aW9uc1xuICAgICAgICAgICAgdHlwZTogXCJsaWdodFwiLFxuICAgICAgICAgICAgZWZmZWN0czogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJib3VuY2VcIixcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IDMwMCxcbiAgICAgICAgICAgICAgICAgICAgYm91bmNlczogMlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgc3ByaXRlOiBcIlRPRE9cIixcbiAgICAgICAgdGFyZ2V0czogMSxcbiAgICAgICAgYXR0YWNrU3BlZWQ6IDAuNixcbiAgICAgICAgcmFuZ2U6IDQwMCxcbiAgICAgICAgZ29sZENvc3Q6IDkwLFxuICAgICAgICB0b3RhbENvc3Q6IDE4MCxcbiAgICAgICAgdXBncmFkZTogW11cbiAgICB9LFxuICAgIGdlbmVyYXRvcjoge1xuICAgICAgICBwcm9qZWN0aWxlOiB7XG4gICAgICAgICAgICBkYW1hZ2U6IDM1LFxuICAgICAgICAgICAgdHJhdmVsVGltZTogMC4xLCAvLyB0aW1lIGluIHNlY29uZHMgYmVmb3JlIGltcGFjdFxuICAgICAgICAgICAgc3ByaXRlOiBcIlRPRE9cIiwgLy8gY2hhbmdlIHRoaXMgdG8gaGF2ZSBhbmltYXRpb25zXG4gICAgICAgICAgICB0eXBlOiBcImxpZ2h0XCIsXG4gICAgICAgICAgICBlZmZlY3RzOiBbXVxuICAgICAgICB9LFxuICAgICAgICBzcHJpdGU6IFwiVE9ET1wiLFxuICAgICAgICB0YXJnZXRzOiAzLFxuICAgICAgICBhdHRhY2tTcGVlZDogMC42LFxuICAgICAgICByYW5nZTogNDAwLFxuICAgICAgICBnb2xkQ29zdDogOTAsXG4gICAgICAgIHRvdGFsQ29zdDogMTgwLFxuICAgICAgICB1cGdyYWRlOiBbXVxuICAgIH1cblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2dhbWVEYXRhL3Rvd2VyZGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIi4vZ2FtZURhdGEvZ2FtZUNvbnN0YW50cy5qc1wiKTtcblxuLyogPT09PT09PT09PT09PT09PT09IFB1YmxpYyBmdW5jdGlvbnMgPT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgY3NzQ2xhc3MpIHtcbiAgICBpZiAoZWxlbWVudC5jbGFzc05hbWUgPT09IFwiXCIpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBjc3NDbGFzcztcbiAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSArPSBcIiBcIiArIGNzc0NsYXNzO1xuICAgIH1cbn1cblxuLypcbmNoZWNrSWZJblNxdWFyZSBjaGVja3Mgd2hldGhlciBhIHBvaW50IGlzIGluIGEgc3F1YXJlICh3aGljaCBpcyBhIG1vbnN0ZXIgb3IgYSB0b3dlcilcblxuVGFrZXMgaW4gdGhyZWUgYXJndW1lbnRzXG5wb2ludCAtIGEgb2JqZWN0IHdpdGggeCBhbmQgeSBjb29yZGluYXRlc1xudG9wTGVmdFBvaW50IC0gYW4gb2JqZWN0IHdpdGggeCBhbmQgeSBjb29yZGluYXRlcyBvZiB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBzcXVhcmVcbnNpZGVMZW5ndGggLSB0aGUgbGVuZ3RoIG9mIHRoZSBzcXVhcmVcblxuUmV0dXJucyBhIGJvb2xlYW4gLSB0cnVlIGlmIHRoZSBjbGljayBvdmVybGFwcyB3aXRoIGFuIGVsZW1lbnQgYW5kIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIGlmIGl0IGRvZXMgbm90XG4qL1xuZnVuY3Rpb24gY2hlY2tJZkluU3F1YXJlKHBvaW50LCB0b3BMZWZ0UG9pbnQsIHNpZGVMZW5ndGgpIHtcbiAgICBpZiAocG9pbnQueCA+PSB0b3BMZWZ0UG9pbnQueFxuICAgICYmIHBvaW50LnggPD0gdG9wTGVmdFBvaW50LnggKyBzaWRlTGVuZ3RoXG4gICAgJiYgcG9pbnQueSA+PSB0b3BMZWZ0UG9pbnQueVxuICAgICYmIHBvaW50LnkgPD0gdG9wTGVmdFBvaW50LnkgKyBzaWRlTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8qXG5UYWtlcyBpbiBhIGRpc3RhbmNlIChpbnQpIGFuZCBwYXRoTGluZXMoYXJyYXkgb2YgcGF0aCBvYmplY3RzKSBhbmQgY29udmVydHMgaXQgdG8gY29vcmRpbmF0ZXMgZm9yIGEgbW9uc3RlclxuUmV0dXJucyBhIGNvb3JkaW5hdGUgb2JqZWN0XG4qL1xuZnVuY3Rpb24gY29udmVydERpc3RhbmNlVG9Db29yZGluYXRlcyhkaXN0YW5jZSwgcGF0aExpbmVzKSB7XG4gICAgdmFyIGNvb3JkaW5hdGVzLFxuICAgICAgICBlbmQgPSBmYWxzZTsgLy8gQm9vbGVhbiB0byByZXByZXNlbnQgd2hldGhlciB0aGUgbW9uc3RlciBpcyBhdCB0aGUgZW5kXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aExpbmVzLmxlbmd0aDsgaSArKykge1xuICAgICAgICBpZiAoZGlzdGFuY2UgLSBwYXRoTGluZXNbaV0uZGlzdGFuY2UgPD0gMCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXN0YW5jZSAtPSBwYXRoTGluZXNbaV0uZGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaSA9PT0gcGF0aExpbmVzLmxlbmd0aCkge1xuICAgICAgICBpLS07IC8vIFNldCB0aGUgY291bnRlciB2YWx1ZSB0byBiZSB0aGUgbGFzdCB2YWx1ZSBpbiB0aGUgcGF0aGxpbmVzIGFycmF5XG4gICAgICAgIGRpc3RhbmNlID0gIHBhdGhMaW5lc1tpXS5kaXN0YW5jZTtcbiAgICAgICAgZW5kID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgb2JqZWN0IHRvIHJldHVybiAoaW5zdGVhZCBvZiBtb2RpZml5aW5nIHN0YXJ0UG9pbnQgb2JqZWN0KVxuICAgIGNvb3JkaW5hdGVzID0gT2JqZWN0LmNyZWF0ZShwYXRoTGluZXNbaV0uc3RhcnRQb2ludCk7XG4gICAgY29vcmRpbmF0ZXMuZW5kID0gZW5kO1xuXG4gICAgLy8gQ2FzZSBmb3Igd2hlbiBtb25zdGVyIGlzIGF0IHRoZSBlbmQgb2YgdGhlIHRoaW5neSAtIHRoZXJlIGlzIGEgYmV0dGVyIHdheSB0byB3cml0ZSB0aGlzIGJ1dCBub3QgcmlnaHQgbm93XG4gICAgaWYgKCFlbmQpIHtcbiAgICAgICAgc3dpdGNoIChwYXRoTGluZXNbaV0uZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAvLyAxNSBpcyBhIGhhbGYgb2YgdGhlIG1vbnN0ZXIgd2lkdGhcbiAgICAgICAgICAgIC8vIHZhbHVlcyB1c2VkIHRvIG9mZnNldCB0aGUgcG9zaXRpb25pbmcgYmFzZWQgb24gdGhlIG1vbnN0ZXIgZGlyZWNpdG9uIG1vdmVtZW50XG4gICAgICAgICAgICBjYXNlIFwidXBcIjpcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzLnggLT0gY29uc3RhbnRzLk1PTlNURVJMRU5HVEgvMjtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzLnkgLT0gZGlzdGFuY2UgKyBjb25zdGFudHMuTU9OU1RFUkxFTkdUSC8yO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZG93blwiOlxuICAgICAgICAgICAgY29vcmRpbmF0ZXMueCAtPSBjb25zdGFudHMuTU9OU1RFUkxFTkdUSC8yO1xuICAgICAgICAgICAgY29vcmRpbmF0ZXMueSArPSBkaXN0YW5jZSAtIGNvbnN0YW50cy5NT05TVEVSTEVOR1RILzI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgICBjb29yZGluYXRlcy54IC09IGRpc3RhbmNlICsgY29uc3RhbnRzLk1PTlNURVJMRU5HVEgvMjtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzLnkgLT0gY29uc3RhbnRzLk1PTlNURVJMRU5HVEgvMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICBjb29yZGluYXRlcy54ICs9IGRpc3RhbmNlIC0gY29uc3RhbnRzLk1PTlNURVJMRU5HVEgvMjtcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzLnkgLT0gY29uc3RhbnRzLk1PTlNURVJMRU5HVEgvMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGlyZWN0aW9uIHByb3ZpZGVkIGluIHBhdGhMaW5lc1wiKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAocGF0aExpbmVzW2ldLmRpcmVjdGlvbikge1xuICAgICAgICAgICAgY2FzZSBcInVwXCI6XG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXMueSAtPSBwYXRoTGluZXNbaV0uZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZG93blwiOlxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzLnkgKz0gcGF0aExpbmVzW2ldLmRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlcy54IC09IHBhdGhMaW5lc1tpXS5kaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzLnggKz0gcGF0aExpbmVzW2ldLmRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRpcmVjdGlvbiBwcm92aWRlZCBpbiBwYXRoTGluZXNcIik7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBjb29yZGluYXRlc1xufVxuXG4vLyBUYWtlcyBpbiBhIHBvc2l0aW9uIG9iamVjdCB3aXRoIGNvb3JkaW5hdGVze3gsIHl9XG4vLyByZXR1cm5zIGEgYmxvY2sgb2JqZWN0IHt4LCB5fSB3aXRoIGJsb2NrIG51bWJlcnNcbi8vIEhhbmRsZXMgZWRnZSBjYXNlcyBvZiB0aGUgYmxvY2sgYmVpbmcgZGVmaW5lZCBhdCB0aGUgZWRnZSAoMzYgYW5kIDI0IHdoaWNoIGFyZSBpbnZhbGlkIGluIHRoZSApXG5mdW5jdGlvbiBjb252ZXJ0VG9CbG9jayhwb3NpdGlvbikge1xuICAgIHZhciB4R3JpZEFtb3VudCA9IGNvbnN0YW50cy5DQU5WQVNXSURUSCAvIGNvbnN0YW50cy5HUklEU0laRSxcbiAgICAgICAgeUdyaWRBbW91bnQgPSBjb25zdGFudHMuQ0FOVkFTSEVJR0hUIC8gY29uc3RhbnRzLkdSSURTSVpFO1xuXG4gICAgaWYgKHBvc2l0aW9uLnggPiAoeEdyaWRBbW91bnQgKiAoY29uc3RhbnRzLlRPV0VSTEVOR1RILzIpKSB8fFxuICAgICAgICBwb3NpdGlvbi55ID4gKHlHcmlkQW1vdW50ICogKGNvbnN0YW50cy5UT1dFUkxFTkdUSC8yKSkpIHtcbiAgICAgICAgY29uc29sZS5sb2cocG9zaXRpb24pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvc2l0aW9uIG91dCBvZiBncmlkIHJhbmdlXCIpO1xuICAgIH1cblxuICAgIHZhciBibG9jayA9IHtcbiAgICAgICAgeDogTWF0aC5mbG9vcihwb3NpdGlvbi54IC8gKGNvbnN0YW50cy5UT1dFUkxFTkdUSC8yKSksXG4gICAgICAgIHk6IE1hdGguZmxvb3IocG9zaXRpb24ueSAvIChjb25zdGFudHMuVE9XRVJMRU5HVEgvMikpXG4gICAgfTtcbiAgICAvLyBBZGp1c3RzIGlmIG1vdXNlIGlzIGF0IGVuZCBvZiBjb250YWluZXJcbiAgICAvLyAzNiBibG9ja3Mgd2lkdGggYW5kIDI0IGJsb2NrcyBoZWlnaHRcbiAgICBpZiAoYmxvY2sueCA+PSB4R3JpZEFtb3VudCAtIDEpIHtcbiAgICAgICAgYmxvY2sueC0tO1xuICAgIH1cblxuICAgIGlmIChibG9jay55ID49IHlHcmlkQW1vdW50IC0gMSkge1xuICAgICAgICBibG9jay55LS07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJsb2NrO1xufVxuXG4vKlxuVGFrZXMgaW4gYSBwb3NpdGlvbiBvYmplY3QgKHggYW5kIHkgY29vcmRpbmF0ZXMpXG5SZXR1cm5zIHRoZSB0b3AgbGVmdCBibG9jayBwb3NpdGlvbiBhbmQgdG9wbGVmdCBjb29yZGluYXRlIG9mIHRoZSB0b3dlclxuR3JpZCBibG9ja3MgYXJlIGluIDI1eDI1IGJsb2NrIGluY3JlbWVudHNcbiovXG5mdW5jdGlvbiBjb252ZXJ0UG9zaXRpb25Ub1Rvd2VyKHBvc2l0aW9uKSB7XG4gICAgdmFyIHRvd2VyUG9zaXRpb24gPSB7XG4gICAgICAgIGdyaWQ6IHt9LFxuICAgICAgICBjb29yZGluYXRlczoge30sXG4gICAgICAgIHNpZGU6IGNvbnN0YW50cy5UT1dFUkxFTkdUSFxuICAgIH0sXG4gICAgICAgIHhHcmlkQW1vdW50ID0gY29uc3RhbnRzLkNBTlZBU1dJRFRIIC8gY29uc3RhbnRzLkdSSURTSVpFLFxuICAgICAgICB5R3JpZEFtb3VudCA9IGNvbnN0YW50cy5DQU5WQVNIRUlHSFQgLyBjb25zdGFudHMuR1JJRFNJWkU7XG5cblxuICAgIHRvd2VyUG9zaXRpb24uZ3JpZCA9IGNvbnZlcnRUb0Jsb2NrKHBvc2l0aW9uKTtcblxuICAgIC8vIENvbnRhaW5lciB3aWR0aCBhbmQgaGVpZ2h0IDkwMCBhbmQgNjAwIHB4IHJlc3BlY3RpdmVseVxuICAgIHRvd2VyUG9zaXRpb24uY29vcmRpbmF0ZXMueCA9ICh0b3dlclBvc2l0aW9uLmdyaWQueCAvIHhHcmlkQW1vdW50KSAqIGNvbnN0YW50cy5DQU5WQVNXSURUSDtcbiAgICB0b3dlclBvc2l0aW9uLmNvb3JkaW5hdGVzLnkgPSAodG93ZXJQb3NpdGlvbi5ncmlkLnkgLyB5R3JpZEFtb3VudCkgKiBjb25zdGFudHMuQ0FOVkFTSEVJR0hUO1xuICAgIHJldHVybiB0b3dlclBvc2l0aW9uO1xufVxuLypcbmdldFBhdGhQb3NpdGlvbiBpbnB1dHM6XG5pbml0aWFsUG9zaXRpb246IHBvc2l0aW9uIG9iamVjdCB7eCwgeX1cbmZpbmFsUG9zaXRpb246IHBvc2l0aW9uIG9iamVjdCB7eCwgeX1cbmZyYWN0aW9uVHJhdmVsbGVkOiBkZWNpbWFsIG9mIGhvdyBmYXIgYWxvbmcgdGhlIHBhdGhcblxuT3V0cHV0OiBwb3NpdGlvbiBvYmplY3Qge3gsIHl9XG4qL1xuZnVuY3Rpb24gZ2V0UGF0aFBvc2l0aW9uKHBvczEsIHBvczIsIGZyYWN0aW9uVHJhdmVsbGVkKSB7XG4gICAgdmFyIGZpbmFsUG9zaXRpb24gPSB7fSxcbiAgICAgICAgYW5nbGUgPSBNYXRoLmF0YW4yKHBvczIueSAtIHBvczEueSwgcG9zMi54IC0gcG9zMS54KSwgLy8gdGhlIGxpbmUgYW5nbGUgKGluIHJhZGlhbnMpIGZyb20gcG9zMSB0byBwb3MyIHdpdGggcmVzcGVjdCB0byB0aGUgb3JpZ2luXG4gICAgICAgIGRpc3RhbmNlRnJvbVBvczEgPSBnZXRQb3NpdGlvbkRpZmZlcmVuY2UocG9zMSwgcG9zMikgKiBmcmFjdGlvblRyYXZlbGxlZDtcblxuICAgIGZpbmFsUG9zaXRpb24ueCA9IHBvczEueCArIGRpc3RhbmNlRnJvbVBvczEgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgZmluYWxQb3NpdGlvbi55ID0gcG9zMS55ICsgZGlzdGFuY2VGcm9tUG9zMSAqIE1hdGguc2luKGFuZ2xlKTtcblxuICAgIHJldHVybiBmaW5hbFBvc2l0aW9uO1xufVxuXG5mdW5jdGlvbiBnZXRQb3NpdGlvbkRpZmZlcmVuY2UocG9zaXRpb24xLCBwb3NpdGlvbjIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KFxuICAgICAgICAgICAgTWF0aC5wb3cocG9zaXRpb24xLngtcG9zaXRpb24yLngsIDIpICtcbiAgICAgICAgICAgIE1hdGgucG93KHBvc2l0aW9uMS55LXBvc2l0aW9uMi55LCAyKVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNzc0NsYXNzKSB7XG4gICAgdmFyIGFycmF5T2ZDbGFzc2VzID0gZWxlbWVudC5jbGFzc05hbWUuc3BsaXQoXCIgXCIpO1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gYXJyYXlPZkNsYXNzZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgIGlmIChhcnJheU9mQ2xhc3Nlc1tpXSA9PT0gY3NzQ2xhc3MpIHtcbiAgICAgICAgICAgIGFycmF5T2ZDbGFzc2VzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGktLTsgai0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gYXJyYXlPZkNsYXNzZXMuam9pbihcIiBcIik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGFkZENsYXNzOiBhZGRDbGFzcyxcbiAgICBjaGVja0lmSW5TcXVhcmU6IGNoZWNrSWZJblNxdWFyZSxcbiAgICBjb252ZXJ0VG9CbG9jazogY29udmVydFRvQmxvY2ssXG4gICAgY29udmVydERpc3RhbmNlVG9Db29yZGluYXRlczogY29udmVydERpc3RhbmNlVG9Db29yZGluYXRlcyxcbiAgICBjb252ZXJ0UG9zaXRpb25Ub1Rvd2VyOiBjb252ZXJ0UG9zaXRpb25Ub1Rvd2VyLFxuICAgIGdldFBhdGhQb3NpdGlvbjogZ2V0UGF0aFBvc2l0aW9uLFxuICAgIGdldFBvc2l0aW9uRGlmZmVyZW5jZTogZ2V0UG9zaXRpb25EaWZmZXJlbmNlLFxuICAgIHJlbW92ZUNsYXNzOiByZW1vdmVDbGFzc1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvdXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQ0FOVkFTV0lEVEg6IDkwMCwgLy8gcHJvYmFibHkgbmVlZCBhIHdheSB0byBzZXQgdGhlIGh0bWwgY2FudmFzIHNpemUgZnJvbSBoZXJlXG4gICAgQ0FOVkFTSEVJR0hUOiA2MDAsIC8vIHByb2JhYmx5IG5lZWQgYSB3YXkgdG8gc2V0IHRoZSBodG1sIGNhbnZhcyBzaXplIGZyb20gaGVyZVxuICAgIEdSSURTSVpFOiAyNSxcbiAgICBUT1dFUkxFTkdUSDogNTAsXG4gICAgTU9OU1RFUkxFTkdUSDogMzAsXG4gICAgUFJPSkVDVElMRUxFTkdUSDogMTAsXG4gICAgVElNRUJFVFdFRU5NT05TVEVSQ1JFQVRFOiAxLCAvLyBzZWNvbmRcbiAgICBUSU1FQkVUV0VFTkxFVkVMUzogMiwgLy8gc2Vjb25kc1xuICAgIEZJTkFMTEVWRUw6IDUwLFxuICAgIFNUQVJUSU5HR09MRDogMTAsXG4gICAgU1RBUlRJTkdMSVZFUzogMzAsXG4gICAgTUVTU0FHRUZPTlQ6ICc0MHB0IERyb2lkIFNhbnMnLFxuICAgIE1FU1NBR0VDT0xPUjogJ3JlZCcsXG4gICAgTUVTU0FHRURVUkFUSU9OOiAwLjgsXG4gICAgTUVTU0FHRUlOVkFMSURQTEFDRU1FTlQ6IFwiSW52YWxpZCBUb3dlciBQbGFjZW1lbnRcIixcbiAgICBNRVNTQUdFTk9URU5PVUdIR09MRDogXCJOb3QgRW5vdWdoIEdvbGRcIixcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2dhbWVEYXRhL2dhbWVDb25zdGFudHMuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHRvd2VyRGF0YSA9IHJlcXVpcmUoXCIuLi9nYW1lRGF0YS90b3dlcmRhdGEuanNcIiksXG4gICAgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMuanNcIiksXG4gICAgY29uc3RhbnRzID0gcmVxdWlyZShcIi4uL2dhbWVEYXRhL2dhbWVDb25zdGFudHMuanNcIik7XG5cbi8vIFByb2plY3RpbGVzIGFyZSBhdHRhY2hlZCB0byBtb25zdGVyc1xudmFyIFByb2plY3RpbGUgPSBmdW5jdGlvbihpZCwgdG93ZXJQb3NpdGlvbikge1xuICAgIHRoaXMuZGFtYWdlID0gdG93ZXJEYXRhW2lkXS5wcm9qZWN0aWxlLmRhbWFnZTtcbiAgICB0aGlzLnRvdGFsVHJhdmVsVGltZSA9IHRvd2VyRGF0YVtpZF0ucHJvamVjdGlsZS50cmF2ZWxUaW1lO1xuICAgIHRoaXMuc3ByaXRlID0gdG93ZXJEYXRhW2lkXS5wcm9qZWN0aWxlLnNwcml0ZTtcbiAgICB0aGlzLnR5cGUgPSB0b3dlckRhdGFbaWRdLnByb2plY3RpbGUudHlwZTtcbiAgICB0aGlzLmVmZmVjdCA9IHRvd2VyRGF0YVtpZF0ucHJvamVjdGlsZS5lZmZlY3Q7XG4gICAgdGhpcy5jdXJyZW50VHJhdmVsVGltZSA9IDA7XG4gICAgdGhpcy5lbmQgPSBmYWxzZTtcbiAgICB0aGlzLmluaXRpYWxQb3NpdGlvbiA9IHtcbiAgICAgICAgeDogdG93ZXJQb3NpdGlvbi54ICsgKGNvbnN0YW50cy5UT1dFUkxFTkdUSC8yKSAtIChjb25zdGFudHMuUFJPSkVDVElMRUxFTkdUSC8yKSxcbiAgICAgICAgeTogdG93ZXJQb3NpdGlvbi55ICsgKGNvbnN0YW50cy5UT1dFUkxFTkdUSC8yKSAtIChjb25zdGFudHMuUFJPSkVDVElMRUxFTkdUSC8yKVxuICAgIH07XG59XG5cblByb2plY3RpbGUucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihtb25zdGVyUG9zaXRpb24pIHtcbiAgICB2YXIgZnJhY3Rpb25UcmF2ZWxsZWQgPSB0aGlzLmN1cnJlbnRUcmF2ZWxUaW1lIC8gdGhpcy50b3RhbFRyYXZlbFRpbWUsXG4gICAgICAgIGFkanVzdGVkTW9uc3RlclBvc2l0aW9uID0ge1xuICAgICAgICAgICAgeDogbW9uc3RlclBvc2l0aW9uLnggKyAoY29uc3RhbnRzLk1PTlNURVJMRU5HVEgvMikgLSAoY29uc3RhbnRzLlBST0pFQ1RJTEVMRU5HVEgvMiksXG4gICAgICAgICAgICB5OiBtb25zdGVyUG9zaXRpb24ueSArIChjb25zdGFudHMuTU9OU1RFUkxFTkdUSC8yKSAtIChjb25zdGFudHMuUFJPSkVDVElMRUxFTkdUSC8yKVxuICAgICAgICB9LFxuICAgICAgICBwb3NpdGlvbiA9IHV0aWxzLmdldFBhdGhQb3NpdGlvbih0aGlzLmluaXRpYWxQb3NpdGlvbiwgYWRqdXN0ZWRNb25zdGVyUG9zaXRpb24sIGZyYWN0aW9uVHJhdmVsbGVkKTtcblxuICAgIC8vIENhbGN1bGF0ZSBhIGZyYWN0aW9uIGJhc2VkIG9uIGN1cnJlbnRUcmF2ZWxUaW1lIC8gdHJhdmVsVGltZSB0byBnZXQgdGhlIHBvc2l0aW9uXG4gICAgZHluYW1pY0NvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgZHluYW1pY0NvbnRleHQuZmlsbFN0eWxlID0gXCJvcmFuZ2VcIjtcbiAgICBkeW5hbWljQ29udGV4dC5yZWN0KHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIGNvbnN0YW50cy5QUk9KRUNUSUxFTEVOR1RILCBjb25zdGFudHMuUFJPSkVDVElMRUxFTkdUSCk7XG4gICAgZHluYW1pY0NvbnRleHQuZmlsbCgpO1xuICAgIC8vIENoYW5nZSB0aGlzIHRvIHVzZSBhIHNwcml0ZVxuICAgIC8vIGRyYXcgYmFzZWQgb24gcG9zaXRpb24gaGVyZVxuXG4gICAgZHluYW1pY0NvbnRleHQuY2xvc2VQYXRoKCk7XG59XG5cblByb2plY3RpbGUucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbihkdCkge1xuICAgIHRoaXMuY3VycmVudFRyYXZlbFRpbWUgKz0gZHQ7XG4gICAgaWYgKHRoaXMuY3VycmVudFRyYXZlbFRpbWUgPj0gdGhpcy50b3RhbFRyYXZlbFRpbWUpIHtcbiAgICAgICAgdGhpcy5lbmQgPSB0cnVlO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQcm9qZWN0aWxlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvY2xhc3Nlcy9Qcm9qZWN0aWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAgcmVxdWlyZSBNb25zdGVyIHRvIGdhaW4gYWNjZXNzXG52YXIgTW9uc3RlciA9IHJlcXVpcmUoXCIuL01vbnN0ZXIuanNcIiksXG4gICAgVG93ZXIgPSByZXF1aXJlKFwiLi9Ub3dlci5qc1wiKSxcbiAgICB0b3dlckRhdGEgPSByZXF1aXJlKFwiLi4vZ2FtZURhdGEvdG93ZXJkYXRhLmpzXCIpLFxuICAgIGxldmVsRGF0YSA9IHJlcXVpcmUoXCIuLi9nYW1lRGF0YS9sZXZlbGRhdGEuanNcIiksXG4gICAgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMuanNcIiksXG4gICAgcGF0aENvb3JkaW5hdGVzID0gcmVxdWlyZShcIi4uL2dhbWVEYXRhL3BhdGhkYXRhLmpzXCIpLFxuICAgIGNvbnN0YW50cyA9IHJlcXVpcmUoXCIuLi9nYW1lRGF0YS9nYW1lQ29uc3RhbnRzLmpzXCIpO1xuXG52YXIgR2FtZUVuZ2luZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudXNlckdvbGQgPSBjb25zdGFudHMuU1RBUlRJTkdHT0xEO1xuICAgIHRoaXMubGV2ZWwgPSAwO1xuICAgIHRoaXMudXNlckxpdmVzID0gY29uc3RhbnRzLlNUQVJUSU5HTElWRVM7XG4gICAgdGhpcy5hY3RpdmVNb25zdGVycyA9IFtdOyAvLyBMaXN0IG9mIGFjdGl2ZSBtb25zdGVycyBpbiB0aGUgZ2FtZVxuICAgIHRoaXMudG93ZXJzID0gW107IC8vIG9iamVjdCBvZiB0b3dlciBvYmplY3RzXG4gICAgdGhpcy50aW1lciA9IGNvbnN0YW50cy5USU1FQkVUV0VFTk1PTlNURVJDUkVBVEU7XG4gICAgdGhpcy5uZXh0TGV2ZWxDYWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLm1vbnN0ZXJzVG9DcmVhdGUgPSAwO1xuICAgIHRoaXMuZ2FtZVN0YXRlID0gXCJzdGFydFwiOyAvLyBQb3NzaWJsZSB2YWx1ZXMgYXJlIHN0YXJ0LCBsb3N0LCB3b24sIHBsYXlpbmdcbiAgICB0aGlzLmdhbWVQYXRoID0gX2NvbnZlcnRQYXRoVG9MaW5lcyhwYXRoQ29vcmRpbmF0ZXMucGF0aCk7XG4gICAgdGhpcy5nYW1lR3JpZCA9IF9pbml0aWF0ZUdyaWQodGhpcy5nYW1lUGF0aCk7XG59XG5cbkdhbWVFbmdpbmUucHJvdG90eXBlLmFkZE1vbnN0ZXIgPSBmdW5jdGlvbihsZXZlbCkge1xuICAgIGxldmVsLS07IC8vIENoYW5nZSB0byBhY2Nlc3MgY29ycmVjdCBhcnJheVxuICAgIHZhciBtdWx0aXBsaWVyID0gKGxldmVsIC8gMikgKyAxLFxuICAgICAgICBtb25zdGVyID0gbmV3IE1vbnN0ZXIobGV2ZWxEYXRhW2xldmVsXS50eXBlLCBtdWx0aXBsaWVyKTtcbiAgICB0aGlzLmFjdGl2ZU1vbnN0ZXJzLnB1c2gobW9uc3Rlcik7XG59XG5cbkdhbWVFbmdpbmUucHJvdG90eXBlLmFkZFRvd2VyID0gZnVuY3Rpb24oaWQsIHBvc2l0aW9uLCBncmlkUG9zaXRpb24sIGdvbGRDb3N0KSB7XG4gICAgdGhpcy51c2VyR29sZCAtPSBnb2xkQ29zdDtcbiAgICB2YXIgdG93ZXIgPSBuZXcgVG93ZXIocG9zaXRpb24sIGlkKTtcbiAgICB0aGlzLnRvd2Vycy5wdXNoKHRvd2VyKTtcbiAgICAvLyBTZXQgZ2FtZUdyaWQgcG9zaXRpb25pbmdcbiAgICB0aGlzLmdhbWVHcmlkW2dyaWRQb3NpdGlvbi54XVtncmlkUG9zaXRpb24ueV0gPSB7ZW1wdHk6IGZhbHNlfTtcbiAgICB0aGlzLmdhbWVHcmlkW2dyaWRQb3NpdGlvbi54ICsgMV1bZ3JpZFBvc2l0aW9uLnldID0ge2VtcHR5OiBmYWxzZX07XG4gICAgdGhpcy5nYW1lR3JpZFtncmlkUG9zaXRpb24ueF1bZ3JpZFBvc2l0aW9uLnkgKyAxXSA9IHtlbXB0eTogZmFsc2V9O1xuICAgIHRoaXMuZ2FtZUdyaWRbZ3JpZFBvc2l0aW9uLnggKyAxXVtncmlkUG9zaXRpb24ueSArIDFdID0ge2VtcHR5OiBmYWxzZX07XG59XG5cbi8qXG5UYWtlcyBpbiBhIHBvc2l0aW9uIG9iamVjdCAobG9jYXRpb24gb2YgdGhlIGNsaWNrKVxuUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGlzIGF0IHRoYXQgcG9zaXRpb25cbnt0eXBlOiBudWxsfSBpZiBub3RoaW5nIGZvdW5kXG4qL1xuR2FtZUVuZ2luZS5wcm90b3R5cGUuY2hlY2tDbGlja0xvY2F0aW9uID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICB2YXIgZWxlbWVudCA9IHt9O1xuICAgIC8vIExvb3BzIHRocm91Z2ggYWN0aXZlTW9uc3RlcnNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0aXZlTW9uc3RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHV0aWxzLmNoZWNrSWZJblNxdWFyZShwb3NpdGlvbiwgdGhpcy5hY3RpdmVNb25zdGVyc1tpXS5wb3NpdGlvbiwgdGhpcy5hY3RpdmVNb25zdGVyc1tpXS5zaWRlTGVuZ3RoKSkge1xuICAgICAgICAgICAgZWxlbWVudC50eXBlID0gXCJtb25zdGVyXCI7XG4gICAgICAgICAgICBlbGVtZW50LmluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbm90aGluZyB3YXMgZm91bmQsIGxvb3AgdGhyb3VnaCB0b3dlcnNcbiAgICBpZiAoZWxlbWVudC50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRvd2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHV0aWxzLmNoZWNrSWZJblNxdWFyZShwb3NpdGlvbiwgdGhpcy50b3dlcnNbaV0ucG9zaXRpb24sIHRoaXMudG93ZXJzW2ldLnBvc2l0aW9uLnNpZGVMZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC50eXBlID0gXCJ0b3dlclwiO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbm8gdG93ZXJzIG9yIG1vbnN0ZXJzIGZvdW5kIHJldHVybiBhIHR5cGUgb2YgbnVsbFxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbGVtZW50LnR5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xufVxuXG5HYW1lRW5naW5lLnByb3RvdHlwZS5jaGVja0dhbWVTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmxldmVsID09PSBjb25zdGFudHMuRklOQUxMRVZFTCArIDEpIHsgLy8gTUFYIGxldmVsXG4gICAgICAgIHRoaXMuZ2FtZVN0YXRlID0gXCJ3b25cIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMudXNlckxpdmVzIDw9IDApIHtcbiAgICAgICAgdGhpcy5nYW1lU3RhdGUgPSBcImxvc3RcIjtcbiAgICB9XG59XG5cbi8vIG1ldGhvZCB0byBjaGVjayBnb2xkIGJlZm9yZSBwbGFjZSB0b3dlciBvciB1cGdyYWRlXG5HYW1lRW5naW5lLnByb3RvdHlwZS5jaGVja0dvbGQgPSBmdW5jdGlvbihnb2xkQ29zdCkge1xuICAgIGlmIChnb2xkQ29zdCA8PSB0aGlzLnVzZXJHb2xkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbkdhbWVFbmdpbmUucHJvdG90eXBlLmdhbWVPdmVyID0gZnVuY3Rpb24oKSB7XG5cbn1cblxuR2FtZUVuZ2luZS5wcm90b3R5cGUuZ2FtZVN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5nYW1lU3RhdGUgPSBcInBsYXlpbmdcIjtcbiAgICB0aGlzLm5leHRMZXZlbCgpO1xufVxuXG5HYW1lRW5naW5lLnByb3RvdHlwZS5nYW1lV29uID0gZnVuY3Rpb24oKSB7XG5cbn1cblxuR2FtZUVuZ2luZS5wcm90b3R5cGUubmV4dExldmVsID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gT25seSBjYWxscyB0aGUgbmV4dCBsZXZlbCBvbmNlIC0gbmV4dExldmVsQ2FsbGVkIGlzIHJlc2V0IG9uIGEgbmV3IG1vbnN0ZXIgY3JlYXRpb25cbiAgICB0aGlzLm1vbnN0ZXJzVG9DcmVhdGUgPSBsZXZlbERhdGFbdGhpcy5sZXZlbF0uYW1vdW50OyAvLyB0aGlzLmxldmVsIHJlZmVycyB0byB0aGUgbmV4dCBsZXZlbFxuICAgIHRoaXMubGV2ZWwrKztcbiAgICB0aGlzLm5leHRMZXZlbENhbGxlZCA9IGZhbHNlO1xufVxuXG4vKlxucGxhY2VUb3dlciBoYW5kbGVzIHRoZSB2YWxpZGF0aW9uIG9mIHRoZSB0b3dlciBwbGFjZW1lbnQgKHBvc2l0aW9uIGFuZCBzdWZmaWNpZW50IGdvbGQpXG5UYWtlcyBpbiAzIGFyZ3VtZW50czpcbnRvd2VyTmFtZSAtIHN0cmluZyBzcGVjaWZ5aW5nIHdoYXQgdG93ZXIgaXMgYmVpbmcgcGxhY2VkXG5ncmlkUG9zaXRpb24gLSB0b3AgbGVmdCBncmlkIGJsb2NrIG9mIHdoZXJlIHRoZSB0b3dlciB3b3VsZCBiZSBwbGFjZWRcbnRvd2VyQ29vcmRpbmF0ZXMgLSB0b3AgbGVmdCBjb29yZGluYXRlIG9mIGEgdG93ZXJcblJldHVybnMgYW4gb2JqZWN0IHdpdGggYSBib29sZWFuIHRvIHJlcHJlc2VudCB3aGV0aGVyIHRoZSB0b3dlciBpcyBwbGFjZWQgYW5kIGFuIGVycm9yIG1lc3NhZ2UgaWYgdGhlIHRvd2VyIHdhcyBub3QgcGxhY2VkXG4qL1xuR2FtZUVuZ2luZS5wcm90b3R5cGUucGxhY2VUb3dlciA9IGZ1bmN0aW9uKHRvd2VyTmFtZSwgZ3JpZFBvc2l0aW9uLCB0b3dlckNvb3JkaW5hdGVzKSB7XG4gICAgdmFyIGdvbGRDb3N0ID0gdG93ZXJEYXRhW3Rvd2VyTmFtZV0uZ29sZENvc3Q7XG4gICAgLy8gVmFsaWRhdGUgdG93ZXIgcGxhY2VtZW50XG4gICAgaWYgKHRoaXMudmFsaWRhdGVUb3dlclBsYWNlbWVudChncmlkUG9zaXRpb24pXG4gICAgJiYgdGhpcy5jaGVja0dvbGQoZ29sZENvc3QpKSB7XG5cbiAgICAgICAgdGhpcy5hZGRUb3dlcih0b3dlck5hbWUsIHRvd2VyQ29vcmRpbmF0ZXMsIGdyaWRQb3NpdGlvbiwgZ29sZENvc3QpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGxhY2VkOiB0cnVlXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcblxuICAgICAgICBpZiAoIXRoaXMudmFsaWRhdGVUb3dlclBsYWNlbWVudChncmlkUG9zaXRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBsYWNlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogY29uc3RhbnRzLk1FU1NBR0VJTlZBTElEUExBQ0VNRU5UXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBsYWNlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogY29uc3RhbnRzLk1FU1NBR0VOT1RFTk9VR0hHT0xEXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuR2FtZUVuZ2luZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICBpZiAodGhpcy5nYW1lU3RhdGUgPT09IFwicGxheWluZ1wiKSB7XG4gICAgICAgIC8vIHNlbmQgc3RhdGUgdG8gdGhlIGRpc3BsYXkgb2JqZWN0IHRvIHJlbmRlclxuICAgICAgICBkeW5hbWljQ29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgZHluYW1pY0NvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGR5bmFtaWNDYW52YXMud2lkdGgsIGR5bmFtaWNDYW52YXMuaGVpZ2h0KTtcblxuICAgICAgICAvLyBSZW5kZXIgdG93ZXJzIGZpcnN0IHNvIHRoYXQgaWYgbW9uc3RlcnMgYXJlIGxhcmdlciB0aGV5IHNob3cgYWJvdmUgdG93ZXJzXG4gICAgICAgIHRoaXMudG93ZXJzLmZvckVhY2goZnVuY3Rpb24odG93ZXIpIHtcbiAgICAgICAgICAgIHRvd2VyLmRyYXcoKTtcbiAgICAgICAgfSlcblxuICAgICAgICAvLyAgbG9vcCB0aHJvdWdoIGxpc3Qgb2YgYWN0aXZlIG1vbnN0ZXJzIGFuZCByZW5kZXIgdGhlbVxuICAgICAgICAvLyAgVE9ETyBwcm9iYWJseSBuZWVkIHRvIGZpbmQgYSBiZXR0ZXIgd2F5IHRvIHJlbmQgdGhlbSBhcGFydCBmcm9tIHJhbmRvbSByZWN0YW5nbGVcbiAgICAgICAgdGhpcy5hY3RpdmVNb25zdGVycy5mb3JFYWNoKGZ1bmN0aW9uKGFjdGl2ZU1vbnN0ZXIpIHtcbiAgICAgICAgICAgIGFjdGl2ZU1vbnN0ZXIuZHJhdygpO1xuXG4gICAgICAgICAgICAvLyBSZW5kZXJzIHByb2plY3RpbGUgYW5pbWF0aW9ucyB0aGF0IGFyZSBhY3RpdmUgZm9yIGVhY2ggbW9uc3RlclxuICAgICAgICAgICAgYWN0aXZlTW9uc3Rlci5wcm9qZWN0aWxlcy5mb3JFYWNoKGZ1bmN0aW9uKHByb2plY3RpbGUpIHtcbiAgICAgICAgICAgICAgICBwcm9qZWN0aWxlLmRyYXcoYWN0aXZlTW9uc3Rlci5wb3NpdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZHluYW1pY0NvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICB9IGVsc2UgaWYgKHRoaXMuZ2FtZVN0YXRlID09PSBcImxvc3RcIikge1xuICAgICAgICAvLyBBZGQgcmVuZGVyIG1ldGhvZCB0byBhZGQgdGhpbmdcbiAgICAgICAgY29uc29sZS5sb2coXCJ5b3UgbG9zdCBsb2xcIik7XG4gICAgfSBlbHNlIGlmICh0aGlzLmdhbWVTdGF0ZSA9PT0gXCJ3b25cIikge1xuICAgICAgICAvLyBBZGQgcmVuZGVyIG1ldGhvZCB0byBhZGQgdGhpbmdcbiAgICAgICAgY29uc29sZS5sb2coXCJjb25ncmF0cyB5b3Ugd29uXCIpO1xuICAgIH1cblxufTtcblxuLy8gQ2hhbmdlZCB2YWx1ZXMgdG8gYmUgYmFzZWQgb2ZmIGR0IChjaGFuZ2UgaW4gdGltZSBzaW5jZSBsYXN0IHJlbmRlcilcbkdhbWVFbmdpbmUucHJvdG90eXBlLnJ1bkN5Y2xlID0gZnVuY3Rpb24oZHQpIHtcbiAgICB0aGlzLmNoZWNrR2FtZVN0YXRlKCk7XG5cbiAgICBpZiAodGhpcy5nYW1lU3RhdGUgPT09IFwicGxheWluZ1wiKSB7XG4gICAgICAgIC8vIGxvb3AgdGhyb3VnaCBhY3RpdmUgbW9uc3RlcnMgYW5kIHRvd2VycyBhbmQgcnVuIHRoZSBjeWNsZVxuICAgICAgICAvLyBFYWNoIHJ1bkN5Y2xlIG1ldGhvZCByZXR1cm5zIGluZm9ybWF0aW9uIGZvciB0aGUgZ2FtZUVuZ2luZSB0b1xuICAgICAgICAvLyBwcm9jZXNzIChlLmcuIHRoZSBtb25zdGVyIGRpZWQsIHRvd2VyIGNoYW5nZWQpXG5cbiAgICAgICAgLy8gQWRkcyBtb25zdGVycyBpZiB0aGVyZSBhcmUgbW9uc3RlcnMgdG8gY3JlYXRlIC0gY3JlYXRlcyAxMCBwZXIgbGV2ZWxcbiAgICAgICAgaWYgKHRoaXMubW9uc3RlcnNUb0NyZWF0ZSA+IDApIHtcbiAgICAgICAgICAgIC8vICB0aW1lciB0byBhZGQgbW9uc3RlcnNcbiAgICAgICAgICAgIHRoaXMudGltZXIgLT0gZHQ7XG4gICAgICAgICAgICBpZiAodGhpcy50aW1lciA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRNb25zdGVyKHRoaXMubGV2ZWwpOyAvLyBzZW5kIHRocm91Z2ggdGhlIGxldmVsIG51bWJlclxuICAgICAgICAgICAgICAgIHRoaXMudGltZXIgPSBjb25zdGFudHMuVElNRUJFVFdFRU5NT05TVEVSQ1JFQVRFOyAvLyBFdmVyeSAxIHNlY29uZCBjcmVhdGUgYSBuZXcgbW9uc3RlclxuICAgICAgICAgICAgICAgIHRoaXMubW9uc3RlcnNUb0NyZWF0ZS0tO1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dExldmVsQ2FsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxscyB0aGUgbmV4dCBsZXZlbCBpZiBhbGwgdGhlIG1vbnN0ZXJzIGFyZSBkZWFkIC0gVE9ETyBhZGQgYSBkZWxheSB0byBzcGFjZSBvdXQgYmV0d2VlbiBsZXZlbHNcbiAgICAgICAgLy8gQ2hlY2tzIHdoZXRoZXIgdGhlcmUgYXJlIGFueSBtb25zdGVycyBsZWZ0IGFuZCB3aGV0aGVyIGFsbCB0aGUgbW9uc3RlcnMgaGF2ZSBiZWVuIGNyZWF0ZWRcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlTW9uc3RlcnMubGVuZ3RoID09PSAwICYmIHRoaXMubW9uc3RlcnNUb0NyZWF0ZSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm5leHRMZXZlbENhbGxlZCkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dExldmVsKCk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCBjb25zdGFudHMuVElNRUJFVFdFRU5MRVZFTFMgKiAxMDAwKTtcblxuICAgICAgICAgICAgICAgIHRoaXMubmV4dExldmVsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlTW9uc3RlcnMuZm9yRWFjaChmdW5jdGlvbihhY3RpdmVNb25zdGVyLCBpLCBtb25zdGVyQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAvLyBtb3ZlcyB0aGUgbW9uc3RlcnMgYW5kIGNoZWNrcyB3aGV0aGVyIHRoZXkgZ2V0IHRvIHRoZSBlbmQgb2YgdGhlIGN5Y2xlXG4gICAgICAgICAgICAgICAgLy8gYWxzbyBmYWN0b3IgdG8gaGF2ZSBhIHByb2plY3RpbGVzIGFycmF5IC0gd2hpY2ggbWVhbnMgdGhhdCBlYWNoIGN5Y2xlIGZvciBtb25zdGVycyB0aGV5IHdpbGwgdGFrZSBkYW1hZ2VcbiAgICAgICAgICAgICAgICB2YXIgbW9uc3RlclN0YXR1cyA9IGFjdGl2ZU1vbnN0ZXIucnVuQ3ljbGUodGhpcy5nYW1lUGF0aCwgZHQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFtb25zdGVyU3RhdHVzLmFsaXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb25zdGVyU3RhdHVzLmdpdmVHb2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXJHb2xkICs9IGFjdGl2ZU1vbnN0ZXIuYm91bnR5XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXJMaXZlcy0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBtb25zdGVyRGVhdGggPSBuZXcgQ3VzdG9tRXZlbnQoXCJ1bml0UmVtb3ZlZFwiLCB7XCJkZXRhaWxcIjoge2luZGV4OiBpLCBlbGVtZW50OiBcIm1vbnN0ZXJcIn19KTtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChtb25zdGVyRGVhdGgpO1xuICAgICAgICAgICAgICAgICAgICBtb25zdGVyQXJyYXkuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgICAgIC8vIFJ1biB0b3dlciBjeWNsZXMgaGVyZSAtIHBhc3MgaW4gYWN0aXZlIG1vbnN0ZXJzIC0gdG93ZXJzIG9ubHkgY3JlYXRlIHByb2plY3RpbGVzXG4gICAgICAgICAgICB0aGlzLnRvd2Vycy5mb3JFYWNoKGZ1bmN0aW9uKHRvd2VyKSB7XG4gICAgICAgICAgICAgICAgdG93ZXIucnVuQ3ljbGUodGhpcy5hY3RpdmVNb25zdGVycywgZHQpOyAvLyBQYXNzIGluIGFjdGl2ZSBtb25zdGVycyBhbmQgYXR0YWNoIHByb2plY3RpbGVzIHRvIHRoZW1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH1cblxuXG4gICAgfVxufVxuXG5HYW1lRW5naW5lLnByb3RvdHlwZS5zZWxsVG93ZXIgPSBmdW5jdGlvbih0b3dlckluZGV4KSB7XG4gICAgdmFyIGdyaWRQb3NpdGlvbiA9IHV0aWxzLmNvbnZlcnRUb0Jsb2NrKHRoaXMudG93ZXJzW3Rvd2VySW5kZXhdLnBvc2l0aW9uKSxcbiAgICAgICAgdG93ZXJEZWF0aCA9IG5ldyBDdXN0b21FdmVudChcInVuaXRSZW1vdmVkXCIsIHtcImRldGFpbFwiOiB7aW5kZXg6IHRvd2VySW5kZXgsIGVsZW1lbnQ6IFwidG93ZXJcIn19KTtcbiAgICAvLyBEaXNwYXRjaCB0aGUgdG93ZXIgZGVhdGggZXZlbnQgZm9yIHRoZSB1aSB0byB1cGRhdGVcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KHRvd2VyRGVhdGgpO1xuXG4gICAgdGhpcy51c2VyR29sZCArPSBNYXRoLmZsb29yKHRoaXMudG93ZXJzW3Rvd2VySW5kZXhdLnRvdGFsQ29zdCAqIDAuNzUpO1xuICAgIHRoaXMudG93ZXJzLnNwbGljZSh0b3dlckluZGV4LCAxKTtcblxuICAgIC8vIFJlbW92ZSB0b3dlciBmcm9tIHRoZSBnYW1lIGdyaWRcbiAgICB0aGlzLmdhbWVHcmlkW2dyaWRQb3NpdGlvbi54XVtncmlkUG9zaXRpb24ueV0uZW1wdHkgPSB0cnVlO1xuICAgIHRoaXMuZ2FtZUdyaWRbZ3JpZFBvc2l0aW9uLnggKyAxXVtncmlkUG9zaXRpb24ueV0uZW1wdHkgPSB0cnVlO1xuICAgIHRoaXMuZ2FtZUdyaWRbZ3JpZFBvc2l0aW9uLnhdW2dyaWRQb3NpdGlvbi55ICsgMV0uZW1wdHkgPSB0cnVlO1xuICAgIHRoaXMuZ2FtZUdyaWRbZ3JpZFBvc2l0aW9uLnggKyAxXVtncmlkUG9zaXRpb24ueSArIDFdLmVtcHR5ID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuR2FtZUVuZ2luZS5wcm90b3R5cGUudXBncmFkZVRvd2VyID0gZnVuY3Rpb24odG93ZXJJbmRleCwgdXBncmFkZU5hbWUpIHtcbiAgICAvLyBDaGVjayBmb3Igc3VmZmljaWVudCBnb2xkXG4gICAgaWYgKHRvd2VyRGF0YVt1cGdyYWRlTmFtZV0uZ29sZENvc3QgPiB0aGlzLnVzZXJHb2xkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDcmVhdGUgYSB0aGUgdXBncmFkZWQgdG93ZXIgYXQgdGhlIHNhbWUgcG9zaXRpb24gYW5kIHJlcGxhY2UgdGhhdCBpbiB0aGUgdG93ZXJzIGFycmF5XG4gICAgICAgIHZhciB1cGdyYWRlZFRvd2VyID0gbmV3IFRvd2VyKHRoaXMudG93ZXJzW3Rvd2VySW5kZXhdLnBvc2l0aW9uLCB1cGdyYWRlTmFtZSk7XG4gICAgICAgIHRoaXMudXNlckdvbGQgLT0gdG93ZXJEYXRhW3VwZ3JhZGVOYW1lXS5nb2xkQ29zdDtcbiAgICAgICAgdGhpcy50b3dlcnMuc3BsaWNlKHRvd2VySW5kZXgsIDEsIHVwZ3JhZGVkVG93ZXIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbi8qXG5UYWtlcyBpbiBhIGdyaWRQb3NpdGlvbiBvYmplY3QgKHBvaW50cyB0byB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB0b3dlcilcblRvd2VycyB0YWtlIHVwIGEgMngyIGdyaWQgLSB0aGlzIGZ1bmN0aW9uIGNoZWNrcyBhbGwgcG9zaXRpb25zXG5SZXR1cm5zIHRydWUgaWYgdGhlIHBvc2l0aW9uIGlzIGEgdmFsaWQgcGxhY2VtZW50IGZvciBhIHRvd2VyXG5SZXR1cm5zIGZhbHNlIGlmIHRoZSBwb3NpdGlvbiBpcyBpbnZhbGlkXG4qL1xuR2FtZUVuZ2luZS5wcm90b3R5cGUudmFsaWRhdGVUb3dlclBsYWNlbWVudCA9IGZ1bmN0aW9uKGdyaWRQb3NpdGlvbikge1xuICAgIC8vIENoZWNrcyBhbGwgNCBwb3NpdGlvbnNcbiAgICB2YXIgcG9zaXRpb25WYWxpZCA9IHRoaXMuZ2FtZUdyaWRbZ3JpZFBvc2l0aW9uLnhdW2dyaWRQb3NpdGlvbi55XS5lbXB0eVxuICAgICYmIHRoaXMuZ2FtZUdyaWRbZ3JpZFBvc2l0aW9uLnggKyAxXVtncmlkUG9zaXRpb24ueV0uZW1wdHlcbiAgICAmJiB0aGlzLmdhbWVHcmlkW2dyaWRQb3NpdGlvbi54XVtncmlkUG9zaXRpb24ueSArIDFdLmVtcHR5XG4gICAgJiYgdGhpcy5nYW1lR3JpZFtncmlkUG9zaXRpb24ueCArIDFdW2dyaWRQb3NpdGlvbi55ICsgMV0uZW1wdHk7XG4gICAgcmV0dXJuIHBvc2l0aW9uVmFsaWQ7XG59XG5cbi8qXG5JbnB1dDogUGF0aCAtIGFuIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyBjb29yZGluYXRlcyB3aGVyZSB0aGUgcGF0aCB3aWxsIHJ1biB0b1xuT3V0cHV0OiBwYXRoTGluZXMgLSBhbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIHN0YXJ0UG9pbnQgKGNvb3JkaW5hdGVzKSxcbiAgICAgICAgZGlzdGFuY2Ugb2YgdGhlIGxpbmUgYW5kIGRpcmVjdGlvbiAobGVmdCwgcmlnaHQsIHVwLCBkb3duKVxuKi9cbmZ1bmN0aW9uIF9jb252ZXJ0UGF0aFRvTGluZXMocGF0aCkge1xuICAgIHZhciBwYXRoTGluZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHZhciBsaW5lID0ge307XG5cbiAgICAgICAgLy8gQXNzdW1lIHRoYXQgdGhlIGRpcmVjdGlvbiBpcyBvbmx5IDQgd2F5c1xuICAgICAgICBpZiAocGF0aFtpKzFdLnggLSBwYXRoW2ldLnggPT09IDApIHtcblxuICAgICAgICAgICAgaWYgKHBhdGhbaSsxXS55IC0gcGF0aFtpXS55ID4gMCkge1xuICAgICAgICAgICAgICAgIGxpbmUuZGlyZWN0aW9uID0gXCJkb3duXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpbmUuZGlyZWN0aW9uID0gXCJ1cFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBhdGhbaSsxXS54IC0gcGF0aFtpXS54ID09PSAwID4gMCkge1xuICAgICAgICAgICAgICAgIGxpbmUuZGlyZWN0aW9uID0gXCJsZWZ0XCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpbmUuZGlyZWN0aW9uID0gXCJyaWdodFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxpbmUuc3RhcnRQb2ludCA9IHBhdGhbaV07XG4gICAgICAgIGxpbmUuZGlzdGFuY2UgPSB1dGlscy5nZXRQb3NpdGlvbkRpZmZlcmVuY2UocGF0aFtpXSwgcGF0aFtpKzFdKTtcbiAgICAgICAgcGF0aExpbmVzLnB1c2gobGluZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhMaW5lcztcbn1cblxuLypcbkNvbnZlcnRzIGEgcGF0aExpbmVzIGFycmF5IChhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggYSBzdGFydFBvaW50LFxuZGlyZWN0aW9uIGFuZCBhIGRpc3RhbmNlKSBpbnRvIGFuIGFycmF5IG9mIGdyaWQgYmxvY2tzICgpXG5Ob3RlIHRoYXQgdGhlcmUgd2lsbCBiZSBzb21lIG92ZXJsYXAgd2l0aCBibG9ja3MsIGhvd2V2ZXIsXG5hcyB0aGV5IGFyZSBvbmx5IHVzZWQgdG8gc2V0IGdyaWQgcG9zaXRpb25zIHRvIG5vdCBlbXB0eSwgb3ZlcmxhcCBpcyBub3QgYW4gaXNzdWVcbiovXG5mdW5jdGlvbiBfY3JlYXRlUGF0aEJsb2NrcyhwYXRoTGluZXMpIHtcbiAgICB2YXIgYmxvY2tzID0gW107XG4gICAgLy8gTG9vcHMgdGhyb3VnaCBhbGwgdGhlIHBhdGhMaW5lcyBhbmQgY3JlYXRlcyBibG9ja3MgYmFzZWQgb24gdGhhdFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIGJsb2NrQW1vdW50IHJlZmVycyB0byB0aGUgYW1vdW50IG9mIGJsb2NrcyB0aGF0IGZvbGxvdyB0aGUgcGF0aFxuICAgICAgICB2YXIgYmxvY2tBbW91bnQgPSBNYXRoLmZsb29yKHBhdGhMaW5lc1tpXS5kaXN0YW5jZSAvIGNvbnN0YW50cy5HUklEU0laRSkgKyAxLFxuICAgICAgICAgICAgcGF0aERpcmVjdGlvbjtcbiAgICAgICAgLyogU2V0IGRpcmVjdGlvblxuICAgICAgICB4OiAxID0gcmlnaHRcbiAgICAgICAgeDogLTEgPSBsZWZ0XG4gICAgICAgIHk6IDEgPSBkb3duXG4gICAgICAgIHk6IC0xID0gdXBcbiAgICAgICAgT2Zmc2V0IHZhbHVlcyBoZWxwIGNlbnRlciB0aGUgZ3JpZCBibG9ja3MgKGkuZS4gaW5saW5lIHdpdGggdGhlIGRpcmVjdGlvbilcbiAgICAgICAgU2lkZSB2YWx1ZXMgYXJlIHVzZWQgdG8gZGVmaW5lIHdoaWNoIHNpZGUgdGhlIGJsb2NrcyBhcmUgb24gcmVsYXRpdmUgdG9cbiAgICAgICAgdGhlIHBhdGggZGlyZWN0aW9uIChpLmUuIGhvcml6b250YWxseSBvciB2ZXJ0aWNhbGx5KVxuICAgICAgICAqL1xuICAgICAgICBzd2l0Y2ggKHBhdGhMaW5lc1tpXS5kaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgXCJ1cFwiOlxuICAgICAgICAgICAgICAgIHBhdGhEaXJlY3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgIHk6IC0xLFxuICAgICAgICAgICAgICAgICAgICB4U2lkZTogY29uc3RhbnRzLkdSSURTSVpFIC8gMixcbiAgICAgICAgICAgICAgICAgICAgeVNpZGU6IDBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZG93blwiOlxuICAgICAgICAgICAgICAgIHBhdGhEaXJlY3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgIHk6IDEsXG4gICAgICAgICAgICAgICAgICAgIHhTaWRlOiBjb25zdGFudHMuR1JJRFNJWkUgLyAyLFxuICAgICAgICAgICAgICAgICAgICB5U2lkZTogMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgICAgICAgcGF0aERpcmVjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogLTEsXG4gICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIHhTaWRlOiAwLFxuICAgICAgICAgICAgICAgICAgICB5U2lkZTogY29uc3RhbnRzLkdSSURTSVpFIC8gMlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgICAgICAgIHBhdGhEaXJlY3Rpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IDEsXG4gICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIHhTaWRlOiAwLFxuICAgICAgICAgICAgICAgICAgICB5U2lkZTogY29uc3RhbnRzLkdSSURTSVpFIC8gMlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkaXJlY3Rpb24gcHJvdmlkZWQgaW4gcGF0aExpbmVzXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAgQ3JlYXRlcyBibG9jayBlcXVhbCB0byBkb3VibGUgdGhlIGFtb3VudCBvZiB0aGUgYmxvY2tBbW91bnQgKHRoZSBlcXVpdmFsZW50IGFtb3VudCBvZiBibG9ja3MgdG8gdGhlIHBhdGggZGlzdGFuY2UpXG4gICAgICAgIGJsb2NrQmVmb3JlIHJlZmVycyB0byBibG9ja3MgZWl0aGVyIHRvIHRoZSBsZWZ0IG9yIHRvcCBvZiB0aGUgcGF0aFxuICAgICAgICBibG9ja0FmdGVyIHJlZmVycyB0byBibG9ja3MgZWl0aGVyIHRvIHRoZSByaWdodCBvciBiZWxvdyBvZiB0aGUgcGF0aFxuICAgICAgICBDcmVhdGVzIGJsb2NrIGxvY2F0aW9ucyBhbmQgZ2l2ZXMgdGhlbSBvZmZzZXRzIHRvIHRoZWlyIGNlbnRlciBwb3NpdGlvbnMgKGZvciBjbGFyaXR5IGluIGNvbnZlcnRpbmcgdG8gYmxvY2tzKVxuICAgICAgICAqL1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJsb2NrQW1vdW50OyBqKyspIHtcblxuICAgICAgICAgICAgdmFyIGJsb2NrQmVmb3JlID0ge1xuXG4gICAgICAgICAgICAgICAgeDogcGF0aExpbmVzW2ldLnN0YXJ0UG9pbnQueCAtXG4gICAgICAgICAgICAgICAgICAgIHBhdGhEaXJlY3Rpb24ueFNpZGUgK1xuICAgICAgICAgICAgICAgICAgICAocGF0aERpcmVjdGlvbi54ICogY29uc3RhbnRzLkdSSURTSVpFICogaikgK1xuICAgICAgICAgICAgICAgICAgICAocGF0aERpcmVjdGlvbi54ICogY29uc3RhbnRzLkdSSURTSVpFIC8gMiksIC8vIEFkZHMgYSBzbGlnaHQgb2Zmc2V0XG5cbiAgICAgICAgICAgICAgICB5OiBwYXRoTGluZXNbaV0uc3RhcnRQb2ludC55IC1cbiAgICAgICAgICAgICAgICAgICAgcGF0aERpcmVjdGlvbi55U2lkZSArXG4gICAgICAgICAgICAgICAgICAgIChwYXRoRGlyZWN0aW9uLnkgKiBjb25zdGFudHMuR1JJRFNJWkUgKiBqICkgK1xuICAgICAgICAgICAgICAgICAgICAocGF0aERpcmVjdGlvbi55ICogY29uc3RhbnRzLkdSSURTSVpFIC8gMikgLy8gQWRkcyBhIHNsaWdodCBvZmZzZXRcblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBibG9ja0FmdGVyID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBwYXRoTGluZXNbaV0uc3RhcnRQb2ludC54ICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhEaXJlY3Rpb24ueFNpZGUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHBhdGhEaXJlY3Rpb24ueCAqIGNvbnN0YW50cy5HUklEU0laRSAqIGopICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChwYXRoRGlyZWN0aW9uLnggKiBjb25zdGFudHMuR1JJRFNJWkUgLyAyKSwgLy8gQWRkcyBhIHNsaWdodCBvZmZzZXRcblxuICAgICAgICAgICAgICAgICAgICB5OiBwYXRoTGluZXNbaV0uc3RhcnRQb2ludC55ICArXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoRGlyZWN0aW9uLnlTaWRlICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChwYXRoRGlyZWN0aW9uLnkgKiBjb25zdGFudHMuR1JJRFNJWkUgKiBqKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAocGF0aERpcmVjdGlvbi55ICogY29uc3RhbnRzLkdSSURTSVpFIC8gMikgLy8gQWRkcyBhIHNsaWdodCBvZmZzZXRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBFZGdlIGNhc2UgZm9yIHdoZW4gdGhlIHBhdGggZXhpdHMgdGhlIHNjcmVlbiAodGhlcmUgaXMgZGVmaW5pdGVseSBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMpXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHN1Y2ggYSBiYWQgc29sdXRpb24gbG9sLlxuICAgICAgICAgICAgaWYgKGJsb2NrQmVmb3JlLnggPCBjb25zdGFudHMuQ0FOVkFTV0lEVEggJiYgYmxvY2tCZWZvcmUueSA8IGNvbnN0YW50cy5DQU5WQVNIRUlHSFQpIHtcbiAgICAgICAgICAgICAgICBibG9ja3MucHVzaCh1dGlscy5jb252ZXJ0VG9CbG9jayhibG9ja0JlZm9yZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJsb2NrQWZ0ZXIueCA8IGNvbnN0YW50cy5DQU5WQVNXSURUSCAmJiBibG9ja0FmdGVyLnkgPCBjb25zdGFudHMuQ0FOVkFTSEVJR0hUKSB7XG4gICAgICAgICAgICAgICAgYmxvY2tzLnB1c2godXRpbHMuY29udmVydFRvQmxvY2soYmxvY2tBZnRlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJsb2Nrc1xufVxuXG4vLyBHcmlkIGlzIDM2IGJ5IDI0XG4vLyBjYW4gYmUgaW5pdGlhdGVkIGJ5IFt4XVt5XSAtIGVhY2ggYmxvY2sgaGFzIGEgYm9vbGVhbiB0byByZXByZXNlbnQgd2hldGhlciBzb21ldGhpbmcgaXMgdGhlcmVcbmZ1bmN0aW9uIF9pbml0aWF0ZUdyaWQocGF0aExpbmVzKSB7XG4gICAgdmFyIGdyaWQgPSBbXSxcbiAgICAgICAgYmxvY2tzID0gX2NyZWF0ZVBhdGhCbG9ja3MocGF0aExpbmVzKSxcbiAgICAgICAgeEdyaWRBbW91bnQgPSBjb25zdGFudHMuQ0FOVkFTV0lEVEggLyBjb25zdGFudHMuR1JJRFNJWkUsXG4gICAgICAgIHlHcmlkQW1vdW50ID0gY29uc3RhbnRzLkNBTlZBU0hFSUdIVCAvIGNvbnN0YW50cy5HUklEU0laRTtcblxuICAgIC8vIENyZWF0ZSB0aGUgZ3JpZFxuICAgIGZvciAodmFyIHggPSAwOyB4IDwgeEdyaWRBbW91bnQ7IHgrKykge1xuICAgICAgICBncmlkW3hdID0gW107XG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgeUdyaWRBbW91bnQ7IHkrKykge1xuICAgICAgICAgICAgZ3JpZFt4XVt5XSA9IHtcbiAgICAgICAgICAgICAgICBlbXB0eTogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBMb29wIHRocm91Z2ggdGhlIGJsb2NrcyAod2hpY2ggYXJlIG9uIHRoZSBwYXRoKSBhbmRcbiAgICBibG9ja3MuZm9yRWFjaChmdW5jdGlvbihibG9jaykge1xuICAgICAgICBncmlkW2Jsb2NrLnhdW2Jsb2NrLnldID0ge1xuICAgICAgICAgICAgZW1wdHk6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZ3JpZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2FtZUVuZ2luZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2NsYXNzZXMvR2FtZS5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ2YXIgbW9uc3RlckRhdGEgPSByZXF1aXJlKFwiLi4vZ2FtZURhdGEvbW9uc3RlcmRhdGEuanNcIiksXG4gICAgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMuanNcIiksXG4gICAgY29uc3RhbnRzID0gcmVxdWlyZShcIi4uL2dhbWVEYXRhL2dhbWVDb25zdGFudHMuanNcIik7XG5cbnZhciBNb25zdGVyID0gZnVuY3Rpb24oaWQsIG11bHRpcGxpZXIpIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5jdXJyZW50SHAgPSBNYXRoLmZsb29yKG1vbnN0ZXJEYXRhW2lkXS5tYXhIcCAqIG11bHRpcGxpZXIpO1xuICAgIHRoaXMubWF4SHAgPSBNYXRoLmZsb29yKG1vbnN0ZXJEYXRhW2lkXS5tYXhIcCAqIG11bHRpcGxpZXIpO1xuICAgIHRoaXMuYmFzZU1zID0gbW9uc3RlckRhdGFbaWRdLmJhc2VNczsgLy8gTW92ZW1lbnQgc3BlZWQgLSBcInVuaXRzXCIgcGVyIHNlY29uZFxuICAgIHRoaXMudHlwZSA9IG1vbnN0ZXJEYXRhW2lkXS50eXBlO1xuICAgIHRoaXMuYm91bnR5ID0gTWF0aC5mbG9vcihtb25zdGVyRGF0YVtpZF0uYm91bnR5ICogbXVsdGlwbGllcik7XG4gICAgdGhpcy5wcm9qZWN0aWxlcyA9IFtdO1xuICAgIHRoaXMuZGlzdGFuY2VUcmF2ZWxsZWQgPSAwO1xuICAgIHRoaXMucG9zaXRpb24gPSB7fTsgLy8gSW5pdGlhbCBwb3NpdGlvbiBpcyBkZWZpbmVkIGJ5IHRoZSBwYXRoXG4gICAgdGhpcy5zaWRlTGVuZ3RoID0gY29uc3RhbnRzLk1PTlNURVJMRU5HVEg7XG59O1xuLy8gTWV0aG9kIHRoZSBnYW1lIG9iamVjdCB1c2VzIHRvIG1vdmUgbW9uc3RlcnNcbk1vbnN0ZXIucHJvdG90eXBlLnJ1bkN5Y2xlID0gZnVuY3Rpb24oZ2FtZVBhdGgsIGR0KSB7XG4gICAgdmFyIHN0YXR1cyA9IHt9O1xuICAgIHRoaXMubW92ZShnYW1lUGF0aCwgZHQpO1xuXG4gICAgdGhpcy5wcm9qZWN0aWxlcy5mb3JFYWNoKGZ1bmN0aW9uKHByb2plY3RpbGUsIGksIHByb2plY3RpbGVBcnJheSkge1xuICAgICAgICBwcm9qZWN0aWxlLm1vdmUoZHQpO1xuICAgICAgICBpZiAocHJvamVjdGlsZS5lbmQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSHAoLXByb2plY3RpbGUuZGFtYWdlKTtcbiAgICAgICAgICAgIHByb2plY3RpbGVBcnJheS5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5jaGVja0RlYXRoKCk7XG5cbiAgICBpZiAodGhpcy5jaGVja0RlYXRoKCkpIHtcbiAgICAgICAgc3RhdHVzLmFsaXZlID0gZmFsc2U7XG4gICAgICAgIHN0YXR1cy5naXZlR29sZCA9ICF0aGlzLnBvc2l0aW9uLmVuZDsgLy8gRG9lcyBub3QgZ2l2ZSBnb2xkIGlmIHRoZSBtb25zdGVyIHJlYWNoZWQgdGhlIGVuZFxuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXR1cy5hbGl2ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXR1cztcbn1cblxuTW9uc3Rlci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKCkge1xuICAgIGR5bmFtaWNDb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGR5bmFtaWNDb250ZXh0LnJlY3QodGhpcy5wb3NpdGlvbi54LCB0aGlzLnBvc2l0aW9uLnksIGNvbnN0YW50cy5NT05TVEVSTEVOR1RILCBjb25zdGFudHMuTU9OU1RFUkxFTkdUSCk7XG4gICAgZHluYW1pY0NvbnRleHQuc3Ryb2tlKCk7XG4gICAgZHluYW1pY0NvbnRleHQuZmlsbFN0eWxlID0gXCJyZWRcIjtcbiAgICBkeW5hbWljQ29udGV4dC5maWxsUmVjdCh0aGlzLnBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi55ICsgY29uc3RhbnRzLk1PTlNURVJMRU5HVEgvMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdGFudHMuTU9OU1RFUkxFTkdUSCAqIHRoaXMuY3VycmVudEhwL3RoaXMubWF4SHAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRzLk1PTlNURVJMRU5HVEgvMyk7XG4gICAgZHluYW1pY0NvbnRleHQuY2xvc2VQYXRoKCk7XG5cbn1cblxuTW9uc3Rlci5wcm90b3R5cGUuY2hlY2tEZWF0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRIcCA8PSAwIHx8IHRoaXMucG9zaXRpb24uZW5kO1xufTtcblxuTW9uc3Rlci5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKHBhdGhMaW5lcywgZHQpIHtcbiAgICB0aGlzLmRpc3RhbmNlVHJhdmVsbGVkICs9IHRoaXMuYmFzZU1zICogZHQ7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHV0aWxzLmNvbnZlcnREaXN0YW5jZVRvQ29vcmRpbmF0ZXModGhpcy5kaXN0YW5jZVRyYXZlbGxlZCwgcGF0aExpbmVzKTtcbn07XG5cbi8vIENhbiB0YWtlIGluIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgbnVtYmVyXG5Nb25zdGVyLnByb3RvdHlwZS51cGRhdGVIcCA9IGZ1bmN0aW9uKGhwQ2hhbmdlKSB7XG4gICAgdGhpcy5jdXJyZW50SHAgKz0gaHBDaGFuZ2U7XG5cbiAgICBpZiAodGhpcy5jdXJyZW50SHAgPiB0aGlzLm1heEhwKSB7XG4gICAgICAgIHRoaXMuY3VycmVudEhwID0gdGhpcy5tYXhIcDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vbnN0ZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9jbGFzc2VzL01vbnN0ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGJhc2ljOiB7XG4gICAgICAgIG1heEhwOiAzMCxcbiAgICAgICAgYmFzZU1zOiA1MCwgLy8gcGl4ZWxzIHBlciBzZWNvbmRcbiAgICAgICAgdHlwZTogXCJub3JtYWxcIiwgLy8gQ2hhbmdlIHRoaXMgdHlwZSBsYXRlclxuICAgICAgICBib3VudHk6IDNcbiAgICB9LFxuICAgIGZhc3Q6IHtcbiAgICAgICAgbWF4SHA6IDMwLFxuICAgICAgICBiYXNlTXM6IDEwMCwgLy8gcGl4ZWxzIHBlciBzZWNvbmRcbiAgICAgICAgdHlwZTogXCJub3JtYWxcIiwgLy8gQ2hhbmdlIHRoaXMgdHlwZSBsYXRlclxuICAgICAgICBib3VudHk6IDRcbiAgICB9LFxuICAgIHRhbms6IHtcbiAgICAgICAgbWF4SHA6IDYwLFxuICAgICAgICBiYXNlTXM6IDMwLFxuICAgICAgICB0eXBlOiBcIm5vcm1hbFwiLFxuICAgICAgICBib3VudHk6IDRcbiAgICB9LFxuICAgIGZpcmU6IHtcbiAgICAgICAgbWF4SHA6IDMwLFxuICAgICAgICBiYXNlTXM6IDcwLFxuICAgICAgICB0eXBlOiBcImZpcmVcIixcbiAgICAgICAgYm91bnR5OiA0XG4gICAgfSxcbiAgICBpY2U6IHtcbiAgICAgICAgbWF4SHA6IDQ1LFxuICAgICAgICBiYXNlTXM6IDQwLFxuICAgICAgICB0eXBlOiBcImljZVwiLFxuICAgICAgICBib3VudHk6IDVcbiAgICB9LFxuICAgIGxpZ2h0OiB7XG4gICAgICAgIG1heEhwOiAyMCxcbiAgICAgICAgYmFzZU1zOiAxMDAsXG4gICAgICAgIHR5cGU6IFwibGlnaHRcIixcbiAgICAgICAgYm91bnR5OiA0XG4gICAgfSxcbiAgICBib3NzMToge1xuICAgICAgICBtYXhIcDogNTAwLFxuICAgICAgICBiYXNlTXM6IDgwLFxuICAgICAgICB0eXBlOiBcIm5vcm1hbFwiLFxuICAgICAgICBib3VudHk6IDIwXG4gICAgfSxcbiAgICBib3NzMjoge1xuICAgICAgICBtYXhIcDogMTUwMCxcbiAgICAgICAgYmFzZU1zOiA4MCxcbiAgICAgICAgdHlwZTogXCJmaXJlXCIsXG4gICAgICAgIGJvdW50eTogNDBcbiAgICB9LFxuICAgIGJvc3MzOiB7XG4gICAgICAgIG1heEhwOiAyNTAwLFxuICAgICAgICBiYXNlTXM6IDEwMCxcbiAgICAgICAgdHlwZTogXCJmaXJlXCIsXG4gICAgICAgIGJvdW50eTogMTAwXG4gICAgfSxcbiAgICBib3NzNDoge1xuICAgICAgICBtYXhIcDogNDUwMCxcbiAgICAgICAgYmFzZU1zOiA4NSxcbiAgICAgICAgdHlwZTogXCJmaXJlXCIsXG4gICAgICAgIGJvdW50eTogNDBcbiAgICB9LFxuICAgIGJvc3M1OiB7XG4gICAgICAgIG1heEhwOiA2MDAwLFxuICAgICAgICBiYXNlTXM6IDk1LFxuICAgICAgICB0eXBlOiBcImZpcmVcIixcbiAgICAgICAgYm91bnR5OiA0MFxuICAgIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9nYW1lRGF0YS9tb25zdGVyZGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGV4cG9ydERhdGEgPSBbXSxcbiAgICBjdXJyZW50TGV2ZWwsXG4gICAgbW9uc3Rlckxvb2t1cCA9IFtcbiAgICB7XG4gICAgICAgIHR5cGU6IFwiYmFzaWNcIixcbiAgICAgICAgYW1vdW50OiAxMFxuICAgIH0sXG4gICAge1xuICAgICAgICB0eXBlOiBcImZpcmVcIixcbiAgICAgICAgYW1vdW50OiAxMFxuICAgIH0sXG4gICAge1xuICAgICAgICB0eXBlOiBcImljZVwiLFxuICAgICAgICBhbW91bnQ6IDhcbiAgICB9LFxuICAgIHtcbiAgICAgICAgdHlwZTogXCJsaWdodFwiLFxuICAgICAgICBhbW91bnQ6IDEwXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6IFwidGFua1wiLFxuICAgICAgICBhbW91bnQ6IDEyXG4gICAgfSxcbiAgICB7XG4gICAgICAgIHR5cGU6IFwiZmFzdFwiLFxuICAgICAgICBhbW91bnQ6IDE1XG4gICAgfVxuXTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCA1MDsgaSsrKSB7XG4gICAgc3dpdGNoIChpKSB7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJib3NzMVwiLFxuICAgICAgICAgICAgICAgIGFtb3VudDogNFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgY3VycmVudExldmVsID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYm9zczJcIixcbiAgICAgICAgICAgICAgICBhbW91bnQ6IDJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzMDpcbiAgICAgICAgICAgIGN1cnJlbnRMZXZlbCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJvc3MzXCIsXG4gICAgICAgICAgICAgICAgYW1vdW50OiAyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJib3NzNFwiLFxuICAgICAgICAgICAgICAgIGFtb3VudDogM1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDUwOlxuICAgICAgICAgICAgY3VycmVudExldmVsID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYm9zczVcIixcbiAgICAgICAgICAgICAgICBhbW91bnQ6IDNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgY3VycmVudExldmVsID0gbW9uc3Rlckxvb2t1cFtpJTZdO1xuICAgIH1cbiAgICBleHBvcnREYXRhLnB1c2goY3VycmVudExldmVsKVxufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnREYXRhO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvZ2FtZURhdGEvbGV2ZWxkYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBwYXRoOiBbXG4gICAgICAgIHt4OiAwLCB5OiA1MDB9LFxuICAgICAgICB7eDogNzUsIHk6IDUwMH0sXG4gICAgICAgIHt4OiA3NSwgeTogMTAwfSxcbiAgICAgICAge3g6IDIyNSwgeTogMTAwfSxcbiAgICAgICAge3g6IDIyNSwgeTogNTAwfSxcbiAgICAgICAge3g6IDM3NSwgeTogNTAwfSxcbiAgICAgICAge3g6IDM3NSwgeTogMTAwfSxcbiAgICAgICAge3g6IDUyNSwgeTogMTAwfSxcbiAgICAgICAge3g6IDUyNSwgeTogNTAwfSxcbiAgICAgICAge3g6IDY3NSwgeTogNTAwfSxcbiAgICAgICAge3g6IDY3NSwgeTogMTAwfSxcbiAgICAgICAge3g6IDgyNSwgeTogMTAwfSxcbiAgICAgICAge3g6IDgyNSwgeTogNTAwfSxcbiAgICAgICAge3g6IDkwMCwgeTogNTAwfVxuICAgIF1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2dhbWVEYXRhL3BhdGhkYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9