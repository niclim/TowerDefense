/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/src/js/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	// Canvas
	__webpack_require__(2);
	
	// User interaction elements
	__webpack_require__(3);


/***/ },
/* 2 */
/***/ function(module, exports) {

	// background contains the static canvas elements
	var background = document.getElementById("static");
	var backgroundContext = background.getContext("2d");
	
	// Settings for the background - move out to a separate file
	var settings = {
	    backgroundColor: "#8CD1E6",
	    pathColor: "gray"
	}
	
	// Drawing the background
	backgroundContext.fillStyle = settings.backgroundColor;
	backgroundContext.fillRect(0, 0, background.width, background.height);
	
	/* Main path will go from [0, 500], [75, 500], [75, 100], [225, 100], [225, 500], [375, 500], [375, 100], [525, 100], [525, 500], [675, 500], [675, 100], [825, 100], [825, 500], [900, 500] */
	
	// Drawing the path - width of the path is 50px
	backgroundContext.fillStyle = settings.pathColor;
	
	backgroundContext.beginPath();
	
	// For the bottom part of the path
	backgroundContext.moveTo(0, 525);
	
	backgroundContext.lineTo(100, 525);
	backgroundContext.lineTo(100, 125); // Top
	backgroundContext.lineTo(200, 125);
	backgroundContext.lineTo(200, 525); // Bottom
	backgroundContext.lineTo(400, 525);
	backgroundContext.lineTo(400, 125); // Top
	backgroundContext.lineTo(500, 125);
	backgroundContext.lineTo(500, 525); // Bottom
	backgroundContext.lineTo(700, 525);
	backgroundContext.lineTo(700, 125); // Top
	backgroundContext.lineTo(800, 125);
	backgroundContext.lineTo(800, 525); // Bottom
	
	//Middle section to the side
	backgroundContext.lineTo(900, 525);
	backgroundContext.lineTo(900, 475);
	backgroundContext.lineTo(850, 475);
	
	// For the top part of the path
	backgroundContext.lineTo(850, 75);
	backgroundContext.lineTo(650, 75);
	backgroundContext.lineTo(650, 475);
	backgroundContext.lineTo(550, 475);
	backgroundContext.lineTo(550, 75);
	backgroundContext.lineTo(350, 75);
	backgroundContext.lineTo(350, 475);
	backgroundContext.lineTo(250, 475);
	backgroundContext.lineTo(250, 75);
	backgroundContext.lineTo(50, 75);
	backgroundContext.lineTo(50, 475);
	
	// End section
	backgroundContext.lineTo(0, 475);
	
	backgroundContext.fill();
	// backgroundContext.lineTo();


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	// NOTE At some point I think we can move some functions into a different file
	
	// Initiate all the components
	var Tower = __webpack_require__(4),
	    GameEngine = __webpack_require__(6),
	    monsterData = __webpack_require__(8),
	    towerData = __webpack_require__(5);
	
	// Cache reused DOM elements
	var infoName = document.getElementById("info-name"),
	    infoIcon = document.getElementById("info-icon"),
	    infoBox1 = document.getElementById("info-box-1"),
	    infoBox2 = document.getElementById("info-box-2"),
	    infoBox3 = document.getElementById("info-box-3"),
	    infoBox4 = document.getElementById("info-box-4");
	
	var towerCards = document.getElementsByClassName("tower-card");
	var towerCardList = [];
	
	//  creates global variables
	game = new GameEngine;
	dynamicCanvas = document.getElementById('dynamic');
	dynamicContext = dynamicCanvas.getContext('2d');
	
	// create state variables
	var activeCanvasElement = {type: null}, // initiate default as null
	    activeTowerSelected = null;
	
	runCycle = function() {
	    game.runCycle();
	    setTimeout(runCycle, 1000);
	}
	
	renderCycle = function() {
	    game.render();
	    renderInformationContainer(); // Renders the information container
	    requestAnimationFrame(renderCycle);
	}
	
	// HERE IS ALL THE INTERACTION EVENT LISTENERS
	
	/* ============== On start click handlers ==============*/
	/* =====================================================*/
	
	// On start, create a game element - these event listeners will be destroyed when the container is overriden
	document.getElementById("start-btn").addEventListener("click", function() {
	    // Hides the modal lightbox
	    document.getElementsByClassName("modal-content")[0].style.display = "none";
	    document.getElementsByClassName("modal-background")[0].style.display = "none";
	
	    // run repeating function that runs game engine run cycle and rendering
	    setTimeout(runCycle, 1000);
	    requestAnimationFrame(renderCycle);
	});
	
	// On clicking the information button, show the information panel
	document.getElementById("information-btn").addEventListener("click", function() {
	    console.log("show information container here");
	});
	
	/* ======== Information container interactions =========*/
	/* =====================================================*/
	
	
	
	/* ================= Information Click =================*/
	/* =====================================================*/
	// Shows information about towers or monsters if hovered over
	// or active
	
	// Runs every game cycle
	function renderInformationContainer() {
	    if (activeCanvasElement.type === "monster") {
	        renderMonsterInformation(activeCanvasElement.id, activeCanvasElement.index);
	    } else if (activeCanvasElement.type === "tower") {
	        renderTowerInformation(activeCanvasElement.id, activeCanvasElement.index);
	    } else {
	        renderDefaultInformation();
	    }
	}
	
	function comparePositions(clickPosition, elementPosition, type) {
	    var sideLength = type === "monster" ? 30 : 50; // width and height of the element
	    if (clickPosition.x >= elementPosition.x
	    && clickPosition.x <= elementPosition.x + sideLength
	    && clickPosition.y >= elementPosition.y
	    && clickPosition.y <= elementPosition.y + sideLength) {
	        return true;
	    } else {
	        return false;
	    }
	}
	
	// Takes in a position object (location of the click)
	// returns an object with information about what is at that position
	function checkClickLocation(position) {
	    var element = {};
	    // Loops through activeMonsters
	    for (var i = 0; i < game.activeMonsters.length; i++) {
	        if (comparePositions(position, game.activeMonsters[i].position, "monster")) {
	            element.type = "monster";
	            element.id = game.activeMonsters[i].id;
	            element.index = i;
	            break;
	        }
	    }
	
	    // If nothing was found, loop through towers
	    if (element.type === undefined) {
	        for (var i = 0; i < game.towers.length; i++) {
	            if (comparePositions(position, game.towers[i].position, "tower")) {
	                element.type = "tower";
	                element.id = game.towers[i].id;
	                element.index = i;
	                break;
	            }
	        }
	    }
	
	    // If no towers or monsters found return a type of null
	    if (element.type === undefined) {
	        element.type = null;
	    }
	
	    return element;
	}
	
	// ID refers to the type of monster and index is the index of the active monster in the active monster's array
	function renderMonsterInformation(id, index) {
	    var currentHp = game.activeMonsters[index].currentHp,
	        maxHp = game.activeMonsters[index].maxHp,
	        type = game.activeMonsters[index].type;
	    infoName.innerHTML = id;
	    // Change icon to active monster - use a sprite
	    infoBox1.innerHTML = "HP: " + currentHp + " / " + maxHp;
	    infoBox2.innerHTML = "Type: " + type;
	    infoBox3.innerHTML = "Strengths: All sorts mate" ;
	    infoBox4.innerHTML = "Weaknesses: Ducks" ;
	}
	
	// ID refers to the type of tower and index is the index of the active tower in the active tower's array
	function renderTowerInformation(id, index) {
	    infoName.innerHTML = id;
	    // Change icon to active monster - use a sprite
	    infoBox1.innerHTML = "Damage: <br> Range: <br> Effect: ";
	    infoBox2.innerHTML = "Attack Speed: <br> Type: " ;
	    infoBox3.innerHTML = "<a class='waves-effect waves-light btn red'>Upgrade</a>" ;
	    infoBox4.innerHTML = "<a class='waves-effect waves-light btn red'>Sell</a>" ;
	    // Change icon to tower monster - use a sprite
	
	}
	
	function renderDefaultInformation() {
	    infoName.innerHTML = "Awesome TD";
	    // Change icon to default image - use a sprite
	    infoBox1.innerHTML = "This is some text";
	    infoBox2.innerHTML = "This is different text";
	    infoBox3.innerHTML = "This is ??? text" ;
	    infoBox4.innerHTML = "This 1231241235" ;
	}
	
	// Get information from towerdata.js
	
	/* ========== Tower Card Click and placements ==========*/
	/* =====================================================*/
	// Click a tower card and make "active" which can be placed on UI element
	// While it is active - use #dynamic.onmousemove = function -> to Send
	// information to the canvas
	
	// set up event listeners at the start which reference functions - these functions depend on the state on the application to control their control flow
	
	function addClass(element, cssClass) {
	    if (element.className === "") {
	        element.className = cssClass;
	    } else {
	        element.className += " " + cssClass;
	    }
	}
	
	function removeClass(element, cssClass) {
	    var arrayOfClasses = element.className.split(" ");
	    for (var i = 0, j = arrayOfClasses.length; i < j; i++) {
	        if (arrayOfClasses[i] === cssClass) {
	            arrayOfClasses.splice(i, 1);
	            i--; j--;
	        }
	    }
	    element.className = arrayOfClasses.join(" ");
	}
	
	function getIndex(towerName) {
	    return towerCardList.indexOf(towerName);
	}
	
	function towerCardClick() {
	
	    var towerName = this.getAttribute("data-tower");
	
	    if (/disabled/i.test(this.className)) { // Tower is disabled
	        return;
	    } else if (activeTowerSelected === null) { // There is no active tower being placed
	        // set the active tower selected to be the tower name
	        // Set up active elements
	        activeTowerSelected = towerName;
	        addClass(towerCards[getIndex(activeTowerSelected)], "active");
	    } else if (activeTowerSelected === towerName) { // The tower card clicked is the same as the active tower
	        cancelTowerPlacement();
	    } else { // There is an active tower which is not the same as what was clicked
	        removeClass(towerCards[getIndex(activeTowerSelected)], "active");
	        activeTowerSelected = towerName;
	        addClass(towerCards[getIndex(activeTowerSelected)], "active");
	    }
	}
	
	function onTowerMouseMovement(e) {
	    if (activeTowerSelected === null) {
	        return
	    };
	    var canvasContainer = this.getBoundingClientRect();
	    var offsetX = e.clientX - canvasContainer.left,
	        offsetY = e.clientY - canvasContainer.top;
	    // send to display to get rendered
	};
	
	// Two possible canvas click scenarios:
	// 1) Tower selection is active (place a tower)
	// 2) Tower selection is inactive (clicking to get information about a monster or tower on the map)
	function canvasClick(e) {
	    // Get click location relative to the canvas element
	    var canvasContainer = this.getBoundingClientRect(),
	    position = {};
	
	    position.x = e.clientX - canvasContainer.left;
	    position.y = e.clientY - canvasContainer.top;
	
	    if (activeTowerSelected !== null) { //
	        var towerName = activeTowerSelected; // NOTE CHANGE GET TOWER NAME FROM LIST
	
	        if (game.validateTowerPlacement(towerName, position)) {
	            game.addTower(position, towerName);
	        } else {
	            console.log("invalid tower placement");
	            // show error message somewhere for the user
	        }
	        removeClass(towerCards[getIndex(activeTowerSelected)], "active");
	        activeTowerSelected = null;
	
	    } else {
	        // check if the position overlaps with the bounding rectangle of monster or tower
	        var element = checkClickLocation(position);
	        activeCanvasElement = element;
	    }
	
	}
	
	function cancelTowerPlacement() {
	
	    removeClass(towerCards[getIndex(activeTowerSelected)], "active");
	    activeTowerSelected = null;
	}
	
	
	// Set up event listeners
	// Convert from nodelist to array
	towerCards = Array.prototype.slice.call(towerCards);
	
	// Tower card click event listeners
	towerCards.map(function(towerCard, i) {
	    towerCardList.push(towerCard.getAttribute("data-tower"));
	    towerCard.addEventListener("click", towerCardClick);
	});
	
	// Game container event listeners
	document.getElementById("dynamic").onmousemove = onTowerMouseMovement;
	document.getElementById("dynamic").addEventListener("click", canvasClick);
	
	// Tower placement cancelling event listeners
	document.onkeydown = function(e) {
	    if (e.keyCode === 27) {
	        cancelTowerPlacement();
	    }
	}


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var towerData = __webpack_require__(5);
	// Position refers to the upper left corner of the elements
	// Tower width - 50 x 50
	var Tower = function(position, id) {
	    if (towerData[id] === undefined) {
	        throw Error("Invalid tower name, check html dataattribute or towerdata")
	    }
	    this.id = id;
	    this.damage = towerData[id].damage;
	    this.speed = towerData[id].speed; // Attack speed
	    this.range = towerData[id].range; // Range of the tower
	    this.type = towerData[id].type; // Type of damage
	    this.effect = towerData[id].effect; // Special effect (e.g. slow, splash, etc)
	    this.position = position; // object with x and y coordinates - should not change
	}
	// Method the game object uses to run towers
	Tower.prototype.runCycle = function() {
	    
	}
	// change this to reference a list or something where a name can be used to determine the properties
	// Takes in a monster's position and checks whether that is in range based on the range - returns true or false if in range which can be used to
	Tower.prototype.checkInRange = function(monsterPosition) {
	    // using sqrt((x2-x1)^2 - (y2-y1)^2)
	    var monsterDistance =
	    Math.sqrt(
	        Math.Pow(monsterPosition.x-this.position.x)
	    -   Math.Pow(monsterPosition.y-this.position.y)
	   );
	
	   if (monsterDistance <= this.range) {
	       return true;
	   } else {
	       return false;
	   }
	}
	
	Tower.prototype.draw = function() {
	    dynamicContext.fillStyle = "green";
	    dynamicContext.fillRect(this.position.x,
	                            this.position.y,
	                            50,
	                            50);
	}
	
	module.exports = Tower;


/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = {
	    basic: {
	        damage: 10,
	        speed: 10,
	        range: 100,
	        type: "basic",
	        effect: "none"
	    }
	};


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	//  require Monster to gain access
	var Monster = __webpack_require__(7),
	    Tower = __webpack_require__(4);
	
	var GameEngine = function() {
	    this.userGold = 10;
	    this.level = 1;
	    this.userLives = 30;
	    this.activeMonsters = []; // List of active monsters in the
	    this.towers = []; // object of tower objects
	    this.timer = 1;
	    // Goes through and disables towers that can't be used yet
	}
	
	GameEngine.prototype.addMonster = function(name) {
	    // add monster (specified by name) to game
	    var monster = new Monster("monster1");
	    this.activeMonsters.push(monster);
	}
	
	GameEngine.prototype.addTower = function(position, id) {
	    // Check gold cost and then reduce gold
	    var tower = new Tower(position, id);
	    this.towers.push(tower);
	
	}
	
	// method to check gold before place tower or upgrade
	GameEngine.prototype.checkGold = function(goldCost) {
	    if (goldCost > this.userGold) {
	        return true;
	    } else {
	        return false;
	    }
	};
	
	GameEngine.prototype.gameOver = function() {
	
	}
	
	GameEngine.prototype.gameWon = function() {
	
	}
	
	// New level method
	GameEngine.prototype.nextLevel = function() {
	
	}
	
	GameEngine.prototype.render = function() {
	    // send state to the display object to render
	    dynamicContext.beginPath();
	    dynamicContext.clearRect(0, 0, dynamicCanvas.width, dynamicCanvas.height);
	
	    // Render towers first so that if monsters are larger they show above towers
	    for (var i = 0, j = this.towers.length; i < j; i ++) {
	        this.towers[i].draw();
	    }
	
	    //  loop through list of active monsters and render them
	    //  TODO probably need to find a better way to rend them apart from random rectangle
	    for (var i = 0, j = this.activeMonsters.length; i < j; i ++) {
	        this.activeMonsters[i].draw();
	    }
	
	
	
	    // dynamicContext.
	};
	
	GameEngine.prototype.runCycle = function() {
	    //  beginning of cycle check if any monsters have died if so remove from active monsters
	    this.checkMonsterDeath();
	    // loop through active monsters and towers and run the cycle
	    // Each runCycle method returns information for the gameEngine to
	    // process (e.g. the monster died, tower changed)
	
	    //  timer to add monsters
	    this.timer--;
	    if (this.timer < 1) {
	        this.addMonster('blah');
	        this.timer = 10;
	    }
	    for (var i = 0, j = this.activeMonsters.length; i < j; i ++) {
	        this.activeMonsters[i].move();
	    }
	    // Send information to render
	}
	
	// method to upgrade tower
	
	// 50 x 50 tower
	GameEngine.prototype.validateTowerPlacement = function(position) {
	
	    // returns true or false whether tower placement is valid
	    return true;
	}
	
	GameEngine.prototype.checkMonsterDeath = function() {
	    for (var i = 0, j = this.activeMonsters.length; i < j; i ++) {
	        if (this.activeMonsters[i].checkDeath()) {
	            this.activeMonsters.splice(i, 1);
	            i--;
	            j--;
	        }
	    }
	}
	
	// redraw canvas
	
	module.exports = GameEngine;


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var monsterData = __webpack_require__(8);
	
	var Monster = function(id) {
	    this.id = id;
	    this.currentHp = monsterData[id].maxHp;
	    this.maxHp = monsterData[id].maxHp;
	    this.baseMs = monsterData[id].baseMs; // Movement speed - "units" per second
	    this.type = monsterData[id].type;
	    this.position = { // All monsters are created in the same position
	        x: 0,
	        y: 485
	    }
	};
	// Method the game object uses to move monsters
	Monster.prototype.runCycle = function() {
	
	}
	
	Monster.prototype.draw = function() {
	    dynamicContext.beginPath();
	    dynamicContext.rect(this.position.x, this.position.y, 30, 30);
	    dynamicContext.stroke();
	    dynamicContext.fillStyle = "red";
	    dynamicContext.fillRect(this.position.x,
	                            this.position.y + 30/3,
	                            30 * this.currentHp/this.maxHp,
	                            30/3);
	}
	
	Monster.prototype.destroy = function() {
	
	};
	
	Monster.prototype.checkDeath = function() {
	    return this.currentHp <= 0;
	};
	
	// Expects up, down, left or right
	Monster.prototype.move = function(direction) {
	    var speed = this.baseMs;
	
	    // some basic monster Movement
	    //  NOTE such a hassle to figure this out
	    //  TODO not finished, not even going to try and finish will figure out how this should work later
	    if (this.position.x <= 50 && this.position.y < 500) {
	        this.position.x += speed;
	    } else if (this.position.x >= 50 && this.position.y >= 90) {
	        this.position.y -= speed;
	    } else if (this.position.x <= 180 && this.position.y >= 80) {
	        this.position.x += speed;
	    }
	
	    //  may not be the best way to do this but ill keep it because not even sure how to do this movement part
	    // if (typeof direction !== "string") {
	    //     throw new TypeError("direction is not a string");
	    // }
	    // direction = direction.toLowerCase();
	    // switch (direction) {
	    //     case "up":
	    //     case "down":
	    //     case "left":
	    //     case "right":
	    //     default:
	    //         throw new Error("Invalid direction");
	    // }
	};
	
	// Can take in a positive or negative number
	Monster.prototype.updateHp = function(hpChange) {
	    this.currentHp += hpChange;
	
	    if (this.currentHp > this.maxHp) {
	        this.currentHp = this.maxHp;
	    }
	};
	
	module.exports = Monster;


/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = {
	    monster1: {
	        maxHp: 30,
	        baseMs: 10,
	        type: 1 // Change this type later
	    }
	};


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZDQ2ODE4NGY0YmZlYWE5NmUzYTIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2VudHJ5LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9iYWNrZ3JvdW5kLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NsYXNzZXMvVG93ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2dhbWVEYXRhL3Rvd2VyZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY2xhc3Nlcy9HYW1lLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9jbGFzc2VzL01vbnN0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2dhbWVEYXRhL21vbnN0ZXJkYXRhLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0Esb0NBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDM0RBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUEyQixXQUFXO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBaUM7QUFDakM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQixnQ0FBZ0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF1Qix3QkFBd0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUE4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InNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9zcmMvanMvXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL2Jvb3RzdHJhcCBkNDY4MTg0ZjRiZmVhYTk2ZTNhMlxuICoqLyIsIi8vIENhbnZhc1xucmVxdWlyZShcIi4vYmFja2dyb3VuZC5qc1wiKTtcblxuLy8gVXNlciBpbnRlcmFjdGlvbiBlbGVtZW50c1xucmVxdWlyZShcIi4vaW50ZXJmYWNlLmpzXCIpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9qcy9lbnRyeS5qc1xuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGJhY2tncm91bmQgY29udGFpbnMgdGhlIHN0YXRpYyBjYW52YXMgZWxlbWVudHNcbnZhciBiYWNrZ3JvdW5kID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdGF0aWNcIik7XG52YXIgYmFja2dyb3VuZENvbnRleHQgPSBiYWNrZ3JvdW5kLmdldENvbnRleHQoXCIyZFwiKTtcblxuLy8gU2V0dGluZ3MgZm9yIHRoZSBiYWNrZ3JvdW5kIC0gbW92ZSBvdXQgdG8gYSBzZXBhcmF0ZSBmaWxlXG52YXIgc2V0dGluZ3MgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiBcIiM4Q0QxRTZcIixcbiAgICBwYXRoQ29sb3I6IFwiZ3JheVwiXG59XG5cbi8vIERyYXdpbmcgdGhlIGJhY2tncm91bmRcbmJhY2tncm91bmRDb250ZXh0LmZpbGxTdHlsZSA9IHNldHRpbmdzLmJhY2tncm91bmRDb2xvcjtcbmJhY2tncm91bmRDb250ZXh0LmZpbGxSZWN0KDAsIDAsIGJhY2tncm91bmQud2lkdGgsIGJhY2tncm91bmQuaGVpZ2h0KTtcblxuLyogTWFpbiBwYXRoIHdpbGwgZ28gZnJvbSBbMCwgNTAwXSwgWzc1LCA1MDBdLCBbNzUsIDEwMF0sIFsyMjUsIDEwMF0sIFsyMjUsIDUwMF0sIFszNzUsIDUwMF0sIFszNzUsIDEwMF0sIFs1MjUsIDEwMF0sIFs1MjUsIDUwMF0sIFs2NzUsIDUwMF0sIFs2NzUsIDEwMF0sIFs4MjUsIDEwMF0sIFs4MjUsIDUwMF0sIFs5MDAsIDUwMF0gKi9cblxuLy8gRHJhd2luZyB0aGUgcGF0aCAtIHdpZHRoIG9mIHRoZSBwYXRoIGlzIDUwcHhcbmJhY2tncm91bmRDb250ZXh0LmZpbGxTdHlsZSA9IHNldHRpbmdzLnBhdGhDb2xvcjtcblxuYmFja2dyb3VuZENvbnRleHQuYmVnaW5QYXRoKCk7XG5cbi8vIEZvciB0aGUgYm90dG9tIHBhcnQgb2YgdGhlIHBhdGhcbmJhY2tncm91bmRDb250ZXh0Lm1vdmVUbygwLCA1MjUpO1xuXG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oMTAwLCA1MjUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDEwMCwgMTI1KTsgLy8gVG9wXG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oMjAwLCAxMjUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDIwMCwgNTI1KTsgLy8gQm90dG9tXG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNDAwLCA1MjUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDQwMCwgMTI1KTsgLy8gVG9wXG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNTAwLCAxMjUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDUwMCwgNTI1KTsgLy8gQm90dG9tXG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNzAwLCA1MjUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDcwMCwgMTI1KTsgLy8gVG9wXG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oODAwLCAxMjUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDgwMCwgNTI1KTsgLy8gQm90dG9tXG5cbi8vTWlkZGxlIHNlY3Rpb24gdG8gdGhlIHNpZGVcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg5MDAsIDUyNSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oOTAwLCA0NzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDg1MCwgNDc1KTtcblxuLy8gRm9yIHRoZSB0b3AgcGFydCBvZiB0aGUgcGF0aFxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDg1MCwgNzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDY1MCwgNzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDY1MCwgNDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg1NTAsIDQ3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNTUwLCA3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oMzUwLCA3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oMzUwLCA0NzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDI1MCwgNDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygyNTAsIDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg1MCwgNzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDUwLCA0NzUpO1xuXG4vLyBFbmQgc2VjdGlvblxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDAsIDQ3NSk7XG5cbmJhY2tncm91bmRDb250ZXh0LmZpbGwoKTtcbi8vIGJhY2tncm91bmRDb250ZXh0LmxpbmVUbygpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9qcy9iYWNrZ3JvdW5kLmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gTk9URSBBdCBzb21lIHBvaW50IEkgdGhpbmsgd2UgY2FuIG1vdmUgc29tZSBmdW5jdGlvbnMgaW50byBhIGRpZmZlcmVudCBmaWxlXG5cbi8vIEluaXRpYXRlIGFsbCB0aGUgY29tcG9uZW50c1xudmFyIFRvd2VyID0gcmVxdWlyZShcIi4vY2xhc3Nlcy9Ub3dlci5qc1wiKSxcbiAgICBHYW1lRW5naW5lID0gcmVxdWlyZShcIi4vY2xhc3Nlcy9HYW1lLmpzXCIpLFxuICAgIG1vbnN0ZXJEYXRhID0gcmVxdWlyZShcIi4vZ2FtZURhdGEvbW9uc3RlcmRhdGEuanNcIiksXG4gICAgdG93ZXJEYXRhID0gcmVxdWlyZShcIi4vZ2FtZURhdGEvdG93ZXJkYXRhLmpzXCIpO1xuXG4vLyBDYWNoZSByZXVzZWQgRE9NIGVsZW1lbnRzXG52YXIgaW5mb05hbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImluZm8tbmFtZVwiKSxcbiAgICBpbmZvSWNvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5mby1pY29uXCIpLFxuICAgIGluZm9Cb3gxID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbmZvLWJveC0xXCIpLFxuICAgIGluZm9Cb3gyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbmZvLWJveC0yXCIpLFxuICAgIGluZm9Cb3gzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbmZvLWJveC0zXCIpLFxuICAgIGluZm9Cb3g0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbmZvLWJveC00XCIpO1xuXG52YXIgdG93ZXJDYXJkcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJ0b3dlci1jYXJkXCIpO1xudmFyIHRvd2VyQ2FyZExpc3QgPSBbXTtcblxuLy8gIGNyZWF0ZXMgZ2xvYmFsIHZhcmlhYmxlc1xuZ2FtZSA9IG5ldyBHYW1lRW5naW5lO1xuZHluYW1pY0NhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkeW5hbWljJyk7XG5keW5hbWljQ29udGV4dCA9IGR5bmFtaWNDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuLy8gY3JlYXRlIHN0YXRlIHZhcmlhYmxlc1xudmFyIGFjdGl2ZUNhbnZhc0VsZW1lbnQgPSB7dHlwZTogbnVsbH0sIC8vIGluaXRpYXRlIGRlZmF1bHQgYXMgbnVsbFxuICAgIGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPSBudWxsO1xuXG5ydW5DeWNsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGdhbWUucnVuQ3ljbGUoKTtcbiAgICBzZXRUaW1lb3V0KHJ1bkN5Y2xlLCAxMDAwKTtcbn1cblxucmVuZGVyQ3ljbGUgPSBmdW5jdGlvbigpIHtcbiAgICBnYW1lLnJlbmRlcigpO1xuICAgIHJlbmRlckluZm9ybWF0aW9uQ29udGFpbmVyKCk7IC8vIFJlbmRlcnMgdGhlIGluZm9ybWF0aW9uIGNvbnRhaW5lclxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXJDeWNsZSk7XG59XG5cbi8vIEhFUkUgSVMgQUxMIFRIRSBJTlRFUkFDVElPTiBFVkVOVCBMSVNURU5FUlNcblxuLyogPT09PT09PT09PT09PT0gT24gc3RhcnQgY2xpY2sgaGFuZGxlcnMgPT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG4vLyBPbiBzdGFydCwgY3JlYXRlIGEgZ2FtZSBlbGVtZW50IC0gdGhlc2UgZXZlbnQgbGlzdGVuZXJzIHdpbGwgYmUgZGVzdHJveWVkIHdoZW4gdGhlIGNvbnRhaW5lciBpcyBvdmVycmlkZW5cbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3RhcnQtYnRuXCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAvLyBIaWRlcyB0aGUgbW9kYWwgbGlnaHRib3hcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwibW9kYWwtY29udGVudFwiKVswXS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcIm1vZGFsLWJhY2tncm91bmRcIilbMF0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXG4gICAgLy8gcnVuIHJlcGVhdGluZyBmdW5jdGlvbiB0aGF0IHJ1bnMgZ2FtZSBlbmdpbmUgcnVuIGN5Y2xlIGFuZCByZW5kZXJpbmdcbiAgICBzZXRUaW1lb3V0KHJ1bkN5Y2xlLCAxMDAwKTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyQ3ljbGUpO1xufSk7XG5cbi8vIE9uIGNsaWNraW5nIHRoZSBpbmZvcm1hdGlvbiBidXR0b24sIHNob3cgdGhlIGluZm9ybWF0aW9uIHBhbmVsXG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImluZm9ybWF0aW9uLWJ0blwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgY29uc29sZS5sb2coXCJzaG93IGluZm9ybWF0aW9uIGNvbnRhaW5lciBoZXJlXCIpO1xufSk7XG5cbi8qID09PT09PT09IEluZm9ybWF0aW9uIGNvbnRhaW5lciBpbnRlcmFjdGlvbnMgPT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5cbi8qID09PT09PT09PT09PT09PT09IEluZm9ybWF0aW9uIENsaWNrID09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8vIFNob3dzIGluZm9ybWF0aW9uIGFib3V0IHRvd2VycyBvciBtb25zdGVycyBpZiBob3ZlcmVkIG92ZXJcbi8vIG9yIGFjdGl2ZVxuXG4vLyBSdW5zIGV2ZXJ5IGdhbWUgY3ljbGVcbmZ1bmN0aW9uIHJlbmRlckluZm9ybWF0aW9uQ29udGFpbmVyKCkge1xuICAgIGlmIChhY3RpdmVDYW52YXNFbGVtZW50LnR5cGUgPT09IFwibW9uc3RlclwiKSB7XG4gICAgICAgIHJlbmRlck1vbnN0ZXJJbmZvcm1hdGlvbihhY3RpdmVDYW52YXNFbGVtZW50LmlkLCBhY3RpdmVDYW52YXNFbGVtZW50LmluZGV4KTtcbiAgICB9IGVsc2UgaWYgKGFjdGl2ZUNhbnZhc0VsZW1lbnQudHlwZSA9PT0gXCJ0b3dlclwiKSB7XG4gICAgICAgIHJlbmRlclRvd2VySW5mb3JtYXRpb24oYWN0aXZlQ2FudmFzRWxlbWVudC5pZCwgYWN0aXZlQ2FudmFzRWxlbWVudC5pbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyRGVmYXVsdEluZm9ybWF0aW9uKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb21wYXJlUG9zaXRpb25zKGNsaWNrUG9zaXRpb24sIGVsZW1lbnRQb3NpdGlvbiwgdHlwZSkge1xuICAgIHZhciBzaWRlTGVuZ3RoID0gdHlwZSA9PT0gXCJtb25zdGVyXCIgPyAzMCA6IDUwOyAvLyB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBlbGVtZW50XG4gICAgaWYgKGNsaWNrUG9zaXRpb24ueCA+PSBlbGVtZW50UG9zaXRpb24ueFxuICAgICYmIGNsaWNrUG9zaXRpb24ueCA8PSBlbGVtZW50UG9zaXRpb24ueCArIHNpZGVMZW5ndGhcbiAgICAmJiBjbGlja1Bvc2l0aW9uLnkgPj0gZWxlbWVudFBvc2l0aW9uLnlcbiAgICAmJiBjbGlja1Bvc2l0aW9uLnkgPD0gZWxlbWVudFBvc2l0aW9uLnkgKyBzaWRlTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbi8vIFRha2VzIGluIGEgcG9zaXRpb24gb2JqZWN0IChsb2NhdGlvbiBvZiB0aGUgY2xpY2spXG4vLyByZXR1cm5zIGFuIG9iamVjdCB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgaXMgYXQgdGhhdCBwb3NpdGlvblxuZnVuY3Rpb24gY2hlY2tDbGlja0xvY2F0aW9uKHBvc2l0aW9uKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB7fTtcbiAgICAvLyBMb29wcyB0aHJvdWdoIGFjdGl2ZU1vbnN0ZXJzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnYW1lLmFjdGl2ZU1vbnN0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjb21wYXJlUG9zaXRpb25zKHBvc2l0aW9uLCBnYW1lLmFjdGl2ZU1vbnN0ZXJzW2ldLnBvc2l0aW9uLCBcIm1vbnN0ZXJcIikpIHtcbiAgICAgICAgICAgIGVsZW1lbnQudHlwZSA9IFwibW9uc3RlclwiO1xuICAgICAgICAgICAgZWxlbWVudC5pZCA9IGdhbWUuYWN0aXZlTW9uc3RlcnNbaV0uaWQ7XG4gICAgICAgICAgICBlbGVtZW50LmluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbm90aGluZyB3YXMgZm91bmQsIGxvb3AgdGhyb3VnaCB0b3dlcnNcbiAgICBpZiAoZWxlbWVudC50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnYW1lLnRvd2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvbXBhcmVQb3NpdGlvbnMocG9zaXRpb24sIGdhbWUudG93ZXJzW2ldLnBvc2l0aW9uLCBcInRvd2VyXCIpKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC50eXBlID0gXCJ0b3dlclwiO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuaWQgPSBnYW1lLnRvd2Vyc1tpXS5pZDtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vIHRvd2VycyBvciBtb25zdGVycyBmb3VuZCByZXR1cm4gYSB0eXBlIG9mIG51bGxcbiAgICBpZiAoZWxlbWVudC50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWxlbWVudC50eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbn1cblxuLy8gSUQgcmVmZXJzIHRvIHRoZSB0eXBlIG9mIG1vbnN0ZXIgYW5kIGluZGV4IGlzIHRoZSBpbmRleCBvZiB0aGUgYWN0aXZlIG1vbnN0ZXIgaW4gdGhlIGFjdGl2ZSBtb25zdGVyJ3MgYXJyYXlcbmZ1bmN0aW9uIHJlbmRlck1vbnN0ZXJJbmZvcm1hdGlvbihpZCwgaW5kZXgpIHtcbiAgICB2YXIgY3VycmVudEhwID0gZ2FtZS5hY3RpdmVNb25zdGVyc1tpbmRleF0uY3VycmVudEhwLFxuICAgICAgICBtYXhIcCA9IGdhbWUuYWN0aXZlTW9uc3RlcnNbaW5kZXhdLm1heEhwLFxuICAgICAgICB0eXBlID0gZ2FtZS5hY3RpdmVNb25zdGVyc1tpbmRleF0udHlwZTtcbiAgICBpbmZvTmFtZS5pbm5lckhUTUwgPSBpZDtcbiAgICAvLyBDaGFuZ2UgaWNvbiB0byBhY3RpdmUgbW9uc3RlciAtIHVzZSBhIHNwcml0ZVxuICAgIGluZm9Cb3gxLmlubmVySFRNTCA9IFwiSFA6IFwiICsgY3VycmVudEhwICsgXCIgLyBcIiArIG1heEhwO1xuICAgIGluZm9Cb3gyLmlubmVySFRNTCA9IFwiVHlwZTogXCIgKyB0eXBlO1xuICAgIGluZm9Cb3gzLmlubmVySFRNTCA9IFwiU3RyZW5ndGhzOiBBbGwgc29ydHMgbWF0ZVwiIDtcbiAgICBpbmZvQm94NC5pbm5lckhUTUwgPSBcIldlYWtuZXNzZXM6IER1Y2tzXCIgO1xufVxuXG4vLyBJRCByZWZlcnMgdG8gdGhlIHR5cGUgb2YgdG93ZXIgYW5kIGluZGV4IGlzIHRoZSBpbmRleCBvZiB0aGUgYWN0aXZlIHRvd2VyIGluIHRoZSBhY3RpdmUgdG93ZXIncyBhcnJheVxuZnVuY3Rpb24gcmVuZGVyVG93ZXJJbmZvcm1hdGlvbihpZCwgaW5kZXgpIHtcbiAgICBpbmZvTmFtZS5pbm5lckhUTUwgPSBpZDtcbiAgICAvLyBDaGFuZ2UgaWNvbiB0byBhY3RpdmUgbW9uc3RlciAtIHVzZSBhIHNwcml0ZVxuICAgIGluZm9Cb3gxLmlubmVySFRNTCA9IFwiRGFtYWdlOiA8YnI+IFJhbmdlOiA8YnI+IEVmZmVjdDogXCI7XG4gICAgaW5mb0JveDIuaW5uZXJIVE1MID0gXCJBdHRhY2sgU3BlZWQ6IDxicj4gVHlwZTogXCIgO1xuICAgIGluZm9Cb3gzLmlubmVySFRNTCA9IFwiPGEgY2xhc3M9J3dhdmVzLWVmZmVjdCB3YXZlcy1saWdodCBidG4gcmVkJz5VcGdyYWRlPC9hPlwiIDtcbiAgICBpbmZvQm94NC5pbm5lckhUTUwgPSBcIjxhIGNsYXNzPSd3YXZlcy1lZmZlY3Qgd2F2ZXMtbGlnaHQgYnRuIHJlZCc+U2VsbDwvYT5cIiA7XG4gICAgLy8gQ2hhbmdlIGljb24gdG8gdG93ZXIgbW9uc3RlciAtIHVzZSBhIHNwcml0ZVxuXG59XG5cbmZ1bmN0aW9uIHJlbmRlckRlZmF1bHRJbmZvcm1hdGlvbigpIHtcbiAgICBpbmZvTmFtZS5pbm5lckhUTUwgPSBcIkF3ZXNvbWUgVERcIjtcbiAgICAvLyBDaGFuZ2UgaWNvbiB0byBkZWZhdWx0IGltYWdlIC0gdXNlIGEgc3ByaXRlXG4gICAgaW5mb0JveDEuaW5uZXJIVE1MID0gXCJUaGlzIGlzIHNvbWUgdGV4dFwiO1xuICAgIGluZm9Cb3gyLmlubmVySFRNTCA9IFwiVGhpcyBpcyBkaWZmZXJlbnQgdGV4dFwiO1xuICAgIGluZm9Cb3gzLmlubmVySFRNTCA9IFwiVGhpcyBpcyA/Pz8gdGV4dFwiIDtcbiAgICBpbmZvQm94NC5pbm5lckhUTUwgPSBcIlRoaXMgMTIzMTI0MTIzNVwiIDtcbn1cblxuLy8gR2V0IGluZm9ybWF0aW9uIGZyb20gdG93ZXJkYXRhLmpzXG5cbi8qID09PT09PT09PT0gVG93ZXIgQ2FyZCBDbGljayBhbmQgcGxhY2VtZW50cyA9PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8vIENsaWNrIGEgdG93ZXIgY2FyZCBhbmQgbWFrZSBcImFjdGl2ZVwiIHdoaWNoIGNhbiBiZSBwbGFjZWQgb24gVUkgZWxlbWVudFxuLy8gV2hpbGUgaXQgaXMgYWN0aXZlIC0gdXNlICNkeW5hbWljLm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24gLT4gdG8gU2VuZFxuLy8gaW5mb3JtYXRpb24gdG8gdGhlIGNhbnZhc1xuXG4vLyBzZXQgdXAgZXZlbnQgbGlzdGVuZXJzIGF0IHRoZSBzdGFydCB3aGljaCByZWZlcmVuY2UgZnVuY3Rpb25zIC0gdGhlc2UgZnVuY3Rpb25zIGRlcGVuZCBvbiB0aGUgc3RhdGUgb24gdGhlIGFwcGxpY2F0aW9uIHRvIGNvbnRyb2wgdGhlaXIgY29udHJvbCBmbG93XG5cbmZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQsIGNzc0NsYXNzKSB7XG4gICAgaWYgKGVsZW1lbnQuY2xhc3NOYW1lID09PSBcIlwiKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gY3NzQ2xhc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgKz0gXCIgXCIgKyBjc3NDbGFzcztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNzc0NsYXNzKSB7XG4gICAgdmFyIGFycmF5T2ZDbGFzc2VzID0gZWxlbWVudC5jbGFzc05hbWUuc3BsaXQoXCIgXCIpO1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gYXJyYXlPZkNsYXNzZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgICAgIGlmIChhcnJheU9mQ2xhc3Nlc1tpXSA9PT0gY3NzQ2xhc3MpIHtcbiAgICAgICAgICAgIGFycmF5T2ZDbGFzc2VzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGktLTsgai0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gYXJyYXlPZkNsYXNzZXMuam9pbihcIiBcIik7XG59XG5cbmZ1bmN0aW9uIGdldEluZGV4KHRvd2VyTmFtZSkge1xuICAgIHJldHVybiB0b3dlckNhcmRMaXN0LmluZGV4T2YodG93ZXJOYW1lKTtcbn1cblxuZnVuY3Rpb24gdG93ZXJDYXJkQ2xpY2soKSB7XG5cbiAgICB2YXIgdG93ZXJOYW1lID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRvd2VyXCIpO1xuXG4gICAgaWYgKC9kaXNhYmxlZC9pLnRlc3QodGhpcy5jbGFzc05hbWUpKSB7IC8vIFRvd2VyIGlzIGRpc2FibGVkXG4gICAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPT09IG51bGwpIHsgLy8gVGhlcmUgaXMgbm8gYWN0aXZlIHRvd2VyIGJlaW5nIHBsYWNlZFxuICAgICAgICAvLyBzZXQgdGhlIGFjdGl2ZSB0b3dlciBzZWxlY3RlZCB0byBiZSB0aGUgdG93ZXIgbmFtZVxuICAgICAgICAvLyBTZXQgdXAgYWN0aXZlIGVsZW1lbnRzXG4gICAgICAgIGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPSB0b3dlck5hbWU7XG4gICAgICAgIGFkZENsYXNzKHRvd2VyQ2FyZHNbZ2V0SW5kZXgoYWN0aXZlVG93ZXJTZWxlY3RlZCldLCBcImFjdGl2ZVwiKTtcbiAgICB9IGVsc2UgaWYgKGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPT09IHRvd2VyTmFtZSkgeyAvLyBUaGUgdG93ZXIgY2FyZCBjbGlja2VkIGlzIHRoZSBzYW1lIGFzIHRoZSBhY3RpdmUgdG93ZXJcbiAgICAgICAgY2FuY2VsVG93ZXJQbGFjZW1lbnQoKTtcbiAgICB9IGVsc2UgeyAvLyBUaGVyZSBpcyBhbiBhY3RpdmUgdG93ZXIgd2hpY2ggaXMgbm90IHRoZSBzYW1lIGFzIHdoYXQgd2FzIGNsaWNrZWRcbiAgICAgICAgcmVtb3ZlQ2xhc3ModG93ZXJDYXJkc1tnZXRJbmRleChhY3RpdmVUb3dlclNlbGVjdGVkKV0sIFwiYWN0aXZlXCIpO1xuICAgICAgICBhY3RpdmVUb3dlclNlbGVjdGVkID0gdG93ZXJOYW1lO1xuICAgICAgICBhZGRDbGFzcyh0b3dlckNhcmRzW2dldEluZGV4KGFjdGl2ZVRvd2VyU2VsZWN0ZWQpXSwgXCJhY3RpdmVcIik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBvblRvd2VyTW91c2VNb3ZlbWVudChlKSB7XG4gICAgaWYgKGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgfTtcbiAgICB2YXIgY2FudmFzQ29udGFpbmVyID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgb2Zmc2V0WCA9IGUuY2xpZW50WCAtIGNhbnZhc0NvbnRhaW5lci5sZWZ0LFxuICAgICAgICBvZmZzZXRZID0gZS5jbGllbnRZIC0gY2FudmFzQ29udGFpbmVyLnRvcDtcbiAgICAvLyBzZW5kIHRvIGRpc3BsYXkgdG8gZ2V0IHJlbmRlcmVkXG59O1xuXG4vLyBUd28gcG9zc2libGUgY2FudmFzIGNsaWNrIHNjZW5hcmlvczpcbi8vIDEpIFRvd2VyIHNlbGVjdGlvbiBpcyBhY3RpdmUgKHBsYWNlIGEgdG93ZXIpXG4vLyAyKSBUb3dlciBzZWxlY3Rpb24gaXMgaW5hY3RpdmUgKGNsaWNraW5nIHRvIGdldCBpbmZvcm1hdGlvbiBhYm91dCBhIG1vbnN0ZXIgb3IgdG93ZXIgb24gdGhlIG1hcClcbmZ1bmN0aW9uIGNhbnZhc0NsaWNrKGUpIHtcbiAgICAvLyBHZXQgY2xpY2sgbG9jYXRpb24gcmVsYXRpdmUgdG8gdGhlIGNhbnZhcyBlbGVtZW50XG4gICAgdmFyIGNhbnZhc0NvbnRhaW5lciA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgcG9zaXRpb24gPSB7fTtcblxuICAgIHBvc2l0aW9uLnggPSBlLmNsaWVudFggLSBjYW52YXNDb250YWluZXIubGVmdDtcbiAgICBwb3NpdGlvbi55ID0gZS5jbGllbnRZIC0gY2FudmFzQ29udGFpbmVyLnRvcDtcblxuICAgIGlmIChhY3RpdmVUb3dlclNlbGVjdGVkICE9PSBudWxsKSB7IC8vXG4gICAgICAgIHZhciB0b3dlck5hbWUgPSBhY3RpdmVUb3dlclNlbGVjdGVkOyAvLyBOT1RFIENIQU5HRSBHRVQgVE9XRVIgTkFNRSBGUk9NIExJU1RcblxuICAgICAgICBpZiAoZ2FtZS52YWxpZGF0ZVRvd2VyUGxhY2VtZW50KHRvd2VyTmFtZSwgcG9zaXRpb24pKSB7XG4gICAgICAgICAgICBnYW1lLmFkZFRvd2VyKHBvc2l0aW9uLCB0b3dlck5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJpbnZhbGlkIHRvd2VyIHBsYWNlbWVudFwiKTtcbiAgICAgICAgICAgIC8vIHNob3cgZXJyb3IgbWVzc2FnZSBzb21ld2hlcmUgZm9yIHRoZSB1c2VyXG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlQ2xhc3ModG93ZXJDYXJkc1tnZXRJbmRleChhY3RpdmVUb3dlclNlbGVjdGVkKV0sIFwiYWN0aXZlXCIpO1xuICAgICAgICBhY3RpdmVUb3dlclNlbGVjdGVkID0gbnVsbDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIHRoZSBwb3NpdGlvbiBvdmVybGFwcyB3aXRoIHRoZSBib3VuZGluZyByZWN0YW5nbGUgb2YgbW9uc3RlciBvciB0b3dlclxuICAgICAgICB2YXIgZWxlbWVudCA9IGNoZWNrQ2xpY2tMb2NhdGlvbihwb3NpdGlvbik7XG4gICAgICAgIGFjdGl2ZUNhbnZhc0VsZW1lbnQgPSBlbGVtZW50O1xuICAgIH1cblxufVxuXG5mdW5jdGlvbiBjYW5jZWxUb3dlclBsYWNlbWVudCgpIHtcblxuICAgIHJlbW92ZUNsYXNzKHRvd2VyQ2FyZHNbZ2V0SW5kZXgoYWN0aXZlVG93ZXJTZWxlY3RlZCldLCBcImFjdGl2ZVwiKTtcbiAgICBhY3RpdmVUb3dlclNlbGVjdGVkID0gbnVsbDtcbn1cblxuXG4vLyBTZXQgdXAgZXZlbnQgbGlzdGVuZXJzXG4vLyBDb252ZXJ0IGZyb20gbm9kZWxpc3QgdG8gYXJyYXlcbnRvd2VyQ2FyZHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0b3dlckNhcmRzKTtcblxuLy8gVG93ZXIgY2FyZCBjbGljayBldmVudCBsaXN0ZW5lcnNcbnRvd2VyQ2FyZHMubWFwKGZ1bmN0aW9uKHRvd2VyQ2FyZCwgaSkge1xuICAgIHRvd2VyQ2FyZExpc3QucHVzaCh0b3dlckNhcmQuZ2V0QXR0cmlidXRlKFwiZGF0YS10b3dlclwiKSk7XG4gICAgdG93ZXJDYXJkLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0b3dlckNhcmRDbGljayk7XG59KTtcblxuLy8gR2FtZSBjb250YWluZXIgZXZlbnQgbGlzdGVuZXJzXG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImR5bmFtaWNcIikub25tb3VzZW1vdmUgPSBvblRvd2VyTW91c2VNb3ZlbWVudDtcbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZHluYW1pY1wiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgY2FudmFzQ2xpY2spO1xuXG4vLyBUb3dlciBwbGFjZW1lbnQgY2FuY2VsbGluZyBldmVudCBsaXN0ZW5lcnNcbmRvY3VtZW50Lm9ua2V5ZG93biA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoZS5rZXlDb2RlID09PSAyNykge1xuICAgICAgICBjYW5jZWxUb3dlclBsYWNlbWVudCgpO1xuICAgIH1cbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvaW50ZXJmYWNlLmpzXG4gKiogbW9kdWxlIGlkID0gM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHRvd2VyRGF0YSA9IHJlcXVpcmUoXCIuLi9nYW1lRGF0YS90b3dlcmRhdGEuanNcIik7XG4vLyBQb3NpdGlvbiByZWZlcnMgdG8gdGhlIHVwcGVyIGxlZnQgY29ybmVyIG9mIHRoZSBlbGVtZW50c1xuLy8gVG93ZXIgd2lkdGggLSA1MCB4IDUwXG52YXIgVG93ZXIgPSBmdW5jdGlvbihwb3NpdGlvbiwgaWQpIHtcbiAgICBpZiAodG93ZXJEYXRhW2lkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiSW52YWxpZCB0b3dlciBuYW1lLCBjaGVjayBodG1sIGRhdGFhdHRyaWJ1dGUgb3IgdG93ZXJkYXRhXCIpXG4gICAgfVxuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmRhbWFnZSA9IHRvd2VyRGF0YVtpZF0uZGFtYWdlO1xuICAgIHRoaXMuc3BlZWQgPSB0b3dlckRhdGFbaWRdLnNwZWVkOyAvLyBBdHRhY2sgc3BlZWRcbiAgICB0aGlzLnJhbmdlID0gdG93ZXJEYXRhW2lkXS5yYW5nZTsgLy8gUmFuZ2Ugb2YgdGhlIHRvd2VyXG4gICAgdGhpcy50eXBlID0gdG93ZXJEYXRhW2lkXS50eXBlOyAvLyBUeXBlIG9mIGRhbWFnZVxuICAgIHRoaXMuZWZmZWN0ID0gdG93ZXJEYXRhW2lkXS5lZmZlY3Q7IC8vIFNwZWNpYWwgZWZmZWN0IChlLmcuIHNsb3csIHNwbGFzaCwgZXRjKVxuICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjsgLy8gb2JqZWN0IHdpdGggeCBhbmQgeSBjb29yZGluYXRlcyAtIHNob3VsZCBub3QgY2hhbmdlXG59XG4vLyBNZXRob2QgdGhlIGdhbWUgb2JqZWN0IHVzZXMgdG8gcnVuIHRvd2Vyc1xuVG93ZXIucHJvdG90eXBlLnJ1bkN5Y2xlID0gZnVuY3Rpb24oKSB7XG4gICAgXG59XG4vLyBjaGFuZ2UgdGhpcyB0byByZWZlcmVuY2UgYSBsaXN0IG9yIHNvbWV0aGluZyB3aGVyZSBhIG5hbWUgY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBwcm9wZXJ0aWVzXG4vLyBUYWtlcyBpbiBhIG1vbnN0ZXIncyBwb3NpdGlvbiBhbmQgY2hlY2tzIHdoZXRoZXIgdGhhdCBpcyBpbiByYW5nZSBiYXNlZCBvbiB0aGUgcmFuZ2UgLSByZXR1cm5zIHRydWUgb3IgZmFsc2UgaWYgaW4gcmFuZ2Ugd2hpY2ggY2FuIGJlIHVzZWQgdG9cblRvd2VyLnByb3RvdHlwZS5jaGVja0luUmFuZ2UgPSBmdW5jdGlvbihtb25zdGVyUG9zaXRpb24pIHtcbiAgICAvLyB1c2luZyBzcXJ0KCh4Mi14MSleMiAtICh5Mi15MSleMilcbiAgICB2YXIgbW9uc3RlckRpc3RhbmNlID1cbiAgICBNYXRoLnNxcnQoXG4gICAgICAgIE1hdGguUG93KG1vbnN0ZXJQb3NpdGlvbi54LXRoaXMucG9zaXRpb24ueClcbiAgICAtICAgTWF0aC5Qb3cobW9uc3RlclBvc2l0aW9uLnktdGhpcy5wb3NpdGlvbi55KVxuICAgKTtcblxuICAgaWYgKG1vbnN0ZXJEaXN0YW5jZSA8PSB0aGlzLnJhbmdlKSB7XG4gICAgICAgcmV0dXJuIHRydWU7XG4gICB9IGVsc2Uge1xuICAgICAgIHJldHVybiBmYWxzZTtcbiAgIH1cbn1cblxuVG93ZXIucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbigpIHtcbiAgICBkeW5hbWljQ29udGV4dC5maWxsU3R5bGUgPSBcImdyZWVuXCI7XG4gICAgZHluYW1pY0NvbnRleHQuZmlsbFJlY3QodGhpcy5wb3NpdGlvbi54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24ueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA1MCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA1MCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVG93ZXI7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2pzL2NsYXNzZXMvVG93ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBiYXNpYzoge1xuICAgICAgICBkYW1hZ2U6IDEwLFxuICAgICAgICBzcGVlZDogMTAsXG4gICAgICAgIHJhbmdlOiAxMDAsXG4gICAgICAgIHR5cGU6IFwiYmFzaWNcIixcbiAgICAgICAgZWZmZWN0OiBcIm5vbmVcIlxuICAgIH1cbn07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2pzL2dhbWVEYXRhL3Rvd2VyZGF0YS5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vICByZXF1aXJlIE1vbnN0ZXIgdG8gZ2FpbiBhY2Nlc3NcbnZhciBNb25zdGVyID0gcmVxdWlyZShcIi4vTW9uc3Rlci5qc1wiKSxcbiAgICBUb3dlciA9IHJlcXVpcmUoXCIuL1Rvd2VyLmpzXCIpO1xuXG52YXIgR2FtZUVuZ2luZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudXNlckdvbGQgPSAxMDtcbiAgICB0aGlzLmxldmVsID0gMTtcbiAgICB0aGlzLnVzZXJMaXZlcyA9IDMwO1xuICAgIHRoaXMuYWN0aXZlTW9uc3RlcnMgPSBbXTsgLy8gTGlzdCBvZiBhY3RpdmUgbW9uc3RlcnMgaW4gdGhlXG4gICAgdGhpcy50b3dlcnMgPSBbXTsgLy8gb2JqZWN0IG9mIHRvd2VyIG9iamVjdHNcbiAgICB0aGlzLnRpbWVyID0gMTtcbiAgICAvLyBHb2VzIHRocm91Z2ggYW5kIGRpc2FibGVzIHRvd2VycyB0aGF0IGNhbid0IGJlIHVzZWQgeWV0XG59XG5cbkdhbWVFbmdpbmUucHJvdG90eXBlLmFkZE1vbnN0ZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgLy8gYWRkIG1vbnN0ZXIgKHNwZWNpZmllZCBieSBuYW1lKSB0byBnYW1lXG4gICAgdmFyIG1vbnN0ZXIgPSBuZXcgTW9uc3RlcihcIm1vbnN0ZXIxXCIpO1xuICAgIHRoaXMuYWN0aXZlTW9uc3RlcnMucHVzaChtb25zdGVyKTtcbn1cblxuR2FtZUVuZ2luZS5wcm90b3R5cGUuYWRkVG93ZXIgPSBmdW5jdGlvbihwb3NpdGlvbiwgaWQpIHtcbiAgICAvLyBDaGVjayBnb2xkIGNvc3QgYW5kIHRoZW4gcmVkdWNlIGdvbGRcbiAgICB2YXIgdG93ZXIgPSBuZXcgVG93ZXIocG9zaXRpb24sIGlkKTtcbiAgICB0aGlzLnRvd2Vycy5wdXNoKHRvd2VyKTtcblxufVxuXG4vLyBtZXRob2QgdG8gY2hlY2sgZ29sZCBiZWZvcmUgcGxhY2UgdG93ZXIgb3IgdXBncmFkZVxuR2FtZUVuZ2luZS5wcm90b3R5cGUuY2hlY2tHb2xkID0gZnVuY3Rpb24oZ29sZENvc3QpIHtcbiAgICBpZiAoZ29sZENvc3QgPiB0aGlzLnVzZXJHb2xkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG5HYW1lRW5naW5lLnByb3RvdHlwZS5nYW1lT3ZlciA9IGZ1bmN0aW9uKCkge1xuXG59XG5cbkdhbWVFbmdpbmUucHJvdG90eXBlLmdhbWVXb24gPSBmdW5jdGlvbigpIHtcblxufVxuXG4vLyBOZXcgbGV2ZWwgbWV0aG9kXG5HYW1lRW5naW5lLnByb3RvdHlwZS5uZXh0TGV2ZWwgPSBmdW5jdGlvbigpIHtcblxufVxuXG5HYW1lRW5naW5lLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBzZW5kIHN0YXRlIHRvIHRoZSBkaXNwbGF5IG9iamVjdCB0byByZW5kZXJcbiAgICBkeW5hbWljQ29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBkeW5hbWljQ29udGV4dC5jbGVhclJlY3QoMCwgMCwgZHluYW1pY0NhbnZhcy53aWR0aCwgZHluYW1pY0NhbnZhcy5oZWlnaHQpO1xuXG4gICAgLy8gUmVuZGVyIHRvd2VycyBmaXJzdCBzbyB0aGF0IGlmIG1vbnN0ZXJzIGFyZSBsYXJnZXIgdGhleSBzaG93IGFib3ZlIHRvd2Vyc1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gdGhpcy50b3dlcnMubGVuZ3RoOyBpIDwgajsgaSArKykge1xuICAgICAgICB0aGlzLnRvd2Vyc1tpXS5kcmF3KCk7XG4gICAgfVxuXG4gICAgLy8gIGxvb3AgdGhyb3VnaCBsaXN0IG9mIGFjdGl2ZSBtb25zdGVycyBhbmQgcmVuZGVyIHRoZW1cbiAgICAvLyAgVE9ETyBwcm9iYWJseSBuZWVkIHRvIGZpbmQgYSBiZXR0ZXIgd2F5IHRvIHJlbmQgdGhlbSBhcGFydCBmcm9tIHJhbmRvbSByZWN0YW5nbGVcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuYWN0aXZlTW9uc3RlcnMubGVuZ3RoOyBpIDwgajsgaSArKykge1xuICAgICAgICB0aGlzLmFjdGl2ZU1vbnN0ZXJzW2ldLmRyYXcoKTtcbiAgICB9XG5cblxuXG4gICAgLy8gZHluYW1pY0NvbnRleHQuXG59O1xuXG5HYW1lRW5naW5lLnByb3RvdHlwZS5ydW5DeWNsZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vICBiZWdpbm5pbmcgb2YgY3ljbGUgY2hlY2sgaWYgYW55IG1vbnN0ZXJzIGhhdmUgZGllZCBpZiBzbyByZW1vdmUgZnJvbSBhY3RpdmUgbW9uc3RlcnNcbiAgICB0aGlzLmNoZWNrTW9uc3RlckRlYXRoKCk7XG4gICAgLy8gbG9vcCB0aHJvdWdoIGFjdGl2ZSBtb25zdGVycyBhbmQgdG93ZXJzIGFuZCBydW4gdGhlIGN5Y2xlXG4gICAgLy8gRWFjaCBydW5DeWNsZSBtZXRob2QgcmV0dXJucyBpbmZvcm1hdGlvbiBmb3IgdGhlIGdhbWVFbmdpbmUgdG9cbiAgICAvLyBwcm9jZXNzIChlLmcuIHRoZSBtb25zdGVyIGRpZWQsIHRvd2VyIGNoYW5nZWQpXG5cbiAgICAvLyAgdGltZXIgdG8gYWRkIG1vbnN0ZXJzXG4gICAgdGhpcy50aW1lci0tO1xuICAgIGlmICh0aGlzLnRpbWVyIDwgMSkge1xuICAgICAgICB0aGlzLmFkZE1vbnN0ZXIoJ2JsYWgnKTtcbiAgICAgICAgdGhpcy50aW1lciA9IDEwO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuYWN0aXZlTW9uc3RlcnMubGVuZ3RoOyBpIDwgajsgaSArKykge1xuICAgICAgICB0aGlzLmFjdGl2ZU1vbnN0ZXJzW2ldLm1vdmUoKTtcbiAgICB9XG4gICAgLy8gU2VuZCBpbmZvcm1hdGlvbiB0byByZW5kZXJcbn1cblxuLy8gbWV0aG9kIHRvIHVwZ3JhZGUgdG93ZXJcblxuLy8gNTAgeCA1MCB0b3dlclxuR2FtZUVuZ2luZS5wcm90b3R5cGUudmFsaWRhdGVUb3dlclBsYWNlbWVudCA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG5cbiAgICAvLyByZXR1cm5zIHRydWUgb3IgZmFsc2Ugd2hldGhlciB0b3dlciBwbGFjZW1lbnQgaXMgdmFsaWRcbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuR2FtZUVuZ2luZS5wcm90b3R5cGUuY2hlY2tNb25zdGVyRGVhdGggPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuYWN0aXZlTW9uc3RlcnMubGVuZ3RoOyBpIDwgajsgaSArKykge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVNb25zdGVyc1tpXS5jaGVja0RlYXRoKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlTW9uc3RlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgai0tO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyByZWRyYXcgY2FudmFzXG5cbm1vZHVsZS5leHBvcnRzID0gR2FtZUVuZ2luZTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvY2xhc3Nlcy9HYW1lLmpzXG4gKiogbW9kdWxlIGlkID0gNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIG1vbnN0ZXJEYXRhID0gcmVxdWlyZShcIi4uL2dhbWVEYXRhL21vbnN0ZXJkYXRhLmpzXCIpO1xuXG52YXIgTW9uc3RlciA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuY3VycmVudEhwID0gbW9uc3RlckRhdGFbaWRdLm1heEhwO1xuICAgIHRoaXMubWF4SHAgPSBtb25zdGVyRGF0YVtpZF0ubWF4SHA7XG4gICAgdGhpcy5iYXNlTXMgPSBtb25zdGVyRGF0YVtpZF0uYmFzZU1zOyAvLyBNb3ZlbWVudCBzcGVlZCAtIFwidW5pdHNcIiBwZXIgc2Vjb25kXG4gICAgdGhpcy50eXBlID0gbW9uc3RlckRhdGFbaWRdLnR5cGU7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHsgLy8gQWxsIG1vbnN0ZXJzIGFyZSBjcmVhdGVkIGluIHRoZSBzYW1lIHBvc2l0aW9uXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDQ4NVxuICAgIH1cbn07XG4vLyBNZXRob2QgdGhlIGdhbWUgb2JqZWN0IHVzZXMgdG8gbW92ZSBtb25zdGVyc1xuTW9uc3Rlci5wcm90b3R5cGUucnVuQ3ljbGUgPSBmdW5jdGlvbigpIHtcblxufVxuXG5Nb25zdGVyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oKSB7XG4gICAgZHluYW1pY0NvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgZHluYW1pY0NvbnRleHQucmVjdCh0aGlzLnBvc2l0aW9uLngsIHRoaXMucG9zaXRpb24ueSwgMzAsIDMwKTtcbiAgICBkeW5hbWljQ29udGV4dC5zdHJva2UoKTtcbiAgICBkeW5hbWljQ29udGV4dC5maWxsU3R5bGUgPSBcInJlZFwiO1xuICAgIGR5bmFtaWNDb250ZXh0LmZpbGxSZWN0KHRoaXMucG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uLnkgKyAzMC8zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMwICogdGhpcy5jdXJyZW50SHAvdGhpcy5tYXhIcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAzMC8zKTtcbn1cblxuTW9uc3Rlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuXG59O1xuXG5Nb25zdGVyLnByb3RvdHlwZS5jaGVja0RlYXRoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudEhwIDw9IDA7XG59O1xuXG4vLyBFeHBlY3RzIHVwLCBkb3duLCBsZWZ0IG9yIHJpZ2h0XG5Nb25zdGVyLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgdmFyIHNwZWVkID0gdGhpcy5iYXNlTXM7XG5cbiAgICAvLyBzb21lIGJhc2ljIG1vbnN0ZXIgTW92ZW1lbnRcbiAgICAvLyAgTk9URSBzdWNoIGEgaGFzc2xlIHRvIGZpZ3VyZSB0aGlzIG91dFxuICAgIC8vICBUT0RPIG5vdCBmaW5pc2hlZCwgbm90IGV2ZW4gZ29pbmcgdG8gdHJ5IGFuZCBmaW5pc2ggd2lsbCBmaWd1cmUgb3V0IGhvdyB0aGlzIHNob3VsZCB3b3JrIGxhdGVyXG4gICAgaWYgKHRoaXMucG9zaXRpb24ueCA8PSA1MCAmJiB0aGlzLnBvc2l0aW9uLnkgPCA1MDApIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi54ICs9IHNwZWVkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wb3NpdGlvbi54ID49IDUwICYmIHRoaXMucG9zaXRpb24ueSA+PSA5MCkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uLnkgLT0gc3BlZWQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBvc2l0aW9uLnggPD0gMTgwICYmIHRoaXMucG9zaXRpb24ueSA+PSA4MCkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uLnggKz0gc3BlZWQ7XG4gICAgfVxuXG4gICAgLy8gIG1heSBub3QgYmUgdGhlIGJlc3Qgd2F5IHRvIGRvIHRoaXMgYnV0IGlsbCBrZWVwIGl0IGJlY2F1c2Ugbm90IGV2ZW4gc3VyZSBob3cgdG8gZG8gdGhpcyBtb3ZlbWVudCBwYXJ0XG4gICAgLy8gaWYgKHR5cGVvZiBkaXJlY3Rpb24gIT09IFwic3RyaW5nXCIpIHtcbiAgICAvLyAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImRpcmVjdGlvbiBpcyBub3QgYSBzdHJpbmdcIik7XG4gICAgLy8gfVxuICAgIC8vIGRpcmVjdGlvbiA9IGRpcmVjdGlvbi50b0xvd2VyQ2FzZSgpO1xuICAgIC8vIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgLy8gICAgIGNhc2UgXCJ1cFwiOlxuICAgIC8vICAgICBjYXNlIFwiZG93blwiOlxuICAgIC8vICAgICBjYXNlIFwibGVmdFwiOlxuICAgIC8vICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAvLyAgICAgZGVmYXVsdDpcbiAgICAvLyAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGlyZWN0aW9uXCIpO1xuICAgIC8vIH1cbn07XG5cbi8vIENhbiB0YWtlIGluIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgbnVtYmVyXG5Nb25zdGVyLnByb3RvdHlwZS51cGRhdGVIcCA9IGZ1bmN0aW9uKGhwQ2hhbmdlKSB7XG4gICAgdGhpcy5jdXJyZW50SHAgKz0gaHBDaGFuZ2U7XG5cbiAgICBpZiAodGhpcy5jdXJyZW50SHAgPiB0aGlzLm1heEhwKSB7XG4gICAgICAgIHRoaXMuY3VycmVudEhwID0gdGhpcy5tYXhIcDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1vbnN0ZXI7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2pzL2NsYXNzZXMvTW9uc3Rlci5qc1xuICoqIG1vZHVsZSBpZCA9IDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG1vbnN0ZXIxOiB7XG4gICAgICAgIG1heEhwOiAzMCxcbiAgICAgICAgYmFzZU1zOiAxMCxcbiAgICAgICAgdHlwZTogMSAvLyBDaGFuZ2UgdGhpcyB0eXBlIGxhdGVyXG4gICAgfVxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvZ2FtZURhdGEvbW9uc3RlcmRhdGEuanNcbiAqKiBtb2R1bGUgaWQgPSA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9