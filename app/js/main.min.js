/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/src/js/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	// Canvas
	__webpack_require__(2);
	
	// User interaction elements
	__webpack_require__(3);


/***/ },
/* 2 */
/***/ function(module, exports) {

	// background contains the static canvas elements
	var background = document.getElementById("static");
	var backgroundContext = background.getContext("2d");
	
	// Settings for the background - move out to a separate file
	var settings = {
	    backgroundColor: "#8CD1E6",
	    pathColor: "gray"
	}
	
	// Drawing the background
	backgroundContext.fillStyle = settings.backgroundColor;
	backgroundContext.fillRect(0, 0, background.width, background.height);
	
	/* Main path will go from [0, 500], [75, 500], [75, 100], [225, 100], [225, 500], [375, 500], [375, 100], [525, 100], [525, 500], [675, 500], [675, 100], [825, 100], [825, 500], [900, 500] */
	
	// Drawing the path - width of the path is 50px
	backgroundContext.fillStyle = settings.pathColor;
	
	backgroundContext.beginPath();
	
	// For the bottom part of the path
	backgroundContext.moveTo(0, 525);
	
	backgroundContext.lineTo(100, 525);
	backgroundContext.lineTo(100, 125); // Top
	backgroundContext.lineTo(200, 125);
	backgroundContext.lineTo(200, 525); // Bottom
	backgroundContext.lineTo(400, 525);
	backgroundContext.lineTo(400, 125); // Top
	backgroundContext.lineTo(500, 125);
	backgroundContext.lineTo(500, 525); // Bottom
	backgroundContext.lineTo(700, 525);
	backgroundContext.lineTo(700, 125); // Top
	backgroundContext.lineTo(800, 125);
	backgroundContext.lineTo(800, 525); // Bottom
	
	//Middle section to the side
	backgroundContext.lineTo(900, 525);
	backgroundContext.lineTo(900, 475);
	backgroundContext.lineTo(850, 475);
	
	// For the top part of the path
	backgroundContext.lineTo(850, 75);
	backgroundContext.lineTo(650, 75);
	backgroundContext.lineTo(650, 475);
	backgroundContext.lineTo(550, 475);
	backgroundContext.lineTo(550, 75);
	backgroundContext.lineTo(350, 75);
	backgroundContext.lineTo(350, 475);
	backgroundContext.lineTo(250, 475);
	backgroundContext.lineTo(250, 75);
	backgroundContext.lineTo(50, 75);
	backgroundContext.lineTo(50, 475);
	
	// End section
	backgroundContext.lineTo(0, 475);
	
	backgroundContext.fill();
	// backgroundContext.lineTo();
	
	// draw a grid (for development purposes)
	var width = 900, height = 600;
	// draw vertical lines
	for (var i = 0; i < width; i += 25) {
	    backgroundContext.moveTo(i, 0);
	    backgroundContext.lineTo(i, height);
	    backgroundContext.stroke();
	}
	// draw horizontal lines
	for (var i = 0; i < height; i += 25) {
	    backgroundContext.moveTo(0, i);
	    backgroundContext.lineTo(width, i);
	    backgroundContext.stroke();
	}


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	// Initiate all the components
	var Tower = __webpack_require__(4),
	    GameEngine = __webpack_require__(9);
	
	// Import and declare utility functions
	var utils = __webpack_require__(6);
	
	var constants = __webpack_require__(7);
	
	// Cache reused DOM elements
	var infoName = document.getElementById("info-name"),
	    infoIcon = document.getElementById("info-icon"),
	    infoBox1 = document.getElementById("info-box-1"),
	    infoBox2 = document.getElementById("info-box-2"),
	    infoBox3 = document.getElementById("info-box-3"),
	    infoBox4 = document.getElementById("info-box-4"),
	    levelInfo = document.getElementById("level"),
	    goldInfo = document.getElementById("gold"),
	    livesInfo = document.getElementById("lives"),
	    towerCards = document.getElementsByClassName("tower-card"),
	    towerCardList = [];
	
	// Convert from nodelist to array
	towerCards = Array.prototype.slice.call(towerCards);
	
	/*
	Create state variables - These are modified on user interaction events
	State variables
	activeCanvasElement - Changed on a mouse click event on a monster, tower or nothing
	activeTowerSelected - The name of the tower that is being placed by the user
	activeMessage - Message displayed in the canvas (can be used for new levels, invalid tower placements, etc)
	canvasMousePosition -
	    onCanvas - boolean to represent whether the mouse is currently on the canvas
	    towerPosition - object with a grid value and coordinate value and sides
	        grid - the top left block of the tower being placed - towers are a 2x2 grid
	        coordinate - the top left corner coordinate
	        sides - 50 px
	    mousePosition - the current mouse coordinates
	*/
	
	var activeCanvasElement = {type: null},
	    activeTowerSelected = null,
	    activeMessage = {message: null},
	    canvasMousePosition = {
	        onCanvas: false,
	        towerPosition: {},
	        mousePosition: {}
	    };
	
	//  creates global variables
	game = new GameEngine;
	dynamicCanvas = document.getElementById('dynamic');
	dynamicContext = dynamicCanvas.getContext('2d');
	
	// Declare the game loop
	var lastTime,
	    gameLoop = function() {
	    var now = Date.now(),
	        dt = (now - lastTime) / 1000.0; // Convert to seconds
	
	    game.runCycle(dt);
	
	    lastTime = now;
	    // Renders methods based on state variables
	    game.render();
	    updateGameInformation();
	    renderTowerPlacement();
	    renderMessage(dt);
	    requestAnimationFrame(gameLoop);
	}
	
	/* ================== Render functions =================*/
	/* =====================================================*/
	// Render functions run every game cycle (on the gameLoop function call)
	// Renders based on the state variables
	
	function updateGameInformation() {
	    livesInfo.innerHTML = game.userLives;
	    goldInfo.innerHTML = game.userGold;
	    levelInfo.innerHTML = game.level;
	
	    if (activeCanvasElement.type === "monster") {
	        renderMonsterInformation(activeCanvasElement.index);
	    } else if (activeCanvasElement.type === "tower") {
	        renderTowerInformation(activeCanvasElement.index);
	    } else {
	        renderDefaultInformation();
	    }
	}
	
	// ID refers to the type of monster and index is the index of the active monster in the active monster's array
	function renderMonsterInformation(index) {
	    var currentHp = game.activeMonsters[index].currentHp,
	        maxHp = game.activeMonsters[index].maxHp,
	        type = game.activeMonsters[index].type,
	        id = game.activeMonsters[index].id;
	
	    infoName.innerHTML = id;
	    // Change icon to active monster - use a sprite
	    infoBox1.innerHTML = "HP: " + currentHp + " / " + maxHp;
	    infoBox2.innerHTML = "Type: " + type;
	    infoBox3.innerHTML = "Strengths: All sorts mate" ;
	    infoBox4.innerHTML = "Weaknesses: Ducks" ;
	}
	
	// ID refers to the type of tower and index is the index of the active tower in the active tower's array
	function renderTowerInformation(index) {
	    var id = game.towers[index].id;
	
	    infoName.innerHTML = id;
	    // Change icon to active monster - use a sprite
	    infoBox1.innerHTML = "Damage: <br> Range: <br> Effect: ";
	    infoBox2.innerHTML = "Attack Speed: <br> Type: " ;
	    infoBox3.innerHTML = "<a class='waves-effect waves-light btn red'>Upgrade</a>" ;
	    infoBox4.innerHTML = "<a class='waves-effect waves-light btn red'>Sell</a>" ;
	    // Change icon to tower monster - use a sprite
	
	}
	
	function renderDefaultInformation() {
	    infoName.innerHTML = "Awesome TD";
	    // Change icon to default image - use a sprite
	    infoBox1.innerHTML = "This is some text";
	    infoBox2.innerHTML = "This is different text";
	    infoBox3.innerHTML = "This is ??? text" ;
	    infoBox4.innerHTML = "This 1231241235" ;
	}
	
	function renderMessage(dt) {
	    if (activeMessage.message === null) {
	        return;
	    } else {
	        dynamicContext.globalAlpha = activeMessage.timer > 0 ? activeMessage.timer : 0; // Sets transparency to 0 if a negative number
	        dynamicContext.font = constants.MESSAGEFONT;
	        dynamicContext.textAlign = "center";
	        dynamicContext.fillStyle = constants.MESSAGECOLOR;
	        dynamicContext.fillText(activeMessage.message, constants.CANVASWIDTH / 2, 50);
	        dynamicContext.globalAlpha = 1;
	
	        if (activeMessage.timer <= 0) {
	            activeMessage = {message: null}; // Reset message
	        } else {
	            activeMessage.timer -= dt;
	        }
	    }
	}
	
	function renderTowerPlacement() {
	    if (activeTowerSelected === null ||
	        !canvasMousePosition.onCanvas) {
	        return
	    };
	
	    var coordinates = canvasMousePosition.towerPosition.coordinates;
	    dynamicContext.beginPath();
	    dynamicContext.globalAlpha = 0.5;
	
	    if (game.validateTowerPlacement(canvasMousePosition.towerPosition.grid)) { // check for valid tower placement
	        dynamicContext.fillStyle = "green";
	    } else {
	        dynamicContext.fillStyle = "red";
	        // do some sort of logic to highlight the tiles that the tower would be placed on and show the tower on those positions
	        // this would run when tower placement is invalid
	    }
	    dynamicContext.fillRect(coordinates.x,
	                            coordinates.y,
	                            constants.TOWERLENGTH,
	                            constants.TOWERLENGTH
	     );
	
	    dynamicContext.globalAlpha = 0.7;
	    dynamicContext.arc(coordinates.x + constants.TOWERLENGTH / 2,
	                       coordinates.y + constants.TOWERLENGTH / 2,
	                       constants.TOWERLENGTH * 0.6,
	                       0,
	                       2 * Math.PI,
	                       false
	     );
	    dynamicContext.fillStyle = 'gray';
	    dynamicContext.fill();
	
	    dynamicContext.globalAlpha = 1;
	    dynamicContext.closePath();
	}
	
	/* ================ UI Event Listeners =================*/
	/* =====================================================*/
	document.getElementById("start-btn").addEventListener("click", function() {
	    // Hides the modal lightbox
	    document.getElementsByClassName("modal-content")[0].style.display = "none";
	    document.getElementsByClassName("modal-background")[0].style.display = "none";
	
	    // Set game to start
	    game.gameStart();
	    // Sets up game loop and render loop
	    lastTime = Date.now();
	    requestAnimationFrame(gameLoop);
	});
	
	// On clicking the information button, show the information panel
	document.getElementById("information-btn").addEventListener("click", function() {
	    // TODO - add information modal information thingy
	    console.log("show information container here");
	});
	
	/*
	These event listeners control the application by interacting with the game
	object and by changing the state variables (which the render functions use
	to read)
	*/
	towerCards.map(function(towerCard, i) {
	    towerCardList.push(towerCard.getAttribute("data-tower"));
	    towerCard.addEventListener("click", towerCardClick);
	});
	
	document.getElementById("dynamic").onmousemove = onCanvasMouseMovement;
	document.getElementById("dynamic").addEventListener("click", canvasClick);
	
	document.onkeydown = function(e) {
	    if (e.keyCode === 27) {
	        cancelTowerPlacement();
	    }
	}
	
	// updates activeCanvasElement when monster death (if the active element is a monster)
	document.addEventListener("monsterDeath", function(e) {
	    if (activeCanvasElement.type === "monster") {
	        if (e.detail.index < activeCanvasElement.index) {
	            activeCanvasElement.index--;
	        } else if (e.detail.index === activeCanvasElement.index) {
	            activeCanvasElement = {type: null} // Reset
	        }
	    }
	});
	
	/* =================== UI Functions ====================*/
	/* =====================================================*/
	/* Click event listener on the tower cards
	Used to control what tower is being actively placed on the canvas
	4 possible flows based on the state of the interface
	1) The tower that was clicked is currently disabled:
	    -> function returns
	2) No towers are actively being placed
	    -> the clicked tower card now becomes the active tower being placed
	3) The clicked tower is the same as the tower actively being placed
	    -> the state is reset so that no towers are actively being placed
	4) The clicked tower is different from the tower actively being placed
	    -> the state is changed to the clicked tower becoming the active tower
	*/
	function towerCardClick() {
	
	    var towerName = this.getAttribute("data-tower"),
	        oldTowerIndex = towerCardList.indexOf(activeTowerSelected),
	        newTowerIndex = towerCardList.indexOf(towerName);
	
	    if (/disabled/i.test(this.className)) {
	        return;
	
	    } else if (activeTowerSelected === null) {
	        activeTowerSelected = towerName;
	        utils.addClass(towerCards[newTowerIndex], "active");
	        canvasMousePosition.onCanvas = false;
	    } else if (activeTowerSelected === towerName) {
	        cancelTowerPlacement();
	        canvasMousePosition.onCanvas = false;
	    } else {
	        utils.removeClass(towerCards[oldTowerIndex], "active");
	        activeTowerSelected = towerName;
	        utils.addClass(towerCards[newTowerIndex], "active");
	        canvasMousePosition.onCanvas = false;
	
	    }
	}
	
	/*
	Called from towerCardClick (when clicking the active tower card) and on an escape key press
	Resets the active tower placement state to null
	*/
	function cancelTowerPlacement() {
	    utils.removeClass(towerCards[towerCardList.indexOf(activeTowerSelected)], "active");
	    activeTowerSelected = null;
	}
	
	/* Mouse move event listener on the canvas
	If the active tower selected state (a tower is being placed by the user):
	    -> update the position of the mouse on the canvas (used by the renderTowerPlacement function)
	otherwise:
	    -> do nothing
	*/
	function onCanvasMouseMovement(e) {
	    if (activeTowerSelected === null) {
	        return
	    };
	
	    var canvasContainer = this.getBoundingClientRect(),
	        position = {};
	
	    position.x = e.clientX - canvasContainer.left;
	    position.y = e.clientY - canvasContainer.top;
	    canvasMousePosition.mousePosition = position;
	    canvasMousePosition.towerPosition = utils.convertPositionToTower(position);
	    canvasMousePosition.onCanvas = true;
	};
	
	
	/* Click event listener on the canvas
	Handles two possible canvas click scenarios
	1) A tower is selected and is actively being placed
	    -> Clicking will validate the tower placement and check the user's gold
	    if both are valid, will tower will be placed (by game object)
	    otherwise, an error message will show up
	2) A tower is not selected and is not being placed
	    -> Will check whether the click position overlaps with the bounding
	    rectangle of monster or tower - if so, it will return the information
	    in the information container
	*/
	function canvasClick(e) {
	    // Get click location relative to the canvas element
	    var canvasContainer = this.getBoundingClientRect(),
	        position = {},
	        towerGridPosition = canvasMousePosition.towerPosition.grid,
	        towerCoordinates = canvasMousePosition.towerPosition.coordinates; // Passes in grid blocks - this is the topLeft block
	
	    position.x = e.clientX - canvasContainer.left;
	    position.y = e.clientY - canvasContainer.top;
	
	    // Runs if the user is placing a tower
	    if (activeTowerSelected !== null) {
	        var towerName = activeTowerSelected,
	            towerPlaced = game.placeTower(towerName, towerGridPosition, towerCoordinates);
	
	        // If the tower was not placed, show an error message
	        if (!towerPlaced.placed) {
	            activeMessage = {
	                message: towerPlaced.message,
	                timer: constants.MESSAGEDURATION // seconds
	            }
	        }
	
	        utils.removeClass(towerCards[towerCardList.indexOf(activeTowerSelected)], "active");
	        activeTowerSelected = null;
	    } else {
	        // User is not running a tower placement
	        activeCanvasElement = game.checkClickLocation(position);
	        updateGameInformation();
	    }
	
	}


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var towerData = __webpack_require__(5),
	    utils = __webpack_require__(6),
	    Projectile = __webpack_require__(8),
	    constants = __webpack_require__(7);
	
	// Position refers to the upper left corner of the elements
	// Tower width - 50 x 50
	var Tower = function(position, id) {
	    if (towerData[id] === undefined) {
	        throw new Error("Invalid tower name, check html dataattribute or towerdata")
	    }
	    this.id = id;
	    this.damage = towerData[id].damage;
	    this.attackSpeed = towerData[id].attackSpeed; // Attack speed
	    this.cooldown = 0;
	    this.range = towerData[id].range; // Range of the tower
	    this.type = towerData[id].type; // Type of damage
	    this.effect = towerData[id].effect; // Special effect (e.g. slow, splash, etc)
	    this.goldCost = towerData[id].goldCost;
	    this.position = position; // object with x and y coordinates - references the top left corner of the tower
	    this.position.sideLength = constants.TOWERLENGTH;
	}
	// Method the game object uses to run towers
	Tower.prototype.runCycle = function(activeMonsters, dt) {
	    var targetMonster = null;
	
	    for (var i = 0; i < activeMonsters.length; i++) {
	        if (this.checkInRange(activeMonsters[i].position)) {
	            targetMonster = i;
	            break;
	        }
	    }
	
	    // Create a projectile if there is a monster in range and the tower has a cooldown of 0
	    if (targetMonster !== null && this.cooldown < 0) {
	        activeMonsters[targetMonster].projectiles.push(new Projectile(this.id, this.position));
	        this.cooldown = this.attackSpeed;
	    }
	
	    if (this.cooldown >= 0) {
	        this.cooldown -= dt;
	    }
	}
	// change this to reference a list or something where a name can be used to determine the properties
	// Takes in a monster's position and checks whether that is in range based on the range - returns true or false if in range which can be used to
	Tower.prototype.checkInRange = function(monsterPosition) {
	    // using sqrt((x2-x1)^2 - (y2-y1)^2)
	    var monsterDistance = utils.getPositionDifference(monsterPosition, this.position);
	
	   if (monsterDistance <= this.range) {
	       return true;
	   } else {
	       return false;
	   }
	}
	
	Tower.prototype.draw = function() {
	    dynamicContext.beginPath();
	    dynamicContext.fillStyle = "green";
	    dynamicContext.fillRect(this.position.x,
	                            this.position.y,
	                            constants.TOWERLENGTH,
	                            constants.TOWERLENGTH);
	    dynamicContext.closePath();
	}
	
	module.exports = Tower;


/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = {
	    basic: {
	        projectile: {
	            damage: 5,
	            travelTime:0.5, // time in seconds before impact
	            sprite: "abc" // change this to have animations
	        },
	        attackSpeed: 1, // 1 second per attack
	        range: 300,
	        goldCost: 10,
	        type: "basic",
	        effect: "none"
	    }
	};


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var constants = __webpack_require__(7);
	
	/* ================== Public functions =================*/
	/* =====================================================*/
	function addClass(element, cssClass) {
	    if (element.className === "") {
	        element.className = cssClass;
	    } else {
	        element.className += " " + cssClass;
	    }
	}
	
	/*
	checkIfInSquare checks whether a point is in a square (which is a monster or a tower)
	
	Takes in three arguments
	point - a object with x and y coordinates
	topLeftPoint - an object with x and y coordinates of the top left corner of the square
	sideLength - the length of the square
	
	Returns a boolean - true if the click overlaps with an element and false
	                    if it does not
	*/
	function checkIfInSquare(point, topLeftPoint, sideLength) {
	    if (point.x >= topLeftPoint.x
	    && point.x <= topLeftPoint.x + sideLength
	    && point.y >= topLeftPoint.y
	    && point.y <= topLeftPoint.y + sideLength) {
	        return true;
	    } else {
	        return false;
	    }
	}
	
	/*
	Takes in a distance (int) and pathLines(array of path objects) and converts it to coordinates for a monster
	Returns a coordinate object
	*/
	function convertDistanceToCoordinates(distance, pathLines) {
	    var coordinates,
	        end = false; // Boolean to represent whether the monster is at the end
	
	
	    for (var i = 0; i < pathLines.length; i ++) {
	        if (distance - pathLines[i].distance <= 0) {
	            break;
	        } else {
	            distance -= pathLines[i].distance;
	        }
	    }
	
	    if (i === pathLines.length) {
	        i--; // Set the counter value to be the last value in the pathlines array
	        distance =  pathLines[i].distance;
	        end = true;
	    }
	
	    // Create a new object to return (instead of modifiying startPoint object)
	    coordinates = Object.create(pathLines[i].startPoint);
	    coordinates.end = end;
	
	    // Case for when monster is at the end of the thingy - there is a better way to write this but not right now
	    if (!end) {
	        switch (pathLines[i].direction) {
	            // 15 is a half of the monster width
	            // values used to offset the positioning based on the monster direciton movement
	            case "up":
	            coordinates.x -= constants.MONSTERLENGTH/2;
	            coordinates.y -= distance + constants.MONSTERLENGTH/2;
	            break;
	            case "down":
	            coordinates.x -= constants.MONSTERLENGTH/2;
	            coordinates.y += distance - constants.MONSTERLENGTH/2;
	            break;
	            case "left":
	            coordinates.x -= distance + constants.MONSTERLENGTH/2;
	            coordinates.y -= constants.MONSTERLENGTH/2;
	            break;
	            case "right":
	            coordinates.x += distance - constants.MONSTERLENGTH/2;
	            coordinates.y -= constants.MONSTERLENGTH/2;
	            break;
	            default:
	            throw new Error("Invalid direction provided in pathLines");
	        }
	    } else {
	        switch (pathLines[i].direction) {
	            case "up":
	                coordinates.y -= pathLines[i].distance;
	                break;
	            case "down":
	                coordinates.y += pathLines[i].distance;
	                break;
	            case "left":
	                coordinates.x -= pathLines[i].distance;
	                break;
	            case "right":
	                coordinates.x += pathLines[i].distance;
	                break;
	            default:
	                throw new Error("Invalid direction provided in pathLines");
	        }
	
	    }
	
	    return coordinates
	}
	
	// Takes in a position object with coordinates{x, y}
	// returns a block object {x, y} with block numbers
	// Handles edge cases of the block being defined at the edge (36 and 24 which are invalid in the )
	function convertToBlock(position) {
	    var xGridAmount = constants.CANVASWIDTH / constants.GRIDSIZE,
	        yGridAmount = constants.CANVASHEIGHT / constants.GRIDSIZE;
	
	    if (position.x > (xGridAmount * (constants.TOWERLENGTH/2)) ||
	        position.y > (yGridAmount * (constants.TOWERLENGTH/2))) {
	        console.log(position)
	        throw new Error("Position out of grid range");
	    }
	
	    var block = {
	        x: Math.floor(position.x / (constants.TOWERLENGTH/2)),
	        y: Math.floor(position.y / (constants.TOWERLENGTH/2))
	    };
	    // Adjusts if mouse is at end of container
	    // 36 blocks width and 24 blocks height
	    if (block.x >= xGridAmount - 1) {
	        block.x--;
	    }
	
	    if (block.y >= yGridAmount - 1) {
	        block.y--;
	    }
	
	    return block;
	}
	
	/*
	Takes in a position object (x and y coordinates)
	Returns the top left block position and topleft coordinate of the tower
	Grid blocks are in 25x25 block increments
	*/
	function convertPositionToTower(position) {
	    var towerPosition = {
	        grid: {},
	        coordinates: {},
	        side: constants.TOWERLENGTH
	    },
	        xGridAmount = constants.CANVASWIDTH / constants.GRIDSIZE,
	        yGridAmount = constants.CANVASHEIGHT / constants.GRIDSIZE;
	
	
	    towerPosition.grid = convertToBlock(position);
	
	    // Container width and height 900 and 600 px respectively
	    towerPosition.coordinates.x = (towerPosition.grid.x / xGridAmount) * constants.CANVASWIDTH;
	    towerPosition.coordinates.y = (towerPosition.grid.y / yGridAmount) * constants.CANVASHEIGHT;
	    return towerPosition;
	}
	/*
	getPathPosition inputs:
	initialPosition: position object {x, y}
	finalPosition: position object {x, y}
	fractionTravelled: decimal of how far along the path
	
	Output: position object {x, y}
	*/
	function getPathPosition(pos1, pos2, fractionTravelled) {
	    var finalPosition = {},
	        angle = Math.atan2(pos2.y - pos1.y, pos2.x - pos1.x), // the line angle (in radians) from pos1 to pos2 with respect to the origin
	        distanceFromPos1 = getPositionDifference(pos1, pos2) * fractionTravelled;
	
	    finalPosition.x = pos1.x + distanceFromPos1 * Math.cos(angle);
	    finalPosition.y = pos1.y + distanceFromPos1 * Math.sin(angle);
	
	    return finalPosition;
	}
	
	function getPositionDifference(position1, position2) {
	    return Math.sqrt(
	            Math.pow(position1.x-position2.x, 2) +
	            Math.pow(position1.y-position2.y, 2)
	    );
	}
	
	function removeClass(element, cssClass) {
	    var arrayOfClasses = element.className.split(" ");
	    for (var i = 0, j = arrayOfClasses.length; i < j; i++) {
	        if (arrayOfClasses[i] === cssClass) {
	            arrayOfClasses.splice(i, 1);
	            i--; j--;
	        }
	    }
	    element.className = arrayOfClasses.join(" ");
	}
	
	module.exports = {
	    addClass: addClass,
	    checkIfInSquare: checkIfInSquare,
	    convertToBlock: convertToBlock,
	    convertDistanceToCoordinates: convertDistanceToCoordinates,
	    convertPositionToTower: convertPositionToTower,
	    getPathPosition: getPathPosition,
	    getPositionDifference: getPositionDifference,
	    removeClass: removeClass
	}


/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = {
	    CANVASWIDTH: 900, // probably need a way to set the html canvas size from here
	    CANVASHEIGHT: 600, // probably need a way to set the html canvas size from here
	    GRIDSIZE: 25,
	    TOWERLENGTH: 50,
	    MONSTERLENGTH: 30,
	    PROJECTILELENGTH: 10,
	    MONSTERSPERLEVEL: 10,
	    TIMEBETWEENMONSTERCREATE: 1, // second
	    TIMEBETWEENLEVELS: 2, // seconds
	    FINALLEVEL: 50,
	    STARTINGGOLD: 10,
	    STARTINGLIVES: 30,
	    MESSAGEFONT: '40pt Droid Sans',
	    MESSAGECOLOR: 'red',
	    MESSAGEDURATION: 0.8,
	    MESSAGEINVALIDPLACEMENT: "Invalid Tower Placement",
	    MESSAGENOTENOUGHGOLD: "Not Enough Gold",
	
	
	
	
	
	}


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var towerData = __webpack_require__(5),
	    utils = __webpack_require__(6),
	    constants = __webpack_require__(7);
	
	// Projectiles are attached to monsters
	var Projectile = function(id, towerPosition) {
	    this.damage = towerData[id].projectile.damage;
	    this.totalTravelTime = towerData[id].projectile.travelTime;
	    this.sprite = towerData[id].projectile.sprite;
	    this.currentTravelTime = 0;
	    this.end = false;
	    this.initialPosition = {
	        x: towerPosition.x + (constants.TOWERLENGTH/2) - (constants.PROJECTILELENGTH/2),
	        y: towerPosition.y + (constants.TOWERLENGTH/2) - (constants.PROJECTILELENGTH/2)
	    };
	}
	
	Projectile.prototype.draw = function(monsterPosition) {
	    var fractionTravelled = this.currentTravelTime / this.totalTravelTime,
	        adjustedMonsterPosition = {
	            x: monsterPosition.x + (constants.MONSTERLENGTH/2) - (constants.PROJECTILELENGTH/2),
	            y: monsterPosition.y + (constants.MONSTERLENGTH/2) - (constants.PROJECTILELENGTH/2)
	        },
	        position = utils.getPathPosition(this.initialPosition, adjustedMonsterPosition, fractionTravelled);
	
	    // Calculate a fraction based on currentTravelTime / travelTime to get the position
	    dynamicContext.beginPath();
	    dynamicContext.fillStyle = "orange";
	    dynamicContext.rect(position.x, position.y, constants.PROJECTILELENGTH, constants.PROJECTILELENGTH);
	    dynamicContext.fill();
	    // Change this to use a sprite
	    // draw based on position here
	
	    dynamicContext.closePath();
	}
	
	Projectile.prototype.move = function(dt) {
	    this.currentTravelTime += dt;
	    if (this.currentTravelTime >= this.totalTravelTime) {
	        this.end = true;
	    }
	}
	
	module.exports = Projectile;


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	//  require Monster to gain access
	var Monster = __webpack_require__(10),
	    Tower = __webpack_require__(4),
	    towerData = __webpack_require__(5),
	    utils = __webpack_require__(6),
	    pathCoordinates = __webpack_require__(12),
	    constants = __webpack_require__(7);
	
	var GameEngine = function() {
	    this.userGold = constants.STARTINGGOLD;
	    this.level = 0;
	    this.userLives = constants.STARTINGLIVES;
	    this.activeMonsters = []; // List of active monsters in the game
	    this.towers = []; // object of tower objects
	    this.timer = constants.TIMEBETWEENMONSTERCREATE;
	    this.nextLevelCalled = false;
	    this.monstersToCreate = 0;
	    this.gamePath = _convertPathToLines(pathCoordinates.path);
	    this.gameState = "start"; // Possible values are start, lost, won, playing
	    this.gameGrid = _initiateGrid(this.gamePath);
	}
	
	GameEngine.prototype.addMonster = function(level) {
	    // add monster (specified by name) to game
	    var monster = new Monster("monster1");  // NOTE CHANGE THIS TO REPRESENT MONSTER BASED ON LEVEL
	    this.activeMonsters.push(monster);
	}
	
	GameEngine.prototype.addTower = function(id, position, gridPosition, goldCost) {
	    this.userGold -= goldCost;
	    var tower = new Tower(position, id);
	    this.towers.push(tower);
	    // Set gameGrid positioning
	    this.gameGrid[gridPosition.x][gridPosition.y] = false;
	    this.gameGrid[gridPosition.x + 1][gridPosition.y] = false;
	    this.gameGrid[gridPosition.x][gridPosition.y + 1] = false;
	    this.gameGrid[gridPosition.x + 1][gridPosition.y + 1] = false;
	}
	
	/*
	Takes in a position object (location of the click)
	Returns an object with information about what is at that position
	{type: null} if nothing found
	*/
	GameEngine.prototype.checkClickLocation = function(position) {
	    var element = {};
	    // Loops through activeMonsters
	    for (var i = 0; i < this.activeMonsters.length; i++) {
	        if (utils.checkIfInSquare(position, this.activeMonsters[i].position, this.activeMonsters[i].sideLength)) {
	            element.type = "monster";
	            element.index = i;
	            break;
	        }
	    }
	
	    // If nothing was found, loop through towers
	    if (element.type === undefined) {
	        for (var i = 0; i < this.towers.length; i++) {
	            if (utils.checkIfInSquare(position, this.towers[i].position, this.towers[i].position.sideLength)) {
	                element.type = "tower";
	                element.index = i;
	                break;
	            }
	        }
	    }
	
	    // If no towers or monsters found return a type of null
	    if (element.type === undefined) {
	        element.type = null;
	    }
	
	    return element;
	}
	
	GameEngine.prototype.checkGameState = function() {
	    if (this.level === constants.FINALLEVEL + 1) { // MAX level
	        this.gameState = "won";
	    } else if (this.userLives <= 0) {
	        this.gameState = "lost";
	    }
	}
	
	// method to check gold before place tower or upgrade
	GameEngine.prototype.checkGold = function(goldCost) {
	    if (goldCost <= this.userGold) {
	        return true;
	    } else {
	        return false;
	    }
	}
	
	GameEngine.prototype.gameOver = function() {
	
	}
	
	GameEngine.prototype.gameStart = function() {
	    this.gameState = "playing";
	    this.nextLevel();
	}
	
	GameEngine.prototype.gameWon = function() {
	
	}
	
	GameEngine.prototype.nextLevel = function() {
	    // Only calls the next level once - nextLevelCalled is reset on a new monster creation
	    if (this.nextLevelCalled === false) {
	        this.monstersToCreate = constants.MONSTERSPERLEVEL;
	        this.level++;
	    }
	}
	
	/*
	placeTower handles the validation of the tower placement (position and sufficient gold)
	Takes in 3 arguments:
	towerName - string specifying what tower is being placed
	gridPosition - top left grid block of where the tower would be placed
	towerCoordinates - top left coordinate of a tower
	Returns an object with a boolean to represent whether the tower is placed and an error message if the tower was not placed
	*/
	GameEngine.prototype.placeTower = function(towerName, gridPosition, towerCoordinates) {
	    var goldCost = towerData[towerName].goldCost;
	    // Validate tower placement
	    if (this.validateTowerPlacement(gridPosition)
	    && this.checkGold(goldCost)) {
	
	        this.addTower(towerName, towerCoordinates, gridPosition, goldCost);
	        return {
	            placed: true
	        };
	    } else {
	
	        if (!this.validateTowerPlacement(gridPosition)) {
	            return {
	                placed: false,
	                message: constants.MESSAGEINVALIDPLACEMENT
	            }
	        } else {
	            return {
	                placed: false,
	                message: constants.MESSAGENOTENOUGHGOLD
	            }
	        }
	    }
	
	}
	
	GameEngine.prototype.render = function() {
	
	    if (this.gameState === "playing") {
	        // send state to the display object to render
	        dynamicContext.beginPath();
	        dynamicContext.clearRect(0, 0, dynamicCanvas.width, dynamicCanvas.height);
	
	        // Render towers first so that if monsters are larger they show above towers
	        this.towers.forEach(function(tower) {
	            tower.draw();
	        })
	
	        //  loop through list of active monsters and render them
	        //  TODO probably need to find a better way to rend them apart from random rectangle
	        this.activeMonsters.forEach(function(activeMonster) {
	            activeMonster.draw();
	
	            // Renders projectile animations that are active for each monster
	            activeMonster.projectiles.forEach(function(projectile) {
	                projectile.draw(activeMonster.position);
	            });
	        });
	
	        dynamicContext.closePath();
	
	    } else if (this.gameState === "lost") {
	        // Add render method to add thing
	        console.log("you lost lol");
	    } else if (this.gameState === "won") {
	        // Add render method to add thing
	        console.log("congrats you won");
	    }
	
	};
	
	// Changed values to be based off dt (change in time since last render)
	GameEngine.prototype.runCycle = function(dt) {
	    this.checkGameState();
	
	    if (this.gameState === "playing") {
	        // loop through active monsters and towers and run the cycle
	        // Each runCycle method returns information for the gameEngine to
	        // process (e.g. the monster died, tower changed)
	
	        // Adds monsters if there are monsters to create - creates 10 per level
	        if (this.monstersToCreate > 0) {
	            //  timer to add monsters
	            this.timer -= dt;
	            if (this.timer <= 0) {
	                this.addMonster(this.level); // send through the level number
	                this.timer = constants.TIMEBETWEENMONSTERCREATE; // Every 1 second create a new monster
	                this.monstersToCreate--;
	                this.nextLevelCalled = false;
	            }
	        }
	
	        // Calls the next level if all the monsters are dead - TODO add a delay to space out between levels
	        // Checks whether there are any monsters left and whether all the monsters have been created
	        if (this.activeMonsters.length === 0 && this.monstersToCreate === 0) {
	            setTimeout(function() {
	                this.nextLevel();
	            }, constants.TIMEBETWEENLEVELS * 1000);
	
	            this.nextLevelCalled = true;
	        } else {
	            this.activeMonsters.forEach(function(activeMonster, i, monsterArray) {
	                // moves the monsters and checks whether they get to the end of the cycle
	                // also factor to have a projectiles array - which means that each cycle for monsters they will take damage
	                var monsterStatus = activeMonster.runCycle(this.gamePath, dt);
	
	                if (!monsterStatus.alive) {
	                    if (monsterStatus.giveGold) {
	                        this.userGold += activeMonster.bounty
	                    }
	                    var monsterDeath = new CustomEvent("monsterDeath", {"detail": {index: i}});
	                    document.dispatchEvent(monsterDeath);
	                    monsterArray.splice(i, 1)
	                }
	            }.bind(this));
	
	            // Run tower cycles here - pass in active monsters - towers only create projectiles
	            this.towers.forEach(function(tower) {
	                tower.runCycle(this.activeMonsters, dt); // Pass in active monsters and attach projectiles to them
	            }.bind(this));
	        }
	
	
	    }
	}
	/*
	Takes in a gridPosition object (points to the top left corner of the tower)
	Towers take up a 2x2 grid - this function checks all positions
	Returns true if the position is a valid placement for a tower
	Returns false if the position is invalid
	*/
	GameEngine.prototype.validateTowerPlacement = function(gridPosition) {
	    // Checks all 4 positions
	    var positionValid = this.gameGrid[gridPosition.x][gridPosition.y].empty
	    && this.gameGrid[gridPosition.x + 1][gridPosition.y].empty
	    && this.gameGrid[gridPosition.x][gridPosition.y + 1].empty
	    && this.gameGrid[gridPosition.x + 1][gridPosition.y + 1].empty;
	    return positionValid;
	}
	
	/*
	Input: Path - an array of objects containing coordinates where the path will run to
	Output: pathLines - an array of objects containing the startPoint (coordinates),
	        distance of the line and direction (left, right, up, down)
	*/
	function _convertPathToLines(path) {
	    var pathLines = [];
	    for (var i = 0; i < path.length - 1; i++) {
	        var line = {};
	
	        // Assume that the direction is only 4 ways
	        if (path[i+1].x - path[i].x === 0) {
	
	            if (path[i+1].y - path[i].y > 0) {
	                line.direction = "down";
	            } else {
	                line.direction = "up";
	            }
	        } else {
	            if (path[i+1].x - path[i].x === 0 > 0) {
	
	                line.direction = "left";
	            } else {
	                line.direction = "right";
	            }
	        }
	        line.startPoint = path[i];
	        line.distance = utils.getPositionDifference(path[i], path[i+1]);
	        pathLines.push(line);
	    }
	
	    return pathLines;
	}
	
	/*
	Converts a pathLines array (an array of objects with a startPoint,
	direction and a distance) into an array of grid blocks ()
	Note that there will be some overlap with blocks, however,
	as they are only used to set grid positions to not empty, overlap is not an issue
	*/
	function _createPathBlocks(pathLines) {
	    var blocks = [];
	    // Loops through all the pathLines and creates blocks based on that
	    for (var i = 0; i < pathLines.length; i++) {
	        // blockAmount refers to the amount of blocks that follow the path
	        var blockAmount = Math.floor(pathLines[i].distance / constants.GRIDSIZE) + 1,
	            pathDirection;
	        /* Set direction
	        x: 1 = right
	        x: -1 = left
	        y: 1 = down
	        y: -1 = up
	        Offset values help center the grid blocks (i.e. inline with the direction)
	        Side values are used to define which side the blocks are on relative to
	        the path direction (i.e. horizontally or vertically)
	        */
	        switch (pathLines[i].direction) {
	            case "up":
	                pathDirection = {
	                    x: 0,
	                    y: -1,
	                    xSide: constants.GRIDSIZE / 2,
	                    ySide: 0
	                }
	                break;
	            case "down":
	                pathDirection = {
	                    x: 0,
	                    y: 1,
	                    xSide: constants.GRIDSIZE / 2,
	                    ySide: 0
	                }
	                break;
	            case "left":
	                pathDirection = {
	                    x: -1,
	                    y: 0,
	                    xSide: 0,
	                    ySide: constants.GRIDSIZE / 2
	                }
	                break;
	            case "right":
	                pathDirection = {
	                    x: 1,
	                    y: 0,
	                    xSide: 0,
	                    ySide: constants.GRIDSIZE / 2
	                }
	                break;
	            default:
	                throw new Error("Invalid direction provided in pathLines");
	        }
	
	        /*
	        Creates block equal to double the amount of the blockAmount (the equivalent amount of blocks to the path distance)
	        blockBefore refers to blocks either to the left or top of the path
	        blockAfter refers to blocks either to the right or below of the path
	        Creates block locations and gives them offsets to their center positions (for clarity in converting to blocks)
	        */
	        for (var j = 0; j < blockAmount; j++) {
	
	            var blockBefore = {
	
	                x: pathLines[i].startPoint.x +
	                    pathDirection.xSide +
	                    (pathDirection.x * constants.GRIDSIZE * j),
	
	                y: pathLines[i].startPoint.y +
	                    pathDirection.ySide +
	                    (pathDirection.y * constants.GRIDSIZE * j )
	
	            },
	                blockAfter = {
	                    x: pathLines[i].startPoint.x +
	                        pathDirection.xSide +
	                        (pathDirection.x * constants.GRIDSIZE * j),
	
	                    y: pathLines[i].startPoint.y  +
	                        pathDirection.ySide +
	                        (pathDirection.y * constants.GRIDSIZE * j)
	            };
	            blocks.push(utils.convertToBlock(blockBefore));
	            blocks.push(utils.convertToBlock(blockAfter));
	        }
	
	
	    }
	
	    return blocks
	}
	
	// Grid is 36 by 24
	// can be initiated by [x][y] - each block has a boolean to represent whether something is there
	function _initiateGrid(pathLines) {
	    var grid = [],
	        blocks = _createPathBlocks(pathLines),
	        xGridAmount = constants.CANVASWIDTH / constants.GRIDSIZE,
	        yGridAmount = constants.CANVASHEIGHT / constants.GRIDSIZE;
	        
	    // Create the grid
	    for (var x = 0; x < xGridAmount; x++) {
	        grid[x] = [];
	        for (var y = 0; y < yGridAmount; y++) {
	            grid[x][y] = {
	                empty: true
	            };
	        }
	    }
	    // Loop through the blocks (which are on the path) and
	    blocks.map(function(block, i) {
	        grid[block.x][block.y] = {
	            empty: false
	        };
	    });
	
	    return grid;
	};
	
	module.exports = GameEngine;


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var monsterData = __webpack_require__(11),
	    utils = __webpack_require__(6),
	    constants = __webpack_require__(7);
	
	var Monster = function(id) {
	    this.id = id;
	    this.currentHp = monsterData[id].maxHp;
	    this.maxHp = monsterData[id].maxHp;
	    this.baseMs = monsterData[id].baseMs; // Movement speed - "units" per second
	    this.type = monsterData[id].type;
	    this.bounty = monsterData[id].bounty;
	    this.projectiles = [];
	    this.distanceTravelled = 0;
	    this.position = {}; // Initial position is defined by the path
	    this.sideLength = constants.MONSTERLENGTH;
	};
	// Method the game object uses to move monsters
	Monster.prototype.runCycle = function(gamePath, dt) {
	    var status = {};
	    this.move(gamePath, dt);
	
	    this.projectiles.forEach(function(projectile, i, projectileArray) {
	        projectile.move(dt);
	        if (projectile.end) {
	            this.updateHp(-projectile.damage);
	            projectileArray.splice(i, 1);
	        }
	    }.bind(this));
	
	    this.checkDeath();
	
	    if (this.checkDeath()) {
	        status.alive = false;
	        status.giveGold = !this.position.end; // Does not give gold if the monster reached the end
	    } else {
	        status.alive = true;
	    }
	
	    return status;
	}
	
	Monster.prototype.draw = function() {
	    dynamicContext.beginPath();
	    dynamicContext.rect(this.position.x, this.position.y, constants.MONSTERLENGTH, constants.MONSTERLENGTH);
	    dynamicContext.stroke();
	    dynamicContext.fillStyle = "red";
	    dynamicContext.fillRect(this.position.x,
	                            this.position.y + constants.MONSTERLENGTH/3,
	                            constants.MONSTERLENGTH * this.currentHp/this.maxHp,
	                            constants.MONSTERLENGTH/3);
	    dynamicContext.closePath();
	
	}
	
	Monster.prototype.destroy = function() {
	
	};
	
	Monster.prototype.checkDeath = function() {
	    return this.currentHp <= 0 || this.position.end;
	};
	
	Monster.prototype.move = function(pathLines, dt) {
	    this.distanceTravelled += this.baseMs * dt;
	    this.position = utils.convertDistanceToCoordinates(this.distanceTravelled, pathLines);
	};
	
	// Can take in a positive or negative number
	Monster.prototype.updateHp = function(hpChange) {
	    this.currentHp += hpChange;
	
	    if (this.currentHp > this.maxHp) {
	        this.currentHp = this.maxHp;
	    }
	};
	
	module.exports = Monster;


/***/ },
/* 11 */
/***/ function(module, exports) {

	module.exports = {
	    monster1: {
	        maxHp: 30,
	        baseMs: 50, // pixels per second
	        type: 1, // Change this type later
	        bounty: 3
	    }
	};


/***/ },
/* 12 */
/***/ function(module, exports) {

	module.exports = {
	    path: [
	        {x: 0, y: 500},
	        {x: 75, y: 500},
	        {x: 75, y: 100},
	        {x: 225, y: 100},
	        {x: 225, y: 500},
	        {x: 375, y: 500},
	        {x: 375, y: 100},
	        {x: 525, y: 100},
	        {x: 525, y: 500},
	        {x: 675, y: 500},
	        {x: 675, y: 100},
	        {x: 825, y: 100},
	        {x: 825, y: 500},
	        {x: 900, y: 500}
	    ]
	}


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZDg3NWIwYjUwMTgzNjBhNjkzYzciLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2VudHJ5LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9iYWNrZ3JvdW5kLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NsYXNzZXMvVG93ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2dhbWVEYXRhL3Rvd2VyZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2dhbWVEYXRhL2dhbWVDb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NsYXNzZXMvUHJvamVjdGlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NsYXNzZXMvR2FtZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY2xhc3Nlcy9Nb25zdGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9nYW1lRGF0YS9tb25zdGVyZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZ2FtZURhdGEvcGF0aGRhdGEuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdENBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQSxvQ0FBbUM7QUFDbkM7QUFDQSxvQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQzFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUEyQixXQUFXO0FBQ3RDO0FBQ0Esc0JBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBLDBCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXVDOztBQUV2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0wsd0ZBQXVGO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBNkIsZUFBZTtBQUM1QyxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0VBQThFO0FBQzlFO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCxvQ0FBbUMsV0FBVztBQUM5QztBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0EsVUFBUyxhQUFhO0FBQ3RCLFVBQVMsY0FBYztBQUN2QixVQUFTLGNBQWM7QUFDdkIsVUFBUyxlQUFlO0FBQ3hCLFVBQVMsZUFBZTtBQUN4QixVQUFTLGVBQWU7QUFDeEIsVUFBUyxlQUFlO0FBQ3hCLFVBQVMsZUFBZTtBQUN4QixVQUFTLGVBQWU7QUFDeEIsVUFBUyxlQUFlO0FBQ3hCLFVBQVMsZUFBZTtBQUN4QixVQUFTLGVBQWU7QUFDeEIsVUFBUyxlQUFlO0FBQ3hCLFVBQVM7QUFDVDtBQUNBIiwiZmlsZSI6Im1haW4ubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL3NyYy9qcy9cIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBkODc1YjBiNTAxODM2MGE2OTNjNyIsIi8vIENhbnZhc1xucmVxdWlyZShcIi4vYmFja2dyb3VuZC5qc1wiKTtcblxuLy8gVXNlciBpbnRlcmFjdGlvbiBlbGVtZW50c1xucmVxdWlyZShcIi4vaW50ZXJmYWNlLmpzXCIpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvZW50cnkuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gYmFja2dyb3VuZCBjb250YWlucyB0aGUgc3RhdGljIGNhbnZhcyBlbGVtZW50c1xudmFyIGJhY2tncm91bmQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN0YXRpY1wiKTtcbnZhciBiYWNrZ3JvdW5kQ29udGV4dCA9IGJhY2tncm91bmQuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4vLyBTZXR0aW5ncyBmb3IgdGhlIGJhY2tncm91bmQgLSBtb3ZlIG91dCB0byBhIHNlcGFyYXRlIGZpbGVcbnZhciBzZXR0aW5ncyA9IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzhDRDFFNlwiLFxuICAgIHBhdGhDb2xvcjogXCJncmF5XCJcbn1cblxuLy8gRHJhd2luZyB0aGUgYmFja2dyb3VuZFxuYmFja2dyb3VuZENvbnRleHQuZmlsbFN0eWxlID0gc2V0dGluZ3MuYmFja2dyb3VuZENvbG9yO1xuYmFja2dyb3VuZENvbnRleHQuZmlsbFJlY3QoMCwgMCwgYmFja2dyb3VuZC53aWR0aCwgYmFja2dyb3VuZC5oZWlnaHQpO1xuXG4vKiBNYWluIHBhdGggd2lsbCBnbyBmcm9tIFswLCA1MDBdLCBbNzUsIDUwMF0sIFs3NSwgMTAwXSwgWzIyNSwgMTAwXSwgWzIyNSwgNTAwXSwgWzM3NSwgNTAwXSwgWzM3NSwgMTAwXSwgWzUyNSwgMTAwXSwgWzUyNSwgNTAwXSwgWzY3NSwgNTAwXSwgWzY3NSwgMTAwXSwgWzgyNSwgMTAwXSwgWzgyNSwgNTAwXSwgWzkwMCwgNTAwXSAqL1xuXG4vLyBEcmF3aW5nIHRoZSBwYXRoIC0gd2lkdGggb2YgdGhlIHBhdGggaXMgNTBweFxuYmFja2dyb3VuZENvbnRleHQuZmlsbFN0eWxlID0gc2V0dGluZ3MucGF0aENvbG9yO1xuXG5iYWNrZ3JvdW5kQ29udGV4dC5iZWdpblBhdGgoKTtcblxuLy8gRm9yIHRoZSBib3R0b20gcGFydCBvZiB0aGUgcGF0aFxuYmFja2dyb3VuZENvbnRleHQubW92ZVRvKDAsIDUyNSk7XG5cbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygxMDAsIDUyNSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oMTAwLCAxMjUpOyAvLyBUb3BcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygyMDAsIDEyNSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oMjAwLCA1MjUpOyAvLyBCb3R0b21cbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg0MDAsIDUyNSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNDAwLCAxMjUpOyAvLyBUb3BcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg1MDAsIDEyNSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNTAwLCA1MjUpOyAvLyBCb3R0b21cbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg3MDAsIDUyNSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNzAwLCAxMjUpOyAvLyBUb3BcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg4MDAsIDEyNSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oODAwLCA1MjUpOyAvLyBCb3R0b21cblxuLy9NaWRkbGUgc2VjdGlvbiB0byB0aGUgc2lkZVxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDkwMCwgNTI1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg5MDAsIDQ3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oODUwLCA0NzUpO1xuXG4vLyBGb3IgdGhlIHRvcCBwYXJ0IG9mIHRoZSBwYXRoXG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oODUwLCA3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNjUwLCA3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNjUwLCA0NzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDU1MCwgNDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg1NTAsIDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygzNTAsIDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygzNTAsIDQ3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oMjUwLCA0NzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDI1MCwgNzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDUwLCA3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNTAsIDQ3NSk7XG5cbi8vIEVuZCBzZWN0aW9uXG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oMCwgNDc1KTtcblxuYmFja2dyb3VuZENvbnRleHQuZmlsbCgpO1xuLy8gYmFja2dyb3VuZENvbnRleHQubGluZVRvKCk7XG5cbi8vIGRyYXcgYSBncmlkIChmb3IgZGV2ZWxvcG1lbnQgcHVycG9zZXMpXG52YXIgd2lkdGggPSA5MDAsIGhlaWdodCA9IDYwMDtcbi8vIGRyYXcgdmVydGljYWwgbGluZXNcbmZvciAodmFyIGkgPSAwOyBpIDwgd2lkdGg7IGkgKz0gMjUpIHtcbiAgICBiYWNrZ3JvdW5kQ29udGV4dC5tb3ZlVG8oaSwgMCk7XG4gICAgYmFja2dyb3VuZENvbnRleHQubGluZVRvKGksIGhlaWdodCk7XG4gICAgYmFja2dyb3VuZENvbnRleHQuc3Ryb2tlKCk7XG59XG4vLyBkcmF3IGhvcml6b250YWwgbGluZXNcbmZvciAodmFyIGkgPSAwOyBpIDwgaGVpZ2h0OyBpICs9IDI1KSB7XG4gICAgYmFja2dyb3VuZENvbnRleHQubW92ZVRvKDAsIGkpO1xuICAgIGJhY2tncm91bmRDb250ZXh0LmxpbmVUbyh3aWR0aCwgaSk7XG4gICAgYmFja2dyb3VuZENvbnRleHQuc3Ryb2tlKCk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9iYWNrZ3JvdW5kLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIEluaXRpYXRlIGFsbCB0aGUgY29tcG9uZW50c1xudmFyIFRvd2VyID0gcmVxdWlyZShcIi4vY2xhc3Nlcy9Ub3dlci5qc1wiKSxcbiAgICBHYW1lRW5naW5lID0gcmVxdWlyZShcIi4vY2xhc3Nlcy9HYW1lLmpzXCIpO1xuXG4vLyBJbXBvcnQgYW5kIGRlY2xhcmUgdXRpbGl0eSBmdW5jdGlvbnNcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuXG52YXIgY29uc3RhbnRzID0gcmVxdWlyZShcIi4vZ2FtZURhdGEvZ2FtZUNvbnN0YW50cy5qc1wiKTtcblxuLy8gQ2FjaGUgcmV1c2VkIERPTSBlbGVtZW50c1xudmFyIGluZm9OYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbmZvLW5hbWVcIiksXG4gICAgaW5mb0ljb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImluZm8taWNvblwiKSxcbiAgICBpbmZvQm94MSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5mby1ib3gtMVwiKSxcbiAgICBpbmZvQm94MiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5mby1ib3gtMlwiKSxcbiAgICBpbmZvQm94MyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5mby1ib3gtM1wiKSxcbiAgICBpbmZvQm94NCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5mby1ib3gtNFwiKSxcbiAgICBsZXZlbEluZm8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxldmVsXCIpLFxuICAgIGdvbGRJbmZvID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJnb2xkXCIpLFxuICAgIGxpdmVzSW5mbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibGl2ZXNcIiksXG4gICAgdG93ZXJDYXJkcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJ0b3dlci1jYXJkXCIpLFxuICAgIHRvd2VyQ2FyZExpc3QgPSBbXTtcblxuLy8gQ29udmVydCBmcm9tIG5vZGVsaXN0IHRvIGFycmF5XG50b3dlckNhcmRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodG93ZXJDYXJkcyk7XG5cbi8qXG5DcmVhdGUgc3RhdGUgdmFyaWFibGVzIC0gVGhlc2UgYXJlIG1vZGlmaWVkIG9uIHVzZXIgaW50ZXJhY3Rpb24gZXZlbnRzXG5TdGF0ZSB2YXJpYWJsZXNcbmFjdGl2ZUNhbnZhc0VsZW1lbnQgLSBDaGFuZ2VkIG9uIGEgbW91c2UgY2xpY2sgZXZlbnQgb24gYSBtb25zdGVyLCB0b3dlciBvciBub3RoaW5nXG5hY3RpdmVUb3dlclNlbGVjdGVkIC0gVGhlIG5hbWUgb2YgdGhlIHRvd2VyIHRoYXQgaXMgYmVpbmcgcGxhY2VkIGJ5IHRoZSB1c2VyXG5hY3RpdmVNZXNzYWdlIC0gTWVzc2FnZSBkaXNwbGF5ZWQgaW4gdGhlIGNhbnZhcyAoY2FuIGJlIHVzZWQgZm9yIG5ldyBsZXZlbHMsIGludmFsaWQgdG93ZXIgcGxhY2VtZW50cywgZXRjKVxuY2FudmFzTW91c2VQb3NpdGlvbiAtXG4gICAgb25DYW52YXMgLSBib29sZWFuIHRvIHJlcHJlc2VudCB3aGV0aGVyIHRoZSBtb3VzZSBpcyBjdXJyZW50bHkgb24gdGhlIGNhbnZhc1xuICAgIHRvd2VyUG9zaXRpb24gLSBvYmplY3Qgd2l0aCBhIGdyaWQgdmFsdWUgYW5kIGNvb3JkaW5hdGUgdmFsdWUgYW5kIHNpZGVzXG4gICAgICAgIGdyaWQgLSB0aGUgdG9wIGxlZnQgYmxvY2sgb2YgdGhlIHRvd2VyIGJlaW5nIHBsYWNlZCAtIHRvd2VycyBhcmUgYSAyeDIgZ3JpZFxuICAgICAgICBjb29yZGluYXRlIC0gdGhlIHRvcCBsZWZ0IGNvcm5lciBjb29yZGluYXRlXG4gICAgICAgIHNpZGVzIC0gNTAgcHhcbiAgICBtb3VzZVBvc2l0aW9uIC0gdGhlIGN1cnJlbnQgbW91c2UgY29vcmRpbmF0ZXNcbiovXG5cbnZhciBhY3RpdmVDYW52YXNFbGVtZW50ID0ge3R5cGU6IG51bGx9LFxuICAgIGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPSBudWxsLFxuICAgIGFjdGl2ZU1lc3NhZ2UgPSB7bWVzc2FnZTogbnVsbH0sXG4gICAgY2FudmFzTW91c2VQb3NpdGlvbiA9IHtcbiAgICAgICAgb25DYW52YXM6IGZhbHNlLFxuICAgICAgICB0b3dlclBvc2l0aW9uOiB7fSxcbiAgICAgICAgbW91c2VQb3NpdGlvbjoge31cbiAgICB9O1xuXG4vLyAgY3JlYXRlcyBnbG9iYWwgdmFyaWFibGVzXG5nYW1lID0gbmV3IEdhbWVFbmdpbmU7XG5keW5hbWljQ2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2R5bmFtaWMnKTtcbmR5bmFtaWNDb250ZXh0ID0gZHluYW1pY0NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4vLyBEZWNsYXJlIHRoZSBnYW1lIGxvb3BcbnZhciBsYXN0VGltZSxcbiAgICBnYW1lTG9vcCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBub3cgPSBEYXRlLm5vdygpLFxuICAgICAgICBkdCA9IChub3cgLSBsYXN0VGltZSkgLyAxMDAwLjA7IC8vIENvbnZlcnQgdG8gc2Vjb25kc1xuXG4gICAgZ2FtZS5ydW5DeWNsZShkdCk7XG5cbiAgICBsYXN0VGltZSA9IG5vdztcbiAgICAvLyBSZW5kZXJzIG1ldGhvZHMgYmFzZWQgb24gc3RhdGUgdmFyaWFibGVzXG4gICAgZ2FtZS5yZW5kZXIoKTtcbiAgICB1cGRhdGVHYW1lSW5mb3JtYXRpb24oKTtcbiAgICByZW5kZXJUb3dlclBsYWNlbWVudCgpO1xuICAgIHJlbmRlck1lc3NhZ2UoZHQpO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShnYW1lTG9vcCk7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PSBSZW5kZXIgZnVuY3Rpb25zID09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8vIFJlbmRlciBmdW5jdGlvbnMgcnVuIGV2ZXJ5IGdhbWUgY3ljbGUgKG9uIHRoZSBnYW1lTG9vcCBmdW5jdGlvbiBjYWxsKVxuLy8gUmVuZGVycyBiYXNlZCBvbiB0aGUgc3RhdGUgdmFyaWFibGVzXG5cbmZ1bmN0aW9uIHVwZGF0ZUdhbWVJbmZvcm1hdGlvbigpIHtcbiAgICBsaXZlc0luZm8uaW5uZXJIVE1MID0gZ2FtZS51c2VyTGl2ZXM7XG4gICAgZ29sZEluZm8uaW5uZXJIVE1MID0gZ2FtZS51c2VyR29sZDtcbiAgICBsZXZlbEluZm8uaW5uZXJIVE1MID0gZ2FtZS5sZXZlbDtcblxuICAgIGlmIChhY3RpdmVDYW52YXNFbGVtZW50LnR5cGUgPT09IFwibW9uc3RlclwiKSB7XG4gICAgICAgIHJlbmRlck1vbnN0ZXJJbmZvcm1hdGlvbihhY3RpdmVDYW52YXNFbGVtZW50LmluZGV4KTtcbiAgICB9IGVsc2UgaWYgKGFjdGl2ZUNhbnZhc0VsZW1lbnQudHlwZSA9PT0gXCJ0b3dlclwiKSB7XG4gICAgICAgIHJlbmRlclRvd2VySW5mb3JtYXRpb24oYWN0aXZlQ2FudmFzRWxlbWVudC5pbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyRGVmYXVsdEluZm9ybWF0aW9uKCk7XG4gICAgfVxufVxuXG4vLyBJRCByZWZlcnMgdG8gdGhlIHR5cGUgb2YgbW9uc3RlciBhbmQgaW5kZXggaXMgdGhlIGluZGV4IG9mIHRoZSBhY3RpdmUgbW9uc3RlciBpbiB0aGUgYWN0aXZlIG1vbnN0ZXIncyBhcnJheVxuZnVuY3Rpb24gcmVuZGVyTW9uc3RlckluZm9ybWF0aW9uKGluZGV4KSB7XG4gICAgdmFyIGN1cnJlbnRIcCA9IGdhbWUuYWN0aXZlTW9uc3RlcnNbaW5kZXhdLmN1cnJlbnRIcCxcbiAgICAgICAgbWF4SHAgPSBnYW1lLmFjdGl2ZU1vbnN0ZXJzW2luZGV4XS5tYXhIcCxcbiAgICAgICAgdHlwZSA9IGdhbWUuYWN0aXZlTW9uc3RlcnNbaW5kZXhdLnR5cGUsXG4gICAgICAgIGlkID0gZ2FtZS5hY3RpdmVNb25zdGVyc1tpbmRleF0uaWQ7XG5cbiAgICBpbmZvTmFtZS5pbm5lckhUTUwgPSBpZDtcbiAgICAvLyBDaGFuZ2UgaWNvbiB0byBhY3RpdmUgbW9uc3RlciAtIHVzZSBhIHNwcml0ZVxuICAgIGluZm9Cb3gxLmlubmVySFRNTCA9IFwiSFA6IFwiICsgY3VycmVudEhwICsgXCIgLyBcIiArIG1heEhwO1xuICAgIGluZm9Cb3gyLmlubmVySFRNTCA9IFwiVHlwZTogXCIgKyB0eXBlO1xuICAgIGluZm9Cb3gzLmlubmVySFRNTCA9IFwiU3RyZW5ndGhzOiBBbGwgc29ydHMgbWF0ZVwiIDtcbiAgICBpbmZvQm94NC5pbm5lckhUTUwgPSBcIldlYWtuZXNzZXM6IER1Y2tzXCIgO1xufVxuXG4vLyBJRCByZWZlcnMgdG8gdGhlIHR5cGUgb2YgdG93ZXIgYW5kIGluZGV4IGlzIHRoZSBpbmRleCBvZiB0aGUgYWN0aXZlIHRvd2VyIGluIHRoZSBhY3RpdmUgdG93ZXIncyBhcnJheVxuZnVuY3Rpb24gcmVuZGVyVG93ZXJJbmZvcm1hdGlvbihpbmRleCkge1xuICAgIHZhciBpZCA9IGdhbWUudG93ZXJzW2luZGV4XS5pZDtcblxuICAgIGluZm9OYW1lLmlubmVySFRNTCA9IGlkO1xuICAgIC8vIENoYW5nZSBpY29uIHRvIGFjdGl2ZSBtb25zdGVyIC0gdXNlIGEgc3ByaXRlXG4gICAgaW5mb0JveDEuaW5uZXJIVE1MID0gXCJEYW1hZ2U6IDxicj4gUmFuZ2U6IDxicj4gRWZmZWN0OiBcIjtcbiAgICBpbmZvQm94Mi5pbm5lckhUTUwgPSBcIkF0dGFjayBTcGVlZDogPGJyPiBUeXBlOiBcIiA7XG4gICAgaW5mb0JveDMuaW5uZXJIVE1MID0gXCI8YSBjbGFzcz0nd2F2ZXMtZWZmZWN0IHdhdmVzLWxpZ2h0IGJ0biByZWQnPlVwZ3JhZGU8L2E+XCIgO1xuICAgIGluZm9Cb3g0LmlubmVySFRNTCA9IFwiPGEgY2xhc3M9J3dhdmVzLWVmZmVjdCB3YXZlcy1saWdodCBidG4gcmVkJz5TZWxsPC9hPlwiIDtcbiAgICAvLyBDaGFuZ2UgaWNvbiB0byB0b3dlciBtb25zdGVyIC0gdXNlIGEgc3ByaXRlXG5cbn1cblxuZnVuY3Rpb24gcmVuZGVyRGVmYXVsdEluZm9ybWF0aW9uKCkge1xuICAgIGluZm9OYW1lLmlubmVySFRNTCA9IFwiQXdlc29tZSBURFwiO1xuICAgIC8vIENoYW5nZSBpY29uIHRvIGRlZmF1bHQgaW1hZ2UgLSB1c2UgYSBzcHJpdGVcbiAgICBpbmZvQm94MS5pbm5lckhUTUwgPSBcIlRoaXMgaXMgc29tZSB0ZXh0XCI7XG4gICAgaW5mb0JveDIuaW5uZXJIVE1MID0gXCJUaGlzIGlzIGRpZmZlcmVudCB0ZXh0XCI7XG4gICAgaW5mb0JveDMuaW5uZXJIVE1MID0gXCJUaGlzIGlzID8/PyB0ZXh0XCIgO1xuICAgIGluZm9Cb3g0LmlubmVySFRNTCA9IFwiVGhpcyAxMjMxMjQxMjM1XCIgO1xufVxuXG5mdW5jdGlvbiByZW5kZXJNZXNzYWdlKGR0KSB7XG4gICAgaWYgKGFjdGl2ZU1lc3NhZ2UubWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZHluYW1pY0NvbnRleHQuZ2xvYmFsQWxwaGEgPSBhY3RpdmVNZXNzYWdlLnRpbWVyID4gMCA/IGFjdGl2ZU1lc3NhZ2UudGltZXIgOiAwOyAvLyBTZXRzIHRyYW5zcGFyZW5jeSB0byAwIGlmIGEgbmVnYXRpdmUgbnVtYmVyXG4gICAgICAgIGR5bmFtaWNDb250ZXh0LmZvbnQgPSBjb25zdGFudHMuTUVTU0FHRUZPTlQ7XG4gICAgICAgIGR5bmFtaWNDb250ZXh0LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIGR5bmFtaWNDb250ZXh0LmZpbGxTdHlsZSA9IGNvbnN0YW50cy5NRVNTQUdFQ09MT1I7XG4gICAgICAgIGR5bmFtaWNDb250ZXh0LmZpbGxUZXh0KGFjdGl2ZU1lc3NhZ2UubWVzc2FnZSwgY29uc3RhbnRzLkNBTlZBU1dJRFRIIC8gMiwgNTApO1xuICAgICAgICBkeW5hbWljQ29udGV4dC5nbG9iYWxBbHBoYSA9IDE7XG5cbiAgICAgICAgaWYgKGFjdGl2ZU1lc3NhZ2UudGltZXIgPD0gMCkge1xuICAgICAgICAgICAgYWN0aXZlTWVzc2FnZSA9IHttZXNzYWdlOiBudWxsfTsgLy8gUmVzZXQgbWVzc2FnZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWN0aXZlTWVzc2FnZS50aW1lciAtPSBkdDtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyVG93ZXJQbGFjZW1lbnQoKSB7XG4gICAgaWYgKGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPT09IG51bGwgfHxcbiAgICAgICAgIWNhbnZhc01vdXNlUG9zaXRpb24ub25DYW52YXMpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgfTtcblxuICAgIHZhciBjb29yZGluYXRlcyA9IGNhbnZhc01vdXNlUG9zaXRpb24udG93ZXJQb3NpdGlvbi5jb29yZGluYXRlcztcbiAgICBkeW5hbWljQ29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBkeW5hbWljQ29udGV4dC5nbG9iYWxBbHBoYSA9IDAuNTtcblxuICAgIGlmIChnYW1lLnZhbGlkYXRlVG93ZXJQbGFjZW1lbnQoY2FudmFzTW91c2VQb3NpdGlvbi50b3dlclBvc2l0aW9uLmdyaWQpKSB7IC8vIGNoZWNrIGZvciB2YWxpZCB0b3dlciBwbGFjZW1lbnRcbiAgICAgICAgZHluYW1pY0NvbnRleHQuZmlsbFN0eWxlID0gXCJncmVlblwiO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGR5bmFtaWNDb250ZXh0LmZpbGxTdHlsZSA9IFwicmVkXCI7XG4gICAgICAgIC8vIGRvIHNvbWUgc29ydCBvZiBsb2dpYyB0byBoaWdobGlnaHQgdGhlIHRpbGVzIHRoYXQgdGhlIHRvd2VyIHdvdWxkIGJlIHBsYWNlZCBvbiBhbmQgc2hvdyB0aGUgdG93ZXIgb24gdGhvc2UgcG9zaXRpb25zXG4gICAgICAgIC8vIHRoaXMgd291bGQgcnVuIHdoZW4gdG93ZXIgcGxhY2VtZW50IGlzIGludmFsaWRcbiAgICB9XG4gICAgZHluYW1pY0NvbnRleHQuZmlsbFJlY3QoY29vcmRpbmF0ZXMueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlcy55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50cy5UT1dFUkxFTkdUSCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdGFudHMuVE9XRVJMRU5HVEhcbiAgICAgKTtcblxuICAgIGR5bmFtaWNDb250ZXh0Lmdsb2JhbEFscGhhID0gMC43O1xuICAgIGR5bmFtaWNDb250ZXh0LmFyYyhjb29yZGluYXRlcy54ICsgY29uc3RhbnRzLlRPV0VSTEVOR1RIIC8gMixcbiAgICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXMueSArIGNvbnN0YW50cy5UT1dFUkxFTkdUSCAvIDIsXG4gICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50cy5UT1dFUkxFTkdUSCAqIDAuNixcbiAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgMiAqIE1hdGguUEksXG4gICAgICAgICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICk7XG4gICAgZHluYW1pY0NvbnRleHQuZmlsbFN0eWxlID0gJ2dyYXknO1xuICAgIGR5bmFtaWNDb250ZXh0LmZpbGwoKTtcblxuICAgIGR5bmFtaWNDb250ZXh0Lmdsb2JhbEFscGhhID0gMTtcbiAgICBkeW5hbWljQ29udGV4dC5jbG9zZVBhdGgoKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PSBVSSBFdmVudCBMaXN0ZW5lcnMgPT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdGFydC1idG5cIikuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgIC8vIEhpZGVzIHRoZSBtb2RhbCBsaWdodGJveFxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJtb2RhbC1jb250ZW50XCIpWzBdLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwibW9kYWwtYmFja2dyb3VuZFwiKVswXS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cbiAgICAvLyBTZXQgZ2FtZSB0byBzdGFydFxuICAgIGdhbWUuZ2FtZVN0YXJ0KCk7XG4gICAgLy8gU2V0cyB1cCBnYW1lIGxvb3AgYW5kIHJlbmRlciBsb29wXG4gICAgbGFzdFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShnYW1lTG9vcCk7XG59KTtcblxuLy8gT24gY2xpY2tpbmcgdGhlIGluZm9ybWF0aW9uIGJ1dHRvbiwgc2hvdyB0aGUgaW5mb3JtYXRpb24gcGFuZWxcbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5mb3JtYXRpb24tYnRuXCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAvLyBUT0RPIC0gYWRkIGluZm9ybWF0aW9uIG1vZGFsIGluZm9ybWF0aW9uIHRoaW5neVxuICAgIGNvbnNvbGUubG9nKFwic2hvdyBpbmZvcm1hdGlvbiBjb250YWluZXIgaGVyZVwiKTtcbn0pO1xuXG4vKlxuVGhlc2UgZXZlbnQgbGlzdGVuZXJzIGNvbnRyb2wgdGhlIGFwcGxpY2F0aW9uIGJ5IGludGVyYWN0aW5nIHdpdGggdGhlIGdhbWVcbm9iamVjdCBhbmQgYnkgY2hhbmdpbmcgdGhlIHN0YXRlIHZhcmlhYmxlcyAod2hpY2ggdGhlIHJlbmRlciBmdW5jdGlvbnMgdXNlXG50byByZWFkKVxuKi9cbnRvd2VyQ2FyZHMubWFwKGZ1bmN0aW9uKHRvd2VyQ2FyZCwgaSkge1xuICAgIHRvd2VyQ2FyZExpc3QucHVzaCh0b3dlckNhcmQuZ2V0QXR0cmlidXRlKFwiZGF0YS10b3dlclwiKSk7XG4gICAgdG93ZXJDYXJkLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0b3dlckNhcmRDbGljayk7XG59KTtcblxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkeW5hbWljXCIpLm9ubW91c2Vtb3ZlID0gb25DYW52YXNNb3VzZU1vdmVtZW50O1xuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkeW5hbWljXCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBjYW52YXNDbGljayk7XG5cbmRvY3VtZW50Lm9ua2V5ZG93biA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoZS5rZXlDb2RlID09PSAyNykge1xuICAgICAgICBjYW5jZWxUb3dlclBsYWNlbWVudCgpO1xuICAgIH1cbn1cblxuLy8gdXBkYXRlcyBhY3RpdmVDYW52YXNFbGVtZW50IHdoZW4gbW9uc3RlciBkZWF0aCAoaWYgdGhlIGFjdGl2ZSBlbGVtZW50IGlzIGEgbW9uc3RlcilcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb25zdGVyRGVhdGhcIiwgZnVuY3Rpb24oZSkge1xuICAgIGlmIChhY3RpdmVDYW52YXNFbGVtZW50LnR5cGUgPT09IFwibW9uc3RlclwiKSB7XG4gICAgICAgIGlmIChlLmRldGFpbC5pbmRleCA8IGFjdGl2ZUNhbnZhc0VsZW1lbnQuaW5kZXgpIHtcbiAgICAgICAgICAgIGFjdGl2ZUNhbnZhc0VsZW1lbnQuaW5kZXgtLTtcbiAgICAgICAgfSBlbHNlIGlmIChlLmRldGFpbC5pbmRleCA9PT0gYWN0aXZlQ2FudmFzRWxlbWVudC5pbmRleCkge1xuICAgICAgICAgICAgYWN0aXZlQ2FudmFzRWxlbWVudCA9IHt0eXBlOiBudWxsfSAvLyBSZXNldFxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qID09PT09PT09PT09PT09PT09PT0gVUkgRnVuY3Rpb25zID09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qIENsaWNrIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSB0b3dlciBjYXJkc1xuVXNlZCB0byBjb250cm9sIHdoYXQgdG93ZXIgaXMgYmVpbmcgYWN0aXZlbHkgcGxhY2VkIG9uIHRoZSBjYW52YXNcbjQgcG9zc2libGUgZmxvd3MgYmFzZWQgb24gdGhlIHN0YXRlIG9mIHRoZSBpbnRlcmZhY2VcbjEpIFRoZSB0b3dlciB0aGF0IHdhcyBjbGlja2VkIGlzIGN1cnJlbnRseSBkaXNhYmxlZDpcbiAgICAtPiBmdW5jdGlvbiByZXR1cm5zXG4yKSBObyB0b3dlcnMgYXJlIGFjdGl2ZWx5IGJlaW5nIHBsYWNlZFxuICAgIC0+IHRoZSBjbGlja2VkIHRvd2VyIGNhcmQgbm93IGJlY29tZXMgdGhlIGFjdGl2ZSB0b3dlciBiZWluZyBwbGFjZWRcbjMpIFRoZSBjbGlja2VkIHRvd2VyIGlzIHRoZSBzYW1lIGFzIHRoZSB0b3dlciBhY3RpdmVseSBiZWluZyBwbGFjZWRcbiAgICAtPiB0aGUgc3RhdGUgaXMgcmVzZXQgc28gdGhhdCBubyB0b3dlcnMgYXJlIGFjdGl2ZWx5IGJlaW5nIHBsYWNlZFxuNCkgVGhlIGNsaWNrZWQgdG93ZXIgaXMgZGlmZmVyZW50IGZyb20gdGhlIHRvd2VyIGFjdGl2ZWx5IGJlaW5nIHBsYWNlZFxuICAgIC0+IHRoZSBzdGF0ZSBpcyBjaGFuZ2VkIHRvIHRoZSBjbGlja2VkIHRvd2VyIGJlY29taW5nIHRoZSBhY3RpdmUgdG93ZXJcbiovXG5mdW5jdGlvbiB0b3dlckNhcmRDbGljaygpIHtcblxuICAgIHZhciB0b3dlck5hbWUgPSB0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtdG93ZXJcIiksXG4gICAgICAgIG9sZFRvd2VySW5kZXggPSB0b3dlckNhcmRMaXN0LmluZGV4T2YoYWN0aXZlVG93ZXJTZWxlY3RlZCksXG4gICAgICAgIG5ld1Rvd2VySW5kZXggPSB0b3dlckNhcmRMaXN0LmluZGV4T2YodG93ZXJOYW1lKTtcblxuICAgIGlmICgvZGlzYWJsZWQvaS50ZXN0KHRoaXMuY2xhc3NOYW1lKSkge1xuICAgICAgICByZXR1cm47XG5cbiAgICB9IGVsc2UgaWYgKGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPT09IG51bGwpIHtcbiAgICAgICAgYWN0aXZlVG93ZXJTZWxlY3RlZCA9IHRvd2VyTmFtZTtcbiAgICAgICAgdXRpbHMuYWRkQ2xhc3ModG93ZXJDYXJkc1tuZXdUb3dlckluZGV4XSwgXCJhY3RpdmVcIik7XG4gICAgICAgIGNhbnZhc01vdXNlUG9zaXRpb24ub25DYW52YXMgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPT09IHRvd2VyTmFtZSkge1xuICAgICAgICBjYW5jZWxUb3dlclBsYWNlbWVudCgpO1xuICAgICAgICBjYW52YXNNb3VzZVBvc2l0aW9uLm9uQ2FudmFzID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdXRpbHMucmVtb3ZlQ2xhc3ModG93ZXJDYXJkc1tvbGRUb3dlckluZGV4XSwgXCJhY3RpdmVcIik7XG4gICAgICAgIGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPSB0b3dlck5hbWU7XG4gICAgICAgIHV0aWxzLmFkZENsYXNzKHRvd2VyQ2FyZHNbbmV3VG93ZXJJbmRleF0sIFwiYWN0aXZlXCIpO1xuICAgICAgICBjYW52YXNNb3VzZVBvc2l0aW9uLm9uQ2FudmFzID0gZmFsc2U7XG5cbiAgICB9XG59XG5cbi8qXG5DYWxsZWQgZnJvbSB0b3dlckNhcmRDbGljayAod2hlbiBjbGlja2luZyB0aGUgYWN0aXZlIHRvd2VyIGNhcmQpIGFuZCBvbiBhbiBlc2NhcGUga2V5IHByZXNzXG5SZXNldHMgdGhlIGFjdGl2ZSB0b3dlciBwbGFjZW1lbnQgc3RhdGUgdG8gbnVsbFxuKi9cbmZ1bmN0aW9uIGNhbmNlbFRvd2VyUGxhY2VtZW50KCkge1xuICAgIHV0aWxzLnJlbW92ZUNsYXNzKHRvd2VyQ2FyZHNbdG93ZXJDYXJkTGlzdC5pbmRleE9mKGFjdGl2ZVRvd2VyU2VsZWN0ZWQpXSwgXCJhY3RpdmVcIik7XG4gICAgYWN0aXZlVG93ZXJTZWxlY3RlZCA9IG51bGw7XG59XG5cbi8qIE1vdXNlIG1vdmUgZXZlbnQgbGlzdGVuZXIgb24gdGhlIGNhbnZhc1xuSWYgdGhlIGFjdGl2ZSB0b3dlciBzZWxlY3RlZCBzdGF0ZSAoYSB0b3dlciBpcyBiZWluZyBwbGFjZWQgYnkgdGhlIHVzZXIpOlxuICAgIC0+IHVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIG1vdXNlIG9uIHRoZSBjYW52YXMgKHVzZWQgYnkgdGhlIHJlbmRlclRvd2VyUGxhY2VtZW50IGZ1bmN0aW9uKVxub3RoZXJ3aXNlOlxuICAgIC0+IGRvIG5vdGhpbmdcbiovXG5mdW5jdGlvbiBvbkNhbnZhc01vdXNlTW92ZW1lbnQoZSkge1xuICAgIGlmIChhY3RpdmVUb3dlclNlbGVjdGVkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVyblxuICAgIH07XG5cbiAgICB2YXIgY2FudmFzQ29udGFpbmVyID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgcG9zaXRpb24gPSB7fTtcblxuICAgIHBvc2l0aW9uLnggPSBlLmNsaWVudFggLSBjYW52YXNDb250YWluZXIubGVmdDtcbiAgICBwb3NpdGlvbi55ID0gZS5jbGllbnRZIC0gY2FudmFzQ29udGFpbmVyLnRvcDtcbiAgICBjYW52YXNNb3VzZVBvc2l0aW9uLm1vdXNlUG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICBjYW52YXNNb3VzZVBvc2l0aW9uLnRvd2VyUG9zaXRpb24gPSB1dGlscy5jb252ZXJ0UG9zaXRpb25Ub1Rvd2VyKHBvc2l0aW9uKTtcbiAgICBjYW52YXNNb3VzZVBvc2l0aW9uLm9uQ2FudmFzID0gdHJ1ZTtcbn07XG5cblxuLyogQ2xpY2sgZXZlbnQgbGlzdGVuZXIgb24gdGhlIGNhbnZhc1xuSGFuZGxlcyB0d28gcG9zc2libGUgY2FudmFzIGNsaWNrIHNjZW5hcmlvc1xuMSkgQSB0b3dlciBpcyBzZWxlY3RlZCBhbmQgaXMgYWN0aXZlbHkgYmVpbmcgcGxhY2VkXG4gICAgLT4gQ2xpY2tpbmcgd2lsbCB2YWxpZGF0ZSB0aGUgdG93ZXIgcGxhY2VtZW50IGFuZCBjaGVjayB0aGUgdXNlcidzIGdvbGRcbiAgICBpZiBib3RoIGFyZSB2YWxpZCwgd2lsbCB0b3dlciB3aWxsIGJlIHBsYWNlZCAoYnkgZ2FtZSBvYmplY3QpXG4gICAgb3RoZXJ3aXNlLCBhbiBlcnJvciBtZXNzYWdlIHdpbGwgc2hvdyB1cFxuMikgQSB0b3dlciBpcyBub3Qgc2VsZWN0ZWQgYW5kIGlzIG5vdCBiZWluZyBwbGFjZWRcbiAgICAtPiBXaWxsIGNoZWNrIHdoZXRoZXIgdGhlIGNsaWNrIHBvc2l0aW9uIG92ZXJsYXBzIHdpdGggdGhlIGJvdW5kaW5nXG4gICAgcmVjdGFuZ2xlIG9mIG1vbnN0ZXIgb3IgdG93ZXIgLSBpZiBzbywgaXQgd2lsbCByZXR1cm4gdGhlIGluZm9ybWF0aW9uXG4gICAgaW4gdGhlIGluZm9ybWF0aW9uIGNvbnRhaW5lclxuKi9cbmZ1bmN0aW9uIGNhbnZhc0NsaWNrKGUpIHtcbiAgICAvLyBHZXQgY2xpY2sgbG9jYXRpb24gcmVsYXRpdmUgdG8gdGhlIGNhbnZhcyBlbGVtZW50XG4gICAgdmFyIGNhbnZhc0NvbnRhaW5lciA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIHBvc2l0aW9uID0ge30sXG4gICAgICAgIHRvd2VyR3JpZFBvc2l0aW9uID0gY2FudmFzTW91c2VQb3NpdGlvbi50b3dlclBvc2l0aW9uLmdyaWQsXG4gICAgICAgIHRvd2VyQ29vcmRpbmF0ZXMgPSBjYW52YXNNb3VzZVBvc2l0aW9uLnRvd2VyUG9zaXRpb24uY29vcmRpbmF0ZXM7IC8vIFBhc3NlcyBpbiBncmlkIGJsb2NrcyAtIHRoaXMgaXMgdGhlIHRvcExlZnQgYmxvY2tcblxuICAgIHBvc2l0aW9uLnggPSBlLmNsaWVudFggLSBjYW52YXNDb250YWluZXIubGVmdDtcbiAgICBwb3NpdGlvbi55ID0gZS5jbGllbnRZIC0gY2FudmFzQ29udGFpbmVyLnRvcDtcblxuICAgIC8vIFJ1bnMgaWYgdGhlIHVzZXIgaXMgcGxhY2luZyBhIHRvd2VyXG4gICAgaWYgKGFjdGl2ZVRvd2VyU2VsZWN0ZWQgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHRvd2VyTmFtZSA9IGFjdGl2ZVRvd2VyU2VsZWN0ZWQsXG4gICAgICAgICAgICB0b3dlclBsYWNlZCA9IGdhbWUucGxhY2VUb3dlcih0b3dlck5hbWUsIHRvd2VyR3JpZFBvc2l0aW9uLCB0b3dlckNvb3JkaW5hdGVzKTtcblxuICAgICAgICAvLyBJZiB0aGUgdG93ZXIgd2FzIG5vdCBwbGFjZWQsIHNob3cgYW4gZXJyb3IgbWVzc2FnZVxuICAgICAgICBpZiAoIXRvd2VyUGxhY2VkLnBsYWNlZCkge1xuICAgICAgICAgICAgYWN0aXZlTWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiB0b3dlclBsYWNlZC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIHRpbWVyOiBjb25zdGFudHMuTUVTU0FHRURVUkFUSU9OIC8vIHNlY29uZHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHV0aWxzLnJlbW92ZUNsYXNzKHRvd2VyQ2FyZHNbdG93ZXJDYXJkTGlzdC5pbmRleE9mKGFjdGl2ZVRvd2VyU2VsZWN0ZWQpXSwgXCJhY3RpdmVcIik7XG4gICAgICAgIGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFVzZXIgaXMgbm90IHJ1bm5pbmcgYSB0b3dlciBwbGFjZW1lbnRcbiAgICAgICAgYWN0aXZlQ2FudmFzRWxlbWVudCA9IGdhbWUuY2hlY2tDbGlja0xvY2F0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgdXBkYXRlR2FtZUluZm9ybWF0aW9uKCk7XG4gICAgfVxuXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9pbnRlcmZhY2UuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHRvd2VyRGF0YSA9IHJlcXVpcmUoXCIuLi9nYW1lRGF0YS90b3dlcmRhdGEuanNcIiksXG4gICAgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMuanNcIiksXG4gICAgUHJvamVjdGlsZSA9IHJlcXVpcmUoXCIuL1Byb2plY3RpbGVzLmpzXCIpLFxuICAgIGNvbnN0YW50cyA9IHJlcXVpcmUoXCIuLi9nYW1lRGF0YS9nYW1lQ29uc3RhbnRzLmpzXCIpO1xuXG4vLyBQb3NpdGlvbiByZWZlcnMgdG8gdGhlIHVwcGVyIGxlZnQgY29ybmVyIG9mIHRoZSBlbGVtZW50c1xuLy8gVG93ZXIgd2lkdGggLSA1MCB4IDUwXG52YXIgVG93ZXIgPSBmdW5jdGlvbihwb3NpdGlvbiwgaWQpIHtcbiAgICBpZiAodG93ZXJEYXRhW2lkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdG93ZXIgbmFtZSwgY2hlY2sgaHRtbCBkYXRhYXR0cmlidXRlIG9yIHRvd2VyZGF0YVwiKVxuICAgIH1cbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5kYW1hZ2UgPSB0b3dlckRhdGFbaWRdLmRhbWFnZTtcbiAgICB0aGlzLmF0dGFja1NwZWVkID0gdG93ZXJEYXRhW2lkXS5hdHRhY2tTcGVlZDsgLy8gQXR0YWNrIHNwZWVkXG4gICAgdGhpcy5jb29sZG93biA9IDA7XG4gICAgdGhpcy5yYW5nZSA9IHRvd2VyRGF0YVtpZF0ucmFuZ2U7IC8vIFJhbmdlIG9mIHRoZSB0b3dlclxuICAgIHRoaXMudHlwZSA9IHRvd2VyRGF0YVtpZF0udHlwZTsgLy8gVHlwZSBvZiBkYW1hZ2VcbiAgICB0aGlzLmVmZmVjdCA9IHRvd2VyRGF0YVtpZF0uZWZmZWN0OyAvLyBTcGVjaWFsIGVmZmVjdCAoZS5nLiBzbG93LCBzcGxhc2gsIGV0YylcbiAgICB0aGlzLmdvbGRDb3N0ID0gdG93ZXJEYXRhW2lkXS5nb2xkQ29zdDtcbiAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247IC8vIG9iamVjdCB3aXRoIHggYW5kIHkgY29vcmRpbmF0ZXMgLSByZWZlcmVuY2VzIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHRvd2VyXG4gICAgdGhpcy5wb3NpdGlvbi5zaWRlTGVuZ3RoID0gY29uc3RhbnRzLlRPV0VSTEVOR1RIO1xufVxuLy8gTWV0aG9kIHRoZSBnYW1lIG9iamVjdCB1c2VzIHRvIHJ1biB0b3dlcnNcblRvd2VyLnByb3RvdHlwZS5ydW5DeWNsZSA9IGZ1bmN0aW9uKGFjdGl2ZU1vbnN0ZXJzLCBkdCkge1xuICAgIHZhciB0YXJnZXRNb25zdGVyID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0aXZlTW9uc3RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tJblJhbmdlKGFjdGl2ZU1vbnN0ZXJzW2ldLnBvc2l0aW9uKSkge1xuICAgICAgICAgICAgdGFyZ2V0TW9uc3RlciA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIHByb2plY3RpbGUgaWYgdGhlcmUgaXMgYSBtb25zdGVyIGluIHJhbmdlIGFuZCB0aGUgdG93ZXIgaGFzIGEgY29vbGRvd24gb2YgMFxuICAgIGlmICh0YXJnZXRNb25zdGVyICE9PSBudWxsICYmIHRoaXMuY29vbGRvd24gPCAwKSB7XG4gICAgICAgIGFjdGl2ZU1vbnN0ZXJzW3RhcmdldE1vbnN0ZXJdLnByb2plY3RpbGVzLnB1c2gobmV3IFByb2plY3RpbGUodGhpcy5pZCwgdGhpcy5wb3NpdGlvbikpO1xuICAgICAgICB0aGlzLmNvb2xkb3duID0gdGhpcy5hdHRhY2tTcGVlZDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb29sZG93biA+PSAwKSB7XG4gICAgICAgIHRoaXMuY29vbGRvd24gLT0gZHQ7XG4gICAgfVxufVxuLy8gY2hhbmdlIHRoaXMgdG8gcmVmZXJlbmNlIGEgbGlzdCBvciBzb21ldGhpbmcgd2hlcmUgYSBuYW1lIGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSB0aGUgcHJvcGVydGllc1xuLy8gVGFrZXMgaW4gYSBtb25zdGVyJ3MgcG9zaXRpb24gYW5kIGNoZWNrcyB3aGV0aGVyIHRoYXQgaXMgaW4gcmFuZ2UgYmFzZWQgb24gdGhlIHJhbmdlIC0gcmV0dXJucyB0cnVlIG9yIGZhbHNlIGlmIGluIHJhbmdlIHdoaWNoIGNhbiBiZSB1c2VkIHRvXG5Ub3dlci5wcm90b3R5cGUuY2hlY2tJblJhbmdlID0gZnVuY3Rpb24obW9uc3RlclBvc2l0aW9uKSB7XG4gICAgLy8gdXNpbmcgc3FydCgoeDIteDEpXjIgLSAoeTIteTEpXjIpXG4gICAgdmFyIG1vbnN0ZXJEaXN0YW5jZSA9IHV0aWxzLmdldFBvc2l0aW9uRGlmZmVyZW5jZShtb25zdGVyUG9zaXRpb24sIHRoaXMucG9zaXRpb24pO1xuXG4gICBpZiAobW9uc3RlckRpc3RhbmNlIDw9IHRoaXMucmFuZ2UpIHtcbiAgICAgICByZXR1cm4gdHJ1ZTtcbiAgIH0gZWxzZSB7XG4gICAgICAgcmV0dXJuIGZhbHNlO1xuICAgfVxufVxuXG5Ub3dlci5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKCkge1xuICAgIGR5bmFtaWNDb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGR5bmFtaWNDb250ZXh0LmZpbGxTdHlsZSA9IFwiZ3JlZW5cIjtcbiAgICBkeW5hbWljQ29udGV4dC5maWxsUmVjdCh0aGlzLnBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50cy5UT1dFUkxFTkdUSCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdGFudHMuVE9XRVJMRU5HVEgpO1xuICAgIGR5bmFtaWNDb250ZXh0LmNsb3NlUGF0aCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRvd2VyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvY2xhc3Nlcy9Ub3dlci5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBiYXNpYzoge1xuICAgICAgICBwcm9qZWN0aWxlOiB7XG4gICAgICAgICAgICBkYW1hZ2U6IDUsXG4gICAgICAgICAgICB0cmF2ZWxUaW1lOjAuNSwgLy8gdGltZSBpbiBzZWNvbmRzIGJlZm9yZSBpbXBhY3RcbiAgICAgICAgICAgIHNwcml0ZTogXCJhYmNcIiAvLyBjaGFuZ2UgdGhpcyB0byBoYXZlIGFuaW1hdGlvbnNcbiAgICAgICAgfSxcbiAgICAgICAgYXR0YWNrU3BlZWQ6IDEsIC8vIDEgc2Vjb25kIHBlciBhdHRhY2tcbiAgICAgICAgcmFuZ2U6IDMwMCxcbiAgICAgICAgZ29sZENvc3Q6IDEwLFxuICAgICAgICB0eXBlOiBcImJhc2ljXCIsXG4gICAgICAgIGVmZmVjdDogXCJub25lXCJcbiAgICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvZ2FtZURhdGEvdG93ZXJkYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBjb25zdGFudHMgPSByZXF1aXJlKFwiLi9nYW1lRGF0YS9nYW1lQ29uc3RhbnRzLmpzXCIpO1xuXG4vKiA9PT09PT09PT09PT09PT09PT0gUHVibGljIGZ1bmN0aW9ucyA9PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5mdW5jdGlvbiBhZGRDbGFzcyhlbGVtZW50LCBjc3NDbGFzcykge1xuICAgIGlmIChlbGVtZW50LmNsYXNzTmFtZSA9PT0gXCJcIikge1xuICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGNzc0NsYXNzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lICs9IFwiIFwiICsgY3NzQ2xhc3M7XG4gICAgfVxufVxuXG4vKlxuY2hlY2tJZkluU3F1YXJlIGNoZWNrcyB3aGV0aGVyIGEgcG9pbnQgaXMgaW4gYSBzcXVhcmUgKHdoaWNoIGlzIGEgbW9uc3RlciBvciBhIHRvd2VyKVxuXG5UYWtlcyBpbiB0aHJlZSBhcmd1bWVudHNcbnBvaW50IC0gYSBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvb3JkaW5hdGVzXG50b3BMZWZ0UG9pbnQgLSBhbiBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHNxdWFyZVxuc2lkZUxlbmd0aCAtIHRoZSBsZW5ndGggb2YgdGhlIHNxdWFyZVxuXG5SZXR1cm5zIGEgYm9vbGVhbiAtIHRydWUgaWYgdGhlIGNsaWNrIG92ZXJsYXBzIHdpdGggYW4gZWxlbWVudCBhbmQgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgaWYgaXQgZG9lcyBub3RcbiovXG5mdW5jdGlvbiBjaGVja0lmSW5TcXVhcmUocG9pbnQsIHRvcExlZnRQb2ludCwgc2lkZUxlbmd0aCkge1xuICAgIGlmIChwb2ludC54ID49IHRvcExlZnRQb2ludC54XG4gICAgJiYgcG9pbnQueCA8PSB0b3BMZWZ0UG9pbnQueCArIHNpZGVMZW5ndGhcbiAgICAmJiBwb2ludC55ID49IHRvcExlZnRQb2ludC55XG4gICAgJiYgcG9pbnQueSA8PSB0b3BMZWZ0UG9pbnQueSArIHNpZGVMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuLypcblRha2VzIGluIGEgZGlzdGFuY2UgKGludCkgYW5kIHBhdGhMaW5lcyhhcnJheSBvZiBwYXRoIG9iamVjdHMpIGFuZCBjb252ZXJ0cyBpdCB0byBjb29yZGluYXRlcyBmb3IgYSBtb25zdGVyXG5SZXR1cm5zIGEgY29vcmRpbmF0ZSBvYmplY3RcbiovXG5mdW5jdGlvbiBjb252ZXJ0RGlzdGFuY2VUb0Nvb3JkaW5hdGVzKGRpc3RhbmNlLCBwYXRoTGluZXMpIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMsXG4gICAgICAgIGVuZCA9IGZhbHNlOyAvLyBCb29sZWFuIHRvIHJlcHJlc2VudCB3aGV0aGVyIHRoZSBtb25zdGVyIGlzIGF0IHRoZSBlbmRcblxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoTGluZXMubGVuZ3RoOyBpICsrKSB7XG4gICAgICAgIGlmIChkaXN0YW5jZSAtIHBhdGhMaW5lc1tpXS5kaXN0YW5jZSA8PSAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpc3RhbmNlIC09IHBhdGhMaW5lc1tpXS5kaXN0YW5jZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpID09PSBwYXRoTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIGktLTsgLy8gU2V0IHRoZSBjb3VudGVyIHZhbHVlIHRvIGJlIHRoZSBsYXN0IHZhbHVlIGluIHRoZSBwYXRobGluZXMgYXJyYXlcbiAgICAgICAgZGlzdGFuY2UgPSAgcGF0aExpbmVzW2ldLmRpc3RhbmNlO1xuICAgICAgICBlbmQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIG5ldyBvYmplY3QgdG8gcmV0dXJuIChpbnN0ZWFkIG9mIG1vZGlmaXlpbmcgc3RhcnRQb2ludCBvYmplY3QpXG4gICAgY29vcmRpbmF0ZXMgPSBPYmplY3QuY3JlYXRlKHBhdGhMaW5lc1tpXS5zdGFydFBvaW50KTtcbiAgICBjb29yZGluYXRlcy5lbmQgPSBlbmQ7XG5cbiAgICAvLyBDYXNlIGZvciB3aGVuIG1vbnN0ZXIgaXMgYXQgdGhlIGVuZCBvZiB0aGUgdGhpbmd5IC0gdGhlcmUgaXMgYSBiZXR0ZXIgd2F5IHRvIHdyaXRlIHRoaXMgYnV0IG5vdCByaWdodCBub3dcbiAgICBpZiAoIWVuZCkge1xuICAgICAgICBzd2l0Y2ggKHBhdGhMaW5lc1tpXS5kaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIDE1IGlzIGEgaGFsZiBvZiB0aGUgbW9uc3RlciB3aWR0aFxuICAgICAgICAgICAgLy8gdmFsdWVzIHVzZWQgdG8gb2Zmc2V0IHRoZSBwb3NpdGlvbmluZyBiYXNlZCBvbiB0aGUgbW9uc3RlciBkaXJlY2l0b24gbW92ZW1lbnRcbiAgICAgICAgICAgIGNhc2UgXCJ1cFwiOlxuICAgICAgICAgICAgY29vcmRpbmF0ZXMueCAtPSBjb25zdGFudHMuTU9OU1RFUkxFTkdUSC8yO1xuICAgICAgICAgICAgY29vcmRpbmF0ZXMueSAtPSBkaXN0YW5jZSArIGNvbnN0YW50cy5NT05TVEVSTEVOR1RILzI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkb3duXCI6XG4gICAgICAgICAgICBjb29yZGluYXRlcy54IC09IGNvbnN0YW50cy5NT05TVEVSTEVOR1RILzI7XG4gICAgICAgICAgICBjb29yZGluYXRlcy55ICs9IGRpc3RhbmNlIC0gY29uc3RhbnRzLk1PTlNURVJMRU5HVEgvMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzLnggLT0gZGlzdGFuY2UgKyBjb25zdGFudHMuTU9OU1RFUkxFTkdUSC8yO1xuICAgICAgICAgICAgY29vcmRpbmF0ZXMueSAtPSBjb25zdGFudHMuTU9OU1RFUkxFTkdUSC8yO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzLnggKz0gZGlzdGFuY2UgLSBjb25zdGFudHMuTU9OU1RFUkxFTkdUSC8yO1xuICAgICAgICAgICAgY29vcmRpbmF0ZXMueSAtPSBjb25zdGFudHMuTU9OU1RFUkxFTkdUSC8yO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkaXJlY3Rpb24gcHJvdmlkZWQgaW4gcGF0aExpbmVzXCIpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoIChwYXRoTGluZXNbaV0uZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIFwidXBcIjpcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlcy55IC09IHBhdGhMaW5lc1tpXS5kaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkb3duXCI6XG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXMueSArPSBwYXRoTGluZXNbaV0uZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzLnggLT0gcGF0aExpbmVzW2ldLmRpc3RhbmNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXMueCArPSBwYXRoTGluZXNbaV0uZGlzdGFuY2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGlyZWN0aW9uIHByb3ZpZGVkIGluIHBhdGhMaW5lc1wiKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzXG59XG5cbi8vIFRha2VzIGluIGEgcG9zaXRpb24gb2JqZWN0IHdpdGggY29vcmRpbmF0ZXN7eCwgeX1cbi8vIHJldHVybnMgYSBibG9jayBvYmplY3Qge3gsIHl9IHdpdGggYmxvY2sgbnVtYmVyc1xuLy8gSGFuZGxlcyBlZGdlIGNhc2VzIG9mIHRoZSBibG9jayBiZWluZyBkZWZpbmVkIGF0IHRoZSBlZGdlICgzNiBhbmQgMjQgd2hpY2ggYXJlIGludmFsaWQgaW4gdGhlIClcbmZ1bmN0aW9uIGNvbnZlcnRUb0Jsb2NrKHBvc2l0aW9uKSB7XG4gICAgdmFyIHhHcmlkQW1vdW50ID0gY29uc3RhbnRzLkNBTlZBU1dJRFRIIC8gY29uc3RhbnRzLkdSSURTSVpFLFxuICAgICAgICB5R3JpZEFtb3VudCA9IGNvbnN0YW50cy5DQU5WQVNIRUlHSFQgLyBjb25zdGFudHMuR1JJRFNJWkU7XG5cbiAgICBpZiAocG9zaXRpb24ueCA+ICh4R3JpZEFtb3VudCAqIChjb25zdGFudHMuVE9XRVJMRU5HVEgvMikpIHx8XG4gICAgICAgIHBvc2l0aW9uLnkgPiAoeUdyaWRBbW91bnQgKiAoY29uc3RhbnRzLlRPV0VSTEVOR1RILzIpKSkge1xuICAgICAgICBjb25zb2xlLmxvZyhwb3NpdGlvbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUG9zaXRpb24gb3V0IG9mIGdyaWQgcmFuZ2VcIik7XG4gICAgfVxuXG4gICAgdmFyIGJsb2NrID0ge1xuICAgICAgICB4OiBNYXRoLmZsb29yKHBvc2l0aW9uLnggLyAoY29uc3RhbnRzLlRPV0VSTEVOR1RILzIpKSxcbiAgICAgICAgeTogTWF0aC5mbG9vcihwb3NpdGlvbi55IC8gKGNvbnN0YW50cy5UT1dFUkxFTkdUSC8yKSlcbiAgICB9O1xuICAgIC8vIEFkanVzdHMgaWYgbW91c2UgaXMgYXQgZW5kIG9mIGNvbnRhaW5lclxuICAgIC8vIDM2IGJsb2NrcyB3aWR0aCBhbmQgMjQgYmxvY2tzIGhlaWdodFxuICAgIGlmIChibG9jay54ID49IHhHcmlkQW1vdW50IC0gMSkge1xuICAgICAgICBibG9jay54LS07XG4gICAgfVxuXG4gICAgaWYgKGJsb2NrLnkgPj0geUdyaWRBbW91bnQgLSAxKSB7XG4gICAgICAgIGJsb2NrLnktLTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmxvY2s7XG59XG5cbi8qXG5UYWtlcyBpbiBhIHBvc2l0aW9uIG9iamVjdCAoeCBhbmQgeSBjb29yZGluYXRlcylcblJldHVybnMgdGhlIHRvcCBsZWZ0IGJsb2NrIHBvc2l0aW9uIGFuZCB0b3BsZWZ0IGNvb3JkaW5hdGUgb2YgdGhlIHRvd2VyXG5HcmlkIGJsb2NrcyBhcmUgaW4gMjV4MjUgYmxvY2sgaW5jcmVtZW50c1xuKi9cbmZ1bmN0aW9uIGNvbnZlcnRQb3NpdGlvblRvVG93ZXIocG9zaXRpb24pIHtcbiAgICB2YXIgdG93ZXJQb3NpdGlvbiA9IHtcbiAgICAgICAgZ3JpZDoge30sXG4gICAgICAgIGNvb3JkaW5hdGVzOiB7fSxcbiAgICAgICAgc2lkZTogY29uc3RhbnRzLlRPV0VSTEVOR1RIXG4gICAgfSxcbiAgICAgICAgeEdyaWRBbW91bnQgPSBjb25zdGFudHMuQ0FOVkFTV0lEVEggLyBjb25zdGFudHMuR1JJRFNJWkUsXG4gICAgICAgIHlHcmlkQW1vdW50ID0gY29uc3RhbnRzLkNBTlZBU0hFSUdIVCAvIGNvbnN0YW50cy5HUklEU0laRTtcblxuXG4gICAgdG93ZXJQb3NpdGlvbi5ncmlkID0gY29udmVydFRvQmxvY2socG9zaXRpb24pO1xuXG4gICAgLy8gQ29udGFpbmVyIHdpZHRoIGFuZCBoZWlnaHQgOTAwIGFuZCA2MDAgcHggcmVzcGVjdGl2ZWx5XG4gICAgdG93ZXJQb3NpdGlvbi5jb29yZGluYXRlcy54ID0gKHRvd2VyUG9zaXRpb24uZ3JpZC54IC8geEdyaWRBbW91bnQpICogY29uc3RhbnRzLkNBTlZBU1dJRFRIO1xuICAgIHRvd2VyUG9zaXRpb24uY29vcmRpbmF0ZXMueSA9ICh0b3dlclBvc2l0aW9uLmdyaWQueSAvIHlHcmlkQW1vdW50KSAqIGNvbnN0YW50cy5DQU5WQVNIRUlHSFQ7XG4gICAgcmV0dXJuIHRvd2VyUG9zaXRpb247XG59XG4vKlxuZ2V0UGF0aFBvc2l0aW9uIGlucHV0czpcbmluaXRpYWxQb3NpdGlvbjogcG9zaXRpb24gb2JqZWN0IHt4LCB5fVxuZmluYWxQb3NpdGlvbjogcG9zaXRpb24gb2JqZWN0IHt4LCB5fVxuZnJhY3Rpb25UcmF2ZWxsZWQ6IGRlY2ltYWwgb2YgaG93IGZhciBhbG9uZyB0aGUgcGF0aFxuXG5PdXRwdXQ6IHBvc2l0aW9uIG9iamVjdCB7eCwgeX1cbiovXG5mdW5jdGlvbiBnZXRQYXRoUG9zaXRpb24ocG9zMSwgcG9zMiwgZnJhY3Rpb25UcmF2ZWxsZWQpIHtcbiAgICB2YXIgZmluYWxQb3NpdGlvbiA9IHt9LFxuICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIocG9zMi55IC0gcG9zMS55LCBwb3MyLnggLSBwb3MxLngpLCAvLyB0aGUgbGluZSBhbmdsZSAoaW4gcmFkaWFucykgZnJvbSBwb3MxIHRvIHBvczIgd2l0aCByZXNwZWN0IHRvIHRoZSBvcmlnaW5cbiAgICAgICAgZGlzdGFuY2VGcm9tUG9zMSA9IGdldFBvc2l0aW9uRGlmZmVyZW5jZShwb3MxLCBwb3MyKSAqIGZyYWN0aW9uVHJhdmVsbGVkO1xuXG4gICAgZmluYWxQb3NpdGlvbi54ID0gcG9zMS54ICsgZGlzdGFuY2VGcm9tUG9zMSAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICBmaW5hbFBvc2l0aW9uLnkgPSBwb3MxLnkgKyBkaXN0YW5jZUZyb21Qb3MxICogTWF0aC5zaW4oYW5nbGUpO1xuXG4gICAgcmV0dXJuIGZpbmFsUG9zaXRpb247XG59XG5cbmZ1bmN0aW9uIGdldFBvc2l0aW9uRGlmZmVyZW5jZShwb3NpdGlvbjEsIHBvc2l0aW9uMikge1xuICAgIHJldHVybiBNYXRoLnNxcnQoXG4gICAgICAgICAgICBNYXRoLnBvdyhwb3NpdGlvbjEueC1wb3NpdGlvbjIueCwgMikgK1xuICAgICAgICAgICAgTWF0aC5wb3cocG9zaXRpb24xLnktcG9zaXRpb24yLnksIDIpXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWxlbWVudCwgY3NzQ2xhc3MpIHtcbiAgICB2YXIgYXJyYXlPZkNsYXNzZXMgPSBlbGVtZW50LmNsYXNzTmFtZS5zcGxpdChcIiBcIik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBhcnJheU9mQ2xhc3Nlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgaWYgKGFycmF5T2ZDbGFzc2VzW2ldID09PSBjc3NDbGFzcykge1xuICAgICAgICAgICAgYXJyYXlPZkNsYXNzZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgaS0tOyBqLS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBhcnJheU9mQ2xhc3Nlcy5qb2luKFwiIFwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYWRkQ2xhc3M6IGFkZENsYXNzLFxuICAgIGNoZWNrSWZJblNxdWFyZTogY2hlY2tJZkluU3F1YXJlLFxuICAgIGNvbnZlcnRUb0Jsb2NrOiBjb252ZXJ0VG9CbG9jayxcbiAgICBjb252ZXJ0RGlzdGFuY2VUb0Nvb3JkaW5hdGVzOiBjb252ZXJ0RGlzdGFuY2VUb0Nvb3JkaW5hdGVzLFxuICAgIGNvbnZlcnRQb3NpdGlvblRvVG93ZXI6IGNvbnZlcnRQb3NpdGlvblRvVG93ZXIsXG4gICAgZ2V0UGF0aFBvc2l0aW9uOiBnZXRQYXRoUG9zaXRpb24sXG4gICAgZ2V0UG9zaXRpb25EaWZmZXJlbmNlOiBnZXRQb3NpdGlvbkRpZmZlcmVuY2UsXG4gICAgcmVtb3ZlQ2xhc3M6IHJlbW92ZUNsYXNzXG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy91dGlscy5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBDQU5WQVNXSURUSDogOTAwLCAvLyBwcm9iYWJseSBuZWVkIGEgd2F5IHRvIHNldCB0aGUgaHRtbCBjYW52YXMgc2l6ZSBmcm9tIGhlcmVcbiAgICBDQU5WQVNIRUlHSFQ6IDYwMCwgLy8gcHJvYmFibHkgbmVlZCBhIHdheSB0byBzZXQgdGhlIGh0bWwgY2FudmFzIHNpemUgZnJvbSBoZXJlXG4gICAgR1JJRFNJWkU6IDI1LFxuICAgIFRPV0VSTEVOR1RIOiA1MCxcbiAgICBNT05TVEVSTEVOR1RIOiAzMCxcbiAgICBQUk9KRUNUSUxFTEVOR1RIOiAxMCxcbiAgICBNT05TVEVSU1BFUkxFVkVMOiAxMCxcbiAgICBUSU1FQkVUV0VFTk1PTlNURVJDUkVBVEU6IDEsIC8vIHNlY29uZFxuICAgIFRJTUVCRVRXRUVOTEVWRUxTOiAyLCAvLyBzZWNvbmRzXG4gICAgRklOQUxMRVZFTDogNTAsXG4gICAgU1RBUlRJTkdHT0xEOiAxMCxcbiAgICBTVEFSVElOR0xJVkVTOiAzMCxcbiAgICBNRVNTQUdFRk9OVDogJzQwcHQgRHJvaWQgU2FucycsXG4gICAgTUVTU0FHRUNPTE9SOiAncmVkJyxcbiAgICBNRVNTQUdFRFVSQVRJT046IDAuOCxcbiAgICBNRVNTQUdFSU5WQUxJRFBMQUNFTUVOVDogXCJJbnZhbGlkIFRvd2VyIFBsYWNlbWVudFwiLFxuICAgIE1FU1NBR0VOT1RFTk9VR0hHT0xEOiBcIk5vdCBFbm91Z2ggR29sZFwiLFxuXG5cblxuXG5cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2dhbWVEYXRhL2dhbWVDb25zdGFudHMuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHRvd2VyRGF0YSA9IHJlcXVpcmUoXCIuLi9nYW1lRGF0YS90b3dlcmRhdGEuanNcIiksXG4gICAgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMuanNcIiksXG4gICAgY29uc3RhbnRzID0gcmVxdWlyZShcIi4uL2dhbWVEYXRhL2dhbWVDb25zdGFudHMuanNcIik7XG5cbi8vIFByb2plY3RpbGVzIGFyZSBhdHRhY2hlZCB0byBtb25zdGVyc1xudmFyIFByb2plY3RpbGUgPSBmdW5jdGlvbihpZCwgdG93ZXJQb3NpdGlvbikge1xuICAgIHRoaXMuZGFtYWdlID0gdG93ZXJEYXRhW2lkXS5wcm9qZWN0aWxlLmRhbWFnZTtcbiAgICB0aGlzLnRvdGFsVHJhdmVsVGltZSA9IHRvd2VyRGF0YVtpZF0ucHJvamVjdGlsZS50cmF2ZWxUaW1lO1xuICAgIHRoaXMuc3ByaXRlID0gdG93ZXJEYXRhW2lkXS5wcm9qZWN0aWxlLnNwcml0ZTtcbiAgICB0aGlzLmN1cnJlbnRUcmF2ZWxUaW1lID0gMDtcbiAgICB0aGlzLmVuZCA9IGZhbHNlO1xuICAgIHRoaXMuaW5pdGlhbFBvc2l0aW9uID0ge1xuICAgICAgICB4OiB0b3dlclBvc2l0aW9uLnggKyAoY29uc3RhbnRzLlRPV0VSTEVOR1RILzIpIC0gKGNvbnN0YW50cy5QUk9KRUNUSUxFTEVOR1RILzIpLFxuICAgICAgICB5OiB0b3dlclBvc2l0aW9uLnkgKyAoY29uc3RhbnRzLlRPV0VSTEVOR1RILzIpIC0gKGNvbnN0YW50cy5QUk9KRUNUSUxFTEVOR1RILzIpXG4gICAgfTtcbn1cblxuUHJvamVjdGlsZS5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKG1vbnN0ZXJQb3NpdGlvbikge1xuICAgIHZhciBmcmFjdGlvblRyYXZlbGxlZCA9IHRoaXMuY3VycmVudFRyYXZlbFRpbWUgLyB0aGlzLnRvdGFsVHJhdmVsVGltZSxcbiAgICAgICAgYWRqdXN0ZWRNb25zdGVyUG9zaXRpb24gPSB7XG4gICAgICAgICAgICB4OiBtb25zdGVyUG9zaXRpb24ueCArIChjb25zdGFudHMuTU9OU1RFUkxFTkdUSC8yKSAtIChjb25zdGFudHMuUFJPSkVDVElMRUxFTkdUSC8yKSxcbiAgICAgICAgICAgIHk6IG1vbnN0ZXJQb3NpdGlvbi55ICsgKGNvbnN0YW50cy5NT05TVEVSTEVOR1RILzIpIC0gKGNvbnN0YW50cy5QUk9KRUNUSUxFTEVOR1RILzIpXG4gICAgICAgIH0sXG4gICAgICAgIHBvc2l0aW9uID0gdXRpbHMuZ2V0UGF0aFBvc2l0aW9uKHRoaXMuaW5pdGlhbFBvc2l0aW9uLCBhZGp1c3RlZE1vbnN0ZXJQb3NpdGlvbiwgZnJhY3Rpb25UcmF2ZWxsZWQpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIGEgZnJhY3Rpb24gYmFzZWQgb24gY3VycmVudFRyYXZlbFRpbWUgLyB0cmF2ZWxUaW1lIHRvIGdldCB0aGUgcG9zaXRpb25cbiAgICBkeW5hbWljQ29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBkeW5hbWljQ29udGV4dC5maWxsU3R5bGUgPSBcIm9yYW5nZVwiO1xuICAgIGR5bmFtaWNDb250ZXh0LnJlY3QocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgY29uc3RhbnRzLlBST0pFQ1RJTEVMRU5HVEgsIGNvbnN0YW50cy5QUk9KRUNUSUxFTEVOR1RIKTtcbiAgICBkeW5hbWljQ29udGV4dC5maWxsKCk7XG4gICAgLy8gQ2hhbmdlIHRoaXMgdG8gdXNlIGEgc3ByaXRlXG4gICAgLy8gZHJhdyBiYXNlZCBvbiBwb3NpdGlvbiBoZXJlXG5cbiAgICBkeW5hbWljQ29udGV4dC5jbG9zZVBhdGgoKTtcbn1cblxuUHJvamVjdGlsZS5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uKGR0KSB7XG4gICAgdGhpcy5jdXJyZW50VHJhdmVsVGltZSArPSBkdDtcbiAgICBpZiAodGhpcy5jdXJyZW50VHJhdmVsVGltZSA+PSB0aGlzLnRvdGFsVHJhdmVsVGltZSkge1xuICAgICAgICB0aGlzLmVuZCA9IHRydWU7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb2plY3RpbGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9jbGFzc2VzL1Byb2plY3RpbGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vICByZXF1aXJlIE1vbnN0ZXIgdG8gZ2FpbiBhY2Nlc3NcbnZhciBNb25zdGVyID0gcmVxdWlyZShcIi4vTW9uc3Rlci5qc1wiKSxcbiAgICBUb3dlciA9IHJlcXVpcmUoXCIuL1Rvd2VyLmpzXCIpLFxuICAgIHRvd2VyRGF0YSA9IHJlcXVpcmUoXCIuLi9nYW1lRGF0YS90b3dlcmRhdGEuanNcIiksXG4gICAgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMuanNcIiksXG4gICAgcGF0aENvb3JkaW5hdGVzID0gcmVxdWlyZShcIi4uL2dhbWVEYXRhL3BhdGhkYXRhLmpzXCIpLFxuICAgIGNvbnN0YW50cyA9IHJlcXVpcmUoXCIuLi9nYW1lRGF0YS9nYW1lQ29uc3RhbnRzLmpzXCIpO1xuXG52YXIgR2FtZUVuZ2luZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudXNlckdvbGQgPSBjb25zdGFudHMuU1RBUlRJTkdHT0xEO1xuICAgIHRoaXMubGV2ZWwgPSAwO1xuICAgIHRoaXMudXNlckxpdmVzID0gY29uc3RhbnRzLlNUQVJUSU5HTElWRVM7XG4gICAgdGhpcy5hY3RpdmVNb25zdGVycyA9IFtdOyAvLyBMaXN0IG9mIGFjdGl2ZSBtb25zdGVycyBpbiB0aGUgZ2FtZVxuICAgIHRoaXMudG93ZXJzID0gW107IC8vIG9iamVjdCBvZiB0b3dlciBvYmplY3RzXG4gICAgdGhpcy50aW1lciA9IGNvbnN0YW50cy5USU1FQkVUV0VFTk1PTlNURVJDUkVBVEU7XG4gICAgdGhpcy5uZXh0TGV2ZWxDYWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLm1vbnN0ZXJzVG9DcmVhdGUgPSAwO1xuICAgIHRoaXMuZ2FtZVBhdGggPSBfY29udmVydFBhdGhUb0xpbmVzKHBhdGhDb29yZGluYXRlcy5wYXRoKTtcbiAgICB0aGlzLmdhbWVTdGF0ZSA9IFwic3RhcnRcIjsgLy8gUG9zc2libGUgdmFsdWVzIGFyZSBzdGFydCwgbG9zdCwgd29uLCBwbGF5aW5nXG4gICAgdGhpcy5nYW1lR3JpZCA9IF9pbml0aWF0ZUdyaWQodGhpcy5nYW1lUGF0aCk7XG59XG5cbkdhbWVFbmdpbmUucHJvdG90eXBlLmFkZE1vbnN0ZXIgPSBmdW5jdGlvbihsZXZlbCkge1xuICAgIC8vIGFkZCBtb25zdGVyIChzcGVjaWZpZWQgYnkgbmFtZSkgdG8gZ2FtZVxuICAgIHZhciBtb25zdGVyID0gbmV3IE1vbnN0ZXIoXCJtb25zdGVyMVwiKTsgIC8vIE5PVEUgQ0hBTkdFIFRISVMgVE8gUkVQUkVTRU5UIE1PTlNURVIgQkFTRUQgT04gTEVWRUxcbiAgICB0aGlzLmFjdGl2ZU1vbnN0ZXJzLnB1c2gobW9uc3Rlcik7XG59XG5cbkdhbWVFbmdpbmUucHJvdG90eXBlLmFkZFRvd2VyID0gZnVuY3Rpb24oaWQsIHBvc2l0aW9uLCBncmlkUG9zaXRpb24sIGdvbGRDb3N0KSB7XG4gICAgdGhpcy51c2VyR29sZCAtPSBnb2xkQ29zdDtcbiAgICB2YXIgdG93ZXIgPSBuZXcgVG93ZXIocG9zaXRpb24sIGlkKTtcbiAgICB0aGlzLnRvd2Vycy5wdXNoKHRvd2VyKTtcbiAgICAvLyBTZXQgZ2FtZUdyaWQgcG9zaXRpb25pbmdcbiAgICB0aGlzLmdhbWVHcmlkW2dyaWRQb3NpdGlvbi54XVtncmlkUG9zaXRpb24ueV0gPSBmYWxzZTtcbiAgICB0aGlzLmdhbWVHcmlkW2dyaWRQb3NpdGlvbi54ICsgMV1bZ3JpZFBvc2l0aW9uLnldID0gZmFsc2U7XG4gICAgdGhpcy5nYW1lR3JpZFtncmlkUG9zaXRpb24ueF1bZ3JpZFBvc2l0aW9uLnkgKyAxXSA9IGZhbHNlO1xuICAgIHRoaXMuZ2FtZUdyaWRbZ3JpZFBvc2l0aW9uLnggKyAxXVtncmlkUG9zaXRpb24ueSArIDFdID0gZmFsc2U7XG59XG5cbi8qXG5UYWtlcyBpbiBhIHBvc2l0aW9uIG9iamVjdCAobG9jYXRpb24gb2YgdGhlIGNsaWNrKVxuUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGlzIGF0IHRoYXQgcG9zaXRpb25cbnt0eXBlOiBudWxsfSBpZiBub3RoaW5nIGZvdW5kXG4qL1xuR2FtZUVuZ2luZS5wcm90b3R5cGUuY2hlY2tDbGlja0xvY2F0aW9uID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICB2YXIgZWxlbWVudCA9IHt9O1xuICAgIC8vIExvb3BzIHRocm91Z2ggYWN0aXZlTW9uc3RlcnNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYWN0aXZlTW9uc3RlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHV0aWxzLmNoZWNrSWZJblNxdWFyZShwb3NpdGlvbiwgdGhpcy5hY3RpdmVNb25zdGVyc1tpXS5wb3NpdGlvbiwgdGhpcy5hY3RpdmVNb25zdGVyc1tpXS5zaWRlTGVuZ3RoKSkge1xuICAgICAgICAgICAgZWxlbWVudC50eXBlID0gXCJtb25zdGVyXCI7XG4gICAgICAgICAgICBlbGVtZW50LmluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbm90aGluZyB3YXMgZm91bmQsIGxvb3AgdGhyb3VnaCB0b3dlcnNcbiAgICBpZiAoZWxlbWVudC50eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRvd2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHV0aWxzLmNoZWNrSWZJblNxdWFyZShwb3NpdGlvbiwgdGhpcy50b3dlcnNbaV0ucG9zaXRpb24sIHRoaXMudG93ZXJzW2ldLnBvc2l0aW9uLnNpZGVMZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC50eXBlID0gXCJ0b3dlclwiO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgbm8gdG93ZXJzIG9yIG1vbnN0ZXJzIGZvdW5kIHJldHVybiBhIHR5cGUgb2YgbnVsbFxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbGVtZW50LnR5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xufVxuXG5HYW1lRW5naW5lLnByb3RvdHlwZS5jaGVja0dhbWVTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmxldmVsID09PSBjb25zdGFudHMuRklOQUxMRVZFTCArIDEpIHsgLy8gTUFYIGxldmVsXG4gICAgICAgIHRoaXMuZ2FtZVN0YXRlID0gXCJ3b25cIjtcbiAgICB9IGVsc2UgaWYgKHRoaXMudXNlckxpdmVzIDw9IDApIHtcbiAgICAgICAgdGhpcy5nYW1lU3RhdGUgPSBcImxvc3RcIjtcbiAgICB9XG59XG5cbi8vIG1ldGhvZCB0byBjaGVjayBnb2xkIGJlZm9yZSBwbGFjZSB0b3dlciBvciB1cGdyYWRlXG5HYW1lRW5naW5lLnByb3RvdHlwZS5jaGVja0dvbGQgPSBmdW5jdGlvbihnb2xkQ29zdCkge1xuICAgIGlmIChnb2xkQ29zdCA8PSB0aGlzLnVzZXJHb2xkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbkdhbWVFbmdpbmUucHJvdG90eXBlLmdhbWVPdmVyID0gZnVuY3Rpb24oKSB7XG5cbn1cblxuR2FtZUVuZ2luZS5wcm90b3R5cGUuZ2FtZVN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5nYW1lU3RhdGUgPSBcInBsYXlpbmdcIjtcbiAgICB0aGlzLm5leHRMZXZlbCgpO1xufVxuXG5HYW1lRW5naW5lLnByb3RvdHlwZS5nYW1lV29uID0gZnVuY3Rpb24oKSB7XG5cbn1cblxuR2FtZUVuZ2luZS5wcm90b3R5cGUubmV4dExldmVsID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gT25seSBjYWxscyB0aGUgbmV4dCBsZXZlbCBvbmNlIC0gbmV4dExldmVsQ2FsbGVkIGlzIHJlc2V0IG9uIGEgbmV3IG1vbnN0ZXIgY3JlYXRpb25cbiAgICBpZiAodGhpcy5uZXh0TGV2ZWxDYWxsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMubW9uc3RlcnNUb0NyZWF0ZSA9IGNvbnN0YW50cy5NT05TVEVSU1BFUkxFVkVMO1xuICAgICAgICB0aGlzLmxldmVsKys7XG4gICAgfVxufVxuXG4vKlxucGxhY2VUb3dlciBoYW5kbGVzIHRoZSB2YWxpZGF0aW9uIG9mIHRoZSB0b3dlciBwbGFjZW1lbnQgKHBvc2l0aW9uIGFuZCBzdWZmaWNpZW50IGdvbGQpXG5UYWtlcyBpbiAzIGFyZ3VtZW50czpcbnRvd2VyTmFtZSAtIHN0cmluZyBzcGVjaWZ5aW5nIHdoYXQgdG93ZXIgaXMgYmVpbmcgcGxhY2VkXG5ncmlkUG9zaXRpb24gLSB0b3AgbGVmdCBncmlkIGJsb2NrIG9mIHdoZXJlIHRoZSB0b3dlciB3b3VsZCBiZSBwbGFjZWRcbnRvd2VyQ29vcmRpbmF0ZXMgLSB0b3AgbGVmdCBjb29yZGluYXRlIG9mIGEgdG93ZXJcblJldHVybnMgYW4gb2JqZWN0IHdpdGggYSBib29sZWFuIHRvIHJlcHJlc2VudCB3aGV0aGVyIHRoZSB0b3dlciBpcyBwbGFjZWQgYW5kIGFuIGVycm9yIG1lc3NhZ2UgaWYgdGhlIHRvd2VyIHdhcyBub3QgcGxhY2VkXG4qL1xuR2FtZUVuZ2luZS5wcm90b3R5cGUucGxhY2VUb3dlciA9IGZ1bmN0aW9uKHRvd2VyTmFtZSwgZ3JpZFBvc2l0aW9uLCB0b3dlckNvb3JkaW5hdGVzKSB7XG4gICAgdmFyIGdvbGRDb3N0ID0gdG93ZXJEYXRhW3Rvd2VyTmFtZV0uZ29sZENvc3Q7XG4gICAgLy8gVmFsaWRhdGUgdG93ZXIgcGxhY2VtZW50XG4gICAgaWYgKHRoaXMudmFsaWRhdGVUb3dlclBsYWNlbWVudChncmlkUG9zaXRpb24pXG4gICAgJiYgdGhpcy5jaGVja0dvbGQoZ29sZENvc3QpKSB7XG5cbiAgICAgICAgdGhpcy5hZGRUb3dlcih0b3dlck5hbWUsIHRvd2VyQ29vcmRpbmF0ZXMsIGdyaWRQb3NpdGlvbiwgZ29sZENvc3QpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGxhY2VkOiB0cnVlXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcblxuICAgICAgICBpZiAoIXRoaXMudmFsaWRhdGVUb3dlclBsYWNlbWVudChncmlkUG9zaXRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBsYWNlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogY29uc3RhbnRzLk1FU1NBR0VJTlZBTElEUExBQ0VNRU5UXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBsYWNlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogY29uc3RhbnRzLk1FU1NBR0VOT1RFTk9VR0hHT0xEXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuR2FtZUVuZ2luZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICBpZiAodGhpcy5nYW1lU3RhdGUgPT09IFwicGxheWluZ1wiKSB7XG4gICAgICAgIC8vIHNlbmQgc3RhdGUgdG8gdGhlIGRpc3BsYXkgb2JqZWN0IHRvIHJlbmRlclxuICAgICAgICBkeW5hbWljQ29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgZHluYW1pY0NvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGR5bmFtaWNDYW52YXMud2lkdGgsIGR5bmFtaWNDYW52YXMuaGVpZ2h0KTtcblxuICAgICAgICAvLyBSZW5kZXIgdG93ZXJzIGZpcnN0IHNvIHRoYXQgaWYgbW9uc3RlcnMgYXJlIGxhcmdlciB0aGV5IHNob3cgYWJvdmUgdG93ZXJzXG4gICAgICAgIHRoaXMudG93ZXJzLmZvckVhY2goZnVuY3Rpb24odG93ZXIpIHtcbiAgICAgICAgICAgIHRvd2VyLmRyYXcoKTtcbiAgICAgICAgfSlcblxuICAgICAgICAvLyAgbG9vcCB0aHJvdWdoIGxpc3Qgb2YgYWN0aXZlIG1vbnN0ZXJzIGFuZCByZW5kZXIgdGhlbVxuICAgICAgICAvLyAgVE9ETyBwcm9iYWJseSBuZWVkIHRvIGZpbmQgYSBiZXR0ZXIgd2F5IHRvIHJlbmQgdGhlbSBhcGFydCBmcm9tIHJhbmRvbSByZWN0YW5nbGVcbiAgICAgICAgdGhpcy5hY3RpdmVNb25zdGVycy5mb3JFYWNoKGZ1bmN0aW9uKGFjdGl2ZU1vbnN0ZXIpIHtcbiAgICAgICAgICAgIGFjdGl2ZU1vbnN0ZXIuZHJhdygpO1xuXG4gICAgICAgICAgICAvLyBSZW5kZXJzIHByb2plY3RpbGUgYW5pbWF0aW9ucyB0aGF0IGFyZSBhY3RpdmUgZm9yIGVhY2ggbW9uc3RlclxuICAgICAgICAgICAgYWN0aXZlTW9uc3Rlci5wcm9qZWN0aWxlcy5mb3JFYWNoKGZ1bmN0aW9uKHByb2plY3RpbGUpIHtcbiAgICAgICAgICAgICAgICBwcm9qZWN0aWxlLmRyYXcoYWN0aXZlTW9uc3Rlci5wb3NpdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZHluYW1pY0NvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICB9IGVsc2UgaWYgKHRoaXMuZ2FtZVN0YXRlID09PSBcImxvc3RcIikge1xuICAgICAgICAvLyBBZGQgcmVuZGVyIG1ldGhvZCB0byBhZGQgdGhpbmdcbiAgICAgICAgY29uc29sZS5sb2coXCJ5b3UgbG9zdCBsb2xcIik7XG4gICAgfSBlbHNlIGlmICh0aGlzLmdhbWVTdGF0ZSA9PT0gXCJ3b25cIikge1xuICAgICAgICAvLyBBZGQgcmVuZGVyIG1ldGhvZCB0byBhZGQgdGhpbmdcbiAgICAgICAgY29uc29sZS5sb2coXCJjb25ncmF0cyB5b3Ugd29uXCIpO1xuICAgIH1cblxufTtcblxuLy8gQ2hhbmdlZCB2YWx1ZXMgdG8gYmUgYmFzZWQgb2ZmIGR0IChjaGFuZ2UgaW4gdGltZSBzaW5jZSBsYXN0IHJlbmRlcilcbkdhbWVFbmdpbmUucHJvdG90eXBlLnJ1bkN5Y2xlID0gZnVuY3Rpb24oZHQpIHtcbiAgICB0aGlzLmNoZWNrR2FtZVN0YXRlKCk7XG5cbiAgICBpZiAodGhpcy5nYW1lU3RhdGUgPT09IFwicGxheWluZ1wiKSB7XG4gICAgICAgIC8vIGxvb3AgdGhyb3VnaCBhY3RpdmUgbW9uc3RlcnMgYW5kIHRvd2VycyBhbmQgcnVuIHRoZSBjeWNsZVxuICAgICAgICAvLyBFYWNoIHJ1bkN5Y2xlIG1ldGhvZCByZXR1cm5zIGluZm9ybWF0aW9uIGZvciB0aGUgZ2FtZUVuZ2luZSB0b1xuICAgICAgICAvLyBwcm9jZXNzIChlLmcuIHRoZSBtb25zdGVyIGRpZWQsIHRvd2VyIGNoYW5nZWQpXG5cbiAgICAgICAgLy8gQWRkcyBtb25zdGVycyBpZiB0aGVyZSBhcmUgbW9uc3RlcnMgdG8gY3JlYXRlIC0gY3JlYXRlcyAxMCBwZXIgbGV2ZWxcbiAgICAgICAgaWYgKHRoaXMubW9uc3RlcnNUb0NyZWF0ZSA+IDApIHtcbiAgICAgICAgICAgIC8vICB0aW1lciB0byBhZGQgbW9uc3RlcnNcbiAgICAgICAgICAgIHRoaXMudGltZXIgLT0gZHQ7XG4gICAgICAgICAgICBpZiAodGhpcy50aW1lciA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRNb25zdGVyKHRoaXMubGV2ZWwpOyAvLyBzZW5kIHRocm91Z2ggdGhlIGxldmVsIG51bWJlclxuICAgICAgICAgICAgICAgIHRoaXMudGltZXIgPSBjb25zdGFudHMuVElNRUJFVFdFRU5NT05TVEVSQ1JFQVRFOyAvLyBFdmVyeSAxIHNlY29uZCBjcmVhdGUgYSBuZXcgbW9uc3RlclxuICAgICAgICAgICAgICAgIHRoaXMubW9uc3RlcnNUb0NyZWF0ZS0tO1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dExldmVsQ2FsbGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYWxscyB0aGUgbmV4dCBsZXZlbCBpZiBhbGwgdGhlIG1vbnN0ZXJzIGFyZSBkZWFkIC0gVE9ETyBhZGQgYSBkZWxheSB0byBzcGFjZSBvdXQgYmV0d2VlbiBsZXZlbHNcbiAgICAgICAgLy8gQ2hlY2tzIHdoZXRoZXIgdGhlcmUgYXJlIGFueSBtb25zdGVycyBsZWZ0IGFuZCB3aGV0aGVyIGFsbCB0aGUgbW9uc3RlcnMgaGF2ZSBiZWVuIGNyZWF0ZWRcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlTW9uc3RlcnMubGVuZ3RoID09PSAwICYmIHRoaXMubW9uc3RlcnNUb0NyZWF0ZSA9PT0gMCkge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRMZXZlbCgpO1xuICAgICAgICAgICAgfSwgY29uc3RhbnRzLlRJTUVCRVRXRUVOTEVWRUxTICogMTAwMCk7XG5cbiAgICAgICAgICAgIHRoaXMubmV4dExldmVsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlTW9uc3RlcnMuZm9yRWFjaChmdW5jdGlvbihhY3RpdmVNb25zdGVyLCBpLCBtb25zdGVyQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAvLyBtb3ZlcyB0aGUgbW9uc3RlcnMgYW5kIGNoZWNrcyB3aGV0aGVyIHRoZXkgZ2V0IHRvIHRoZSBlbmQgb2YgdGhlIGN5Y2xlXG4gICAgICAgICAgICAgICAgLy8gYWxzbyBmYWN0b3IgdG8gaGF2ZSBhIHByb2plY3RpbGVzIGFycmF5IC0gd2hpY2ggbWVhbnMgdGhhdCBlYWNoIGN5Y2xlIGZvciBtb25zdGVycyB0aGV5IHdpbGwgdGFrZSBkYW1hZ2VcbiAgICAgICAgICAgICAgICB2YXIgbW9uc3RlclN0YXR1cyA9IGFjdGl2ZU1vbnN0ZXIucnVuQ3ljbGUodGhpcy5nYW1lUGF0aCwgZHQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFtb25zdGVyU3RhdHVzLmFsaXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb25zdGVyU3RhdHVzLmdpdmVHb2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVzZXJHb2xkICs9IGFjdGl2ZU1vbnN0ZXIuYm91bnR5XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vbnN0ZXJEZWF0aCA9IG5ldyBDdXN0b21FdmVudChcIm1vbnN0ZXJEZWF0aFwiLCB7XCJkZXRhaWxcIjoge2luZGV4OiBpfX0pO1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG1vbnN0ZXJEZWF0aCk7XG4gICAgICAgICAgICAgICAgICAgIG1vbnN0ZXJBcnJheS5zcGxpY2UoaSwgMSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICAvLyBSdW4gdG93ZXIgY3ljbGVzIGhlcmUgLSBwYXNzIGluIGFjdGl2ZSBtb25zdGVycyAtIHRvd2VycyBvbmx5IGNyZWF0ZSBwcm9qZWN0aWxlc1xuICAgICAgICAgICAgdGhpcy50b3dlcnMuZm9yRWFjaChmdW5jdGlvbih0b3dlcikge1xuICAgICAgICAgICAgICAgIHRvd2VyLnJ1bkN5Y2xlKHRoaXMuYWN0aXZlTW9uc3RlcnMsIGR0KTsgLy8gUGFzcyBpbiBhY3RpdmUgbW9uc3RlcnMgYW5kIGF0dGFjaCBwcm9qZWN0aWxlcyB0byB0aGVtXG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9XG5cblxuICAgIH1cbn1cbi8qXG5UYWtlcyBpbiBhIGdyaWRQb3NpdGlvbiBvYmplY3QgKHBvaW50cyB0byB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSB0b3dlcilcblRvd2VycyB0YWtlIHVwIGEgMngyIGdyaWQgLSB0aGlzIGZ1bmN0aW9uIGNoZWNrcyBhbGwgcG9zaXRpb25zXG5SZXR1cm5zIHRydWUgaWYgdGhlIHBvc2l0aW9uIGlzIGEgdmFsaWQgcGxhY2VtZW50IGZvciBhIHRvd2VyXG5SZXR1cm5zIGZhbHNlIGlmIHRoZSBwb3NpdGlvbiBpcyBpbnZhbGlkXG4qL1xuR2FtZUVuZ2luZS5wcm90b3R5cGUudmFsaWRhdGVUb3dlclBsYWNlbWVudCA9IGZ1bmN0aW9uKGdyaWRQb3NpdGlvbikge1xuICAgIC8vIENoZWNrcyBhbGwgNCBwb3NpdGlvbnNcbiAgICB2YXIgcG9zaXRpb25WYWxpZCA9IHRoaXMuZ2FtZUdyaWRbZ3JpZFBvc2l0aW9uLnhdW2dyaWRQb3NpdGlvbi55XS5lbXB0eVxuICAgICYmIHRoaXMuZ2FtZUdyaWRbZ3JpZFBvc2l0aW9uLnggKyAxXVtncmlkUG9zaXRpb24ueV0uZW1wdHlcbiAgICAmJiB0aGlzLmdhbWVHcmlkW2dyaWRQb3NpdGlvbi54XVtncmlkUG9zaXRpb24ueSArIDFdLmVtcHR5XG4gICAgJiYgdGhpcy5nYW1lR3JpZFtncmlkUG9zaXRpb24ueCArIDFdW2dyaWRQb3NpdGlvbi55ICsgMV0uZW1wdHk7XG4gICAgcmV0dXJuIHBvc2l0aW9uVmFsaWQ7XG59XG5cbi8qXG5JbnB1dDogUGF0aCAtIGFuIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyBjb29yZGluYXRlcyB3aGVyZSB0aGUgcGF0aCB3aWxsIHJ1biB0b1xuT3V0cHV0OiBwYXRoTGluZXMgLSBhbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIHN0YXJ0UG9pbnQgKGNvb3JkaW5hdGVzKSxcbiAgICAgICAgZGlzdGFuY2Ugb2YgdGhlIGxpbmUgYW5kIGRpcmVjdGlvbiAobGVmdCwgcmlnaHQsIHVwLCBkb3duKVxuKi9cbmZ1bmN0aW9uIF9jb252ZXJ0UGF0aFRvTGluZXMocGF0aCkge1xuICAgIHZhciBwYXRoTGluZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHZhciBsaW5lID0ge307XG5cbiAgICAgICAgLy8gQXNzdW1lIHRoYXQgdGhlIGRpcmVjdGlvbiBpcyBvbmx5IDQgd2F5c1xuICAgICAgICBpZiAocGF0aFtpKzFdLnggLSBwYXRoW2ldLnggPT09IDApIHtcblxuICAgICAgICAgICAgaWYgKHBhdGhbaSsxXS55IC0gcGF0aFtpXS55ID4gMCkge1xuICAgICAgICAgICAgICAgIGxpbmUuZGlyZWN0aW9uID0gXCJkb3duXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpbmUuZGlyZWN0aW9uID0gXCJ1cFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHBhdGhbaSsxXS54IC0gcGF0aFtpXS54ID09PSAwID4gMCkge1xuXG4gICAgICAgICAgICAgICAgbGluZS5kaXJlY3Rpb24gPSBcImxlZnRcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGluZS5kaXJlY3Rpb24gPSBcInJpZ2h0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGluZS5zdGFydFBvaW50ID0gcGF0aFtpXTtcbiAgICAgICAgbGluZS5kaXN0YW5jZSA9IHV0aWxzLmdldFBvc2l0aW9uRGlmZmVyZW5jZShwYXRoW2ldLCBwYXRoW2krMV0pO1xuICAgICAgICBwYXRoTGluZXMucHVzaChsaW5lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aExpbmVzO1xufVxuXG4vKlxuQ29udmVydHMgYSBwYXRoTGluZXMgYXJyYXkgKGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCBhIHN0YXJ0UG9pbnQsXG5kaXJlY3Rpb24gYW5kIGEgZGlzdGFuY2UpIGludG8gYW4gYXJyYXkgb2YgZ3JpZCBibG9ja3MgKClcbk5vdGUgdGhhdCB0aGVyZSB3aWxsIGJlIHNvbWUgb3ZlcmxhcCB3aXRoIGJsb2NrcywgaG93ZXZlcixcbmFzIHRoZXkgYXJlIG9ubHkgdXNlZCB0byBzZXQgZ3JpZCBwb3NpdGlvbnMgdG8gbm90IGVtcHR5LCBvdmVybGFwIGlzIG5vdCBhbiBpc3N1ZVxuKi9cbmZ1bmN0aW9uIF9jcmVhdGVQYXRoQmxvY2tzKHBhdGhMaW5lcykge1xuICAgIHZhciBibG9ja3MgPSBbXTtcbiAgICAvLyBMb29wcyB0aHJvdWdoIGFsbCB0aGUgcGF0aExpbmVzIGFuZCBjcmVhdGVzIGJsb2NrcyBiYXNlZCBvbiB0aGF0XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoTGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gYmxvY2tBbW91bnQgcmVmZXJzIHRvIHRoZSBhbW91bnQgb2YgYmxvY2tzIHRoYXQgZm9sbG93IHRoZSBwYXRoXG4gICAgICAgIHZhciBibG9ja0Ftb3VudCA9IE1hdGguZmxvb3IocGF0aExpbmVzW2ldLmRpc3RhbmNlIC8gY29uc3RhbnRzLkdSSURTSVpFKSArIDEsXG4gICAgICAgICAgICBwYXRoRGlyZWN0aW9uO1xuICAgICAgICAvKiBTZXQgZGlyZWN0aW9uXG4gICAgICAgIHg6IDEgPSByaWdodFxuICAgICAgICB4OiAtMSA9IGxlZnRcbiAgICAgICAgeTogMSA9IGRvd25cbiAgICAgICAgeTogLTEgPSB1cFxuICAgICAgICBPZmZzZXQgdmFsdWVzIGhlbHAgY2VudGVyIHRoZSBncmlkIGJsb2NrcyAoaS5lLiBpbmxpbmUgd2l0aCB0aGUgZGlyZWN0aW9uKVxuICAgICAgICBTaWRlIHZhbHVlcyBhcmUgdXNlZCB0byBkZWZpbmUgd2hpY2ggc2lkZSB0aGUgYmxvY2tzIGFyZSBvbiByZWxhdGl2ZSB0b1xuICAgICAgICB0aGUgcGF0aCBkaXJlY3Rpb24gKGkuZS4gaG9yaXpvbnRhbGx5IG9yIHZlcnRpY2FsbHkpXG4gICAgICAgICovXG4gICAgICAgIHN3aXRjaCAocGF0aExpbmVzW2ldLmRpcmVjdGlvbikge1xuICAgICAgICAgICAgY2FzZSBcInVwXCI6XG4gICAgICAgICAgICAgICAgcGF0aERpcmVjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgeTogLTEsXG4gICAgICAgICAgICAgICAgICAgIHhTaWRlOiBjb25zdGFudHMuR1JJRFNJWkUgLyAyLFxuICAgICAgICAgICAgICAgICAgICB5U2lkZTogMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkb3duXCI6XG4gICAgICAgICAgICAgICAgcGF0aERpcmVjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgeTogMSxcbiAgICAgICAgICAgICAgICAgICAgeFNpZGU6IGNvbnN0YW50cy5HUklEU0laRSAvIDIsXG4gICAgICAgICAgICAgICAgICAgIHlTaWRlOiAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgICAgICAgICBwYXRoRGlyZWN0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiAtMSxcbiAgICAgICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICAgICAgeFNpZGU6IDAsXG4gICAgICAgICAgICAgICAgICAgIHlTaWRlOiBjb25zdGFudHMuR1JJRFNJWkUgLyAyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgICAgICAgcGF0aERpcmVjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogMSxcbiAgICAgICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICAgICAgeFNpZGU6IDAsXG4gICAgICAgICAgICAgICAgICAgIHlTaWRlOiBjb25zdGFudHMuR1JJRFNJWkUgLyAyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRpcmVjdGlvbiBwcm92aWRlZCBpbiBwYXRoTGluZXNcIik7XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICBDcmVhdGVzIGJsb2NrIGVxdWFsIHRvIGRvdWJsZSB0aGUgYW1vdW50IG9mIHRoZSBibG9ja0Ftb3VudCAodGhlIGVxdWl2YWxlbnQgYW1vdW50IG9mIGJsb2NrcyB0byB0aGUgcGF0aCBkaXN0YW5jZSlcbiAgICAgICAgYmxvY2tCZWZvcmUgcmVmZXJzIHRvIGJsb2NrcyBlaXRoZXIgdG8gdGhlIGxlZnQgb3IgdG9wIG9mIHRoZSBwYXRoXG4gICAgICAgIGJsb2NrQWZ0ZXIgcmVmZXJzIHRvIGJsb2NrcyBlaXRoZXIgdG8gdGhlIHJpZ2h0IG9yIGJlbG93IG9mIHRoZSBwYXRoXG4gICAgICAgIENyZWF0ZXMgYmxvY2sgbG9jYXRpb25zIGFuZCBnaXZlcyB0aGVtIG9mZnNldHMgdG8gdGhlaXIgY2VudGVyIHBvc2l0aW9ucyAoZm9yIGNsYXJpdHkgaW4gY29udmVydGluZyB0byBibG9ja3MpXG4gICAgICAgICovXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYmxvY2tBbW91bnQ7IGorKykge1xuXG4gICAgICAgICAgICB2YXIgYmxvY2tCZWZvcmUgPSB7XG5cbiAgICAgICAgICAgICAgICB4OiBwYXRoTGluZXNbaV0uc3RhcnRQb2ludC54ICtcbiAgICAgICAgICAgICAgICAgICAgcGF0aERpcmVjdGlvbi54U2lkZSArXG4gICAgICAgICAgICAgICAgICAgIChwYXRoRGlyZWN0aW9uLnggKiBjb25zdGFudHMuR1JJRFNJWkUgKiBqKSxcblxuICAgICAgICAgICAgICAgIHk6IHBhdGhMaW5lc1tpXS5zdGFydFBvaW50LnkgK1xuICAgICAgICAgICAgICAgICAgICBwYXRoRGlyZWN0aW9uLnlTaWRlICtcbiAgICAgICAgICAgICAgICAgICAgKHBhdGhEaXJlY3Rpb24ueSAqIGNvbnN0YW50cy5HUklEU0laRSAqIGogKVxuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJsb2NrQWZ0ZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHBhdGhMaW5lc1tpXS5zdGFydFBvaW50LnggK1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aERpcmVjdGlvbi54U2lkZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAocGF0aERpcmVjdGlvbi54ICogY29uc3RhbnRzLkdSSURTSVpFICogaiksXG5cbiAgICAgICAgICAgICAgICAgICAgeTogcGF0aExpbmVzW2ldLnN0YXJ0UG9pbnQueSAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aERpcmVjdGlvbi55U2lkZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAocGF0aERpcmVjdGlvbi55ICogY29uc3RhbnRzLkdSSURTSVpFICogailcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBibG9ja3MucHVzaCh1dGlscy5jb252ZXJ0VG9CbG9jayhibG9ja0JlZm9yZSkpO1xuICAgICAgICAgICAgYmxvY2tzLnB1c2godXRpbHMuY29udmVydFRvQmxvY2soYmxvY2tBZnRlcikpO1xuICAgICAgICB9XG5cblxuICAgIH1cblxuICAgIHJldHVybiBibG9ja3Ncbn1cblxuLy8gR3JpZCBpcyAzNiBieSAyNFxuLy8gY2FuIGJlIGluaXRpYXRlZCBieSBbeF1beV0gLSBlYWNoIGJsb2NrIGhhcyBhIGJvb2xlYW4gdG8gcmVwcmVzZW50IHdoZXRoZXIgc29tZXRoaW5nIGlzIHRoZXJlXG5mdW5jdGlvbiBfaW5pdGlhdGVHcmlkKHBhdGhMaW5lcykge1xuICAgIHZhciBncmlkID0gW10sXG4gICAgICAgIGJsb2NrcyA9IF9jcmVhdGVQYXRoQmxvY2tzKHBhdGhMaW5lcyksXG4gICAgICAgIHhHcmlkQW1vdW50ID0gY29uc3RhbnRzLkNBTlZBU1dJRFRIIC8gY29uc3RhbnRzLkdSSURTSVpFLFxuICAgICAgICB5R3JpZEFtb3VudCA9IGNvbnN0YW50cy5DQU5WQVNIRUlHSFQgLyBjb25zdGFudHMuR1JJRFNJWkU7XG4gICAgICAgIFxuICAgIC8vIENyZWF0ZSB0aGUgZ3JpZFxuICAgIGZvciAodmFyIHggPSAwOyB4IDwgeEdyaWRBbW91bnQ7IHgrKykge1xuICAgICAgICBncmlkW3hdID0gW107XG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgeUdyaWRBbW91bnQ7IHkrKykge1xuICAgICAgICAgICAgZ3JpZFt4XVt5XSA9IHtcbiAgICAgICAgICAgICAgICBlbXB0eTogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBMb29wIHRocm91Z2ggdGhlIGJsb2NrcyAod2hpY2ggYXJlIG9uIHRoZSBwYXRoKSBhbmRcbiAgICBibG9ja3MubWFwKGZ1bmN0aW9uKGJsb2NrLCBpKSB7XG4gICAgICAgIGdyaWRbYmxvY2sueF1bYmxvY2sueV0gPSB7XG4gICAgICAgICAgICBlbXB0eTogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9KTtcblxuICAgIHJldHVybiBncmlkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBHYW1lRW5naW5lO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvY2xhc3Nlcy9HYW1lLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBtb25zdGVyRGF0YSA9IHJlcXVpcmUoXCIuLi9nYW1lRGF0YS9tb25zdGVyZGF0YS5qc1wiKSxcbiAgICB1dGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy5qc1wiKSxcbiAgICBjb25zdGFudHMgPSByZXF1aXJlKFwiLi4vZ2FtZURhdGEvZ2FtZUNvbnN0YW50cy5qc1wiKTtcblxudmFyIE1vbnN0ZXIgPSBmdW5jdGlvbihpZCkge1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmN1cnJlbnRIcCA9IG1vbnN0ZXJEYXRhW2lkXS5tYXhIcDtcbiAgICB0aGlzLm1heEhwID0gbW9uc3RlckRhdGFbaWRdLm1heEhwO1xuICAgIHRoaXMuYmFzZU1zID0gbW9uc3RlckRhdGFbaWRdLmJhc2VNczsgLy8gTW92ZW1lbnQgc3BlZWQgLSBcInVuaXRzXCIgcGVyIHNlY29uZFxuICAgIHRoaXMudHlwZSA9IG1vbnN0ZXJEYXRhW2lkXS50eXBlO1xuICAgIHRoaXMuYm91bnR5ID0gbW9uc3RlckRhdGFbaWRdLmJvdW50eTtcbiAgICB0aGlzLnByb2plY3RpbGVzID0gW107XG4gICAgdGhpcy5kaXN0YW5jZVRyYXZlbGxlZCA9IDA7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHt9OyAvLyBJbml0aWFsIHBvc2l0aW9uIGlzIGRlZmluZWQgYnkgdGhlIHBhdGhcbiAgICB0aGlzLnNpZGVMZW5ndGggPSBjb25zdGFudHMuTU9OU1RFUkxFTkdUSDtcbn07XG4vLyBNZXRob2QgdGhlIGdhbWUgb2JqZWN0IHVzZXMgdG8gbW92ZSBtb25zdGVyc1xuTW9uc3Rlci5wcm90b3R5cGUucnVuQ3ljbGUgPSBmdW5jdGlvbihnYW1lUGF0aCwgZHQpIHtcbiAgICB2YXIgc3RhdHVzID0ge307XG4gICAgdGhpcy5tb3ZlKGdhbWVQYXRoLCBkdCk7XG5cbiAgICB0aGlzLnByb2plY3RpbGVzLmZvckVhY2goZnVuY3Rpb24ocHJvamVjdGlsZSwgaSwgcHJvamVjdGlsZUFycmF5KSB7XG4gICAgICAgIHByb2plY3RpbGUubW92ZShkdCk7XG4gICAgICAgIGlmIChwcm9qZWN0aWxlLmVuZCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVIcCgtcHJvamVjdGlsZS5kYW1hZ2UpO1xuICAgICAgICAgICAgcHJvamVjdGlsZUFycmF5LnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICB0aGlzLmNoZWNrRGVhdGgoKTtcblxuICAgIGlmICh0aGlzLmNoZWNrRGVhdGgoKSkge1xuICAgICAgICBzdGF0dXMuYWxpdmUgPSBmYWxzZTtcbiAgICAgICAgc3RhdHVzLmdpdmVHb2xkID0gIXRoaXMucG9zaXRpb24uZW5kOyAvLyBEb2VzIG5vdCBnaXZlIGdvbGQgaWYgdGhlIG1vbnN0ZXIgcmVhY2hlZCB0aGUgZW5kXG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdHVzLmFsaXZlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdHVzO1xufVxuXG5Nb25zdGVyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oKSB7XG4gICAgZHluYW1pY0NvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgZHluYW1pY0NvbnRleHQucmVjdCh0aGlzLnBvc2l0aW9uLngsIHRoaXMucG9zaXRpb24ueSwgY29uc3RhbnRzLk1PTlNURVJMRU5HVEgsIGNvbnN0YW50cy5NT05TVEVSTEVOR1RIKTtcbiAgICBkeW5hbWljQ29udGV4dC5zdHJva2UoKTtcbiAgICBkeW5hbWljQ29udGV4dC5maWxsU3R5bGUgPSBcInJlZFwiO1xuICAgIGR5bmFtaWNDb250ZXh0LmZpbGxSZWN0KHRoaXMucG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uLnkgKyBjb25zdGFudHMuTU9OU1RFUkxFTkdUSC8zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0YW50cy5NT05TVEVSTEVOR1RIICogdGhpcy5jdXJyZW50SHAvdGhpcy5tYXhIcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdGFudHMuTU9OU1RFUkxFTkdUSC8zKTtcbiAgICBkeW5hbWljQ29udGV4dC5jbG9zZVBhdGgoKTtcblxufVxuXG5Nb25zdGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cbn07XG5cbk1vbnN0ZXIucHJvdG90eXBlLmNoZWNrRGVhdGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50SHAgPD0gMCB8fCB0aGlzLnBvc2l0aW9uLmVuZDtcbn07XG5cbk1vbnN0ZXIucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbihwYXRoTGluZXMsIGR0KSB7XG4gICAgdGhpcy5kaXN0YW5jZVRyYXZlbGxlZCArPSB0aGlzLmJhc2VNcyAqIGR0O1xuICAgIHRoaXMucG9zaXRpb24gPSB1dGlscy5jb252ZXJ0RGlzdGFuY2VUb0Nvb3JkaW5hdGVzKHRoaXMuZGlzdGFuY2VUcmF2ZWxsZWQsIHBhdGhMaW5lcyk7XG59O1xuXG4vLyBDYW4gdGFrZSBpbiBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIG51bWJlclxuTW9uc3Rlci5wcm90b3R5cGUudXBkYXRlSHAgPSBmdW5jdGlvbihocENoYW5nZSkge1xuICAgIHRoaXMuY3VycmVudEhwICs9IGhwQ2hhbmdlO1xuXG4gICAgaWYgKHRoaXMuY3VycmVudEhwID4gdGhpcy5tYXhIcCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRIcCA9IHRoaXMubWF4SHA7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb25zdGVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvY2xhc3Nlcy9Nb25zdGVyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtb25zdGVyMToge1xuICAgICAgICBtYXhIcDogMzAsXG4gICAgICAgIGJhc2VNczogNTAsIC8vIHBpeGVscyBwZXIgc2Vjb25kXG4gICAgICAgIHR5cGU6IDEsIC8vIENoYW5nZSB0aGlzIHR5cGUgbGF0ZXJcbiAgICAgICAgYm91bnR5OiAzXG4gICAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2dhbWVEYXRhL21vbnN0ZXJkYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBwYXRoOiBbXG4gICAgICAgIHt4OiAwLCB5OiA1MDB9LFxuICAgICAgICB7eDogNzUsIHk6IDUwMH0sXG4gICAgICAgIHt4OiA3NSwgeTogMTAwfSxcbiAgICAgICAge3g6IDIyNSwgeTogMTAwfSxcbiAgICAgICAge3g6IDIyNSwgeTogNTAwfSxcbiAgICAgICAge3g6IDM3NSwgeTogNTAwfSxcbiAgICAgICAge3g6IDM3NSwgeTogMTAwfSxcbiAgICAgICAge3g6IDUyNSwgeTogMTAwfSxcbiAgICAgICAge3g6IDUyNSwgeTogNTAwfSxcbiAgICAgICAge3g6IDY3NSwgeTogNTAwfSxcbiAgICAgICAge3g6IDY3NSwgeTogMTAwfSxcbiAgICAgICAge3g6IDgyNSwgeTogMTAwfSxcbiAgICAgICAge3g6IDgyNSwgeTogNTAwfSxcbiAgICAgICAge3g6IDkwMCwgeTogNTAwfVxuICAgIF1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL2dhbWVEYXRhL3BhdGhkYXRhLmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9