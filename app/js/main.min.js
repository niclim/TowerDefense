/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/src/js/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	// Canvas
	__webpack_require__(2);
	
	// User interaction elements
	__webpack_require__(3);


/***/ },
/* 2 */
/***/ function(module, exports) {

	// background contains the static canvas elements
	var background = document.getElementById("static");
	var backgroundContext = background.getContext("2d");
	
	// Settings for the background - move out to a separate file
	var settings = {
	    backgroundColor: "#8CD1E6",
	    pathColor: "gray"
	}
	
	// Drawing the background
	backgroundContext.fillStyle = settings.backgroundColor;
	backgroundContext.fillRect(0, 0, background.width, background.height);
	
	/* Main path will go from [0, 500], [75, 500], [75, 100], [225, 100], [225, 500], [375, 500], [375, 100], [525, 100], [525, 500], [675, 500], [675, 100], [825, 100], [825, 500], [900, 500] */
	
	// Drawing the path - width of the path is 50px
	backgroundContext.fillStyle = settings.pathColor;
	
	backgroundContext.beginPath();
	
	// For the bottom part of the path
	backgroundContext.moveTo(0, 525);
	
	backgroundContext.lineTo(100, 525);
	backgroundContext.lineTo(100, 125); // Top
	backgroundContext.lineTo(200, 125);
	backgroundContext.lineTo(200, 525); // Bottom
	backgroundContext.lineTo(400, 525);
	backgroundContext.lineTo(400, 125); // Top
	backgroundContext.lineTo(500, 125);
	backgroundContext.lineTo(500, 525); // Bottom
	backgroundContext.lineTo(700, 525);
	backgroundContext.lineTo(700, 125); // Top
	backgroundContext.lineTo(800, 125);
	backgroundContext.lineTo(800, 525); // Bottom
	
	//Middle section to the side
	backgroundContext.lineTo(900, 525);
	backgroundContext.lineTo(900, 475);
	backgroundContext.lineTo(850, 475);
	
	// For the top part of the path
	backgroundContext.lineTo(850, 75);
	backgroundContext.lineTo(650, 75);
	backgroundContext.lineTo(650, 475);
	backgroundContext.lineTo(550, 475);
	backgroundContext.lineTo(550, 75);
	backgroundContext.lineTo(350, 75);
	backgroundContext.lineTo(350, 475);
	backgroundContext.lineTo(250, 475);
	backgroundContext.lineTo(250, 75);
	backgroundContext.lineTo(50, 75);
	backgroundContext.lineTo(50, 475);
	
	// End section
	backgroundContext.lineTo(0, 475);
	
	backgroundContext.fill();
	// backgroundContext.lineTo();


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	// Initiate all the components
	var Tower = __webpack_require__(4),
	    GameEngine = __webpack_require__(6)
	
	// Cache reused DOM elements
	var infoName = document.getElementById("info-name"),
	    infoBox1 = document.getElementById("info-box-1"),
	    infoBox2 = document.getElementById("info-box-2"),
	    infoBox3 = document.getElementById("info-box-3"),
	    infoBox4 = document.getElementById("info-box-4");
	
	//  creates global variables
	game = new GameEngine;
	dynamicCanvas = document.getElementById('dynamic');
	dynamicContext = dynamicCanvas.getContext('2d');
	
	runCycle = function() {
	    game.runCycle();
	    setTimeout(runCycle, 1000);
	}
	
	renderCycle = function() {
	    game.render();
	    requestAnimationFrame(renderCycle);
	}
	
	// HERE IS ALL THE INTERACTION EVENT LISTENERS
	
	/* ============== On start click handlers ==============*/
	/* =====================================================*/
	
	// On start, create a game element - these event listeners will be destroyed when the container is overriden
	document.getElementById("start-btn").addEventListener("click", function() {
	    // Hides the modal lightbox
	    document.getElementsByClassName("modal-content")[0].style.display = "none";
	    document.getElementsByClassName("modal-background")[0].style.display = "none";
	
	    // run repeating function that runs game engine run cycle and rendering
	    setTimeout(runCycle, 1000);
	    requestAnimationFrame(renderCycle);
	});
	
	// On clicking the information button, show the information panel
	document.getElementById("information-btn").addEventListener("click", function() {
	    console.log("show information container here");
	});
	
	/* ======== Information container interactions =========*/
	/* =====================================================*/
	
	
	
	/* ================= Information Click =================*/
	/* =====================================================*/
	// Shows information about towers or monsters if hovered over
	// or active
	var activeCanvasElement = null;
	
	
	function comparePositions(clickPosition, elementPosition, type) {
	    var sideLength = type === "monster" ? 30 : 50; // width and height of the element
	    if (clickPosition.x >= elementPosition.x
	    && clickPosition.x <= elementPosition.x + sideLength
	    && clickPosition.y >= elementPosition.y
	    && clickPosition.y <= elementPosition.y + sideLength) {
	        return true;
	    } else {
	        return false;
	    }
	}
	
	// Takes in a position object (location of the click)
	// returns an object with information about what is at that position
	function checkClickLocation(position) {
	    var element = {};
	    // Loops through activeMonsters
	    for (var i = 0; i < game.activeMonsters.length; i++) {
	        if (comparePositions(position, game.activeMonsters[i].position, "monster")) {
	            element.type = "monster";
	            element.id = game.activeMonsters[i].id;
	            element.index = i;
	            break;
	        }
	    }
	
	    // If nothing was found, loop through towers
	    if (element.type === undefined) {
	        for (var i = 0; i < game.towers.length; i++) {
	            if (comparePositions(position, game.towers[i].position, "tower")) {
	                element.type = "tower";
	                element.id = game.towers[i].id;
	                element.index = i;
	                break;
	            }
	        }
	    }
	
	    // If no towers or monsters found return a type of null
	    if (element.type === undefined) {
	        element.type = null;
	    }
	
	    return element;
	}
	
	// Get information from towerdata.js
	
	/* ========== Tower Card Click and placements ==========*/
	/* =====================================================*/
	// Click a tower card and make "active" which can be placed on UI element
	// While it is active - use #dynamic.onmousemove = function -> to Send
	// information to the canvas
	
	// set up event listeners at the start which reference functions - these functions depend on the state on the application to control their control flow
	var activeTowerSelected = null;
	var towerCards = document.getElementsByClassName("tower-card");
	var towerCardList = [];
	
	function addClass(element, cssClass) {
	    if (element.className === "") {
	        element.className = cssClass;
	    } else {
	        element.className += " " + cssClass;
	    }
	}
	
	function removeClass(element, cssClass) {
	    var arrayOfClasses = element.className.split(" ");
	    for (var i = 0; i < arrayOfClasses.length; i++) {
	        if (arrayOfClasses[i] === cssClass) {
	            arrayOfClasses.splice(i, 1);
	        }
	    }
	    element.className = arrayOfClasses.join(" ");
	}
	
	function getIndex(towerName) {
	    return towerCardList.indexOf(towerName);
	}
	
	function towerCardClick() {
	
	    var towerName = this.getAttribute("data-tower");
	
	    if (/disabled/i.test(this.className)) { // Tower is disabled
	        return;
	    } else if (activeTowerSelected === null) { // There is no active tower being placed
	        // set the active tower selected to be the tower name
	        // Set up active elements
	        activeTowerSelected = towerName;
	        addClass(towerCards[getIndex(activeTowerSelected)], "active");
	    } else if (activeTowerSelected === towerName) { // The tower card clicked is the same as the active tower
	        cancelTowerPlacement();
	    } else { // There is an active tower which is not the same as what was clicked
	        removeClass(towerCards[getIndex(activeTowerSelected)], "active");
	        activeTowerSelected = towerName;
	        addClass(towerCards[getIndex(activeTowerSelected)], "active");
	    }
	}
	
	function onTowerMouseMovement(e) {
	    if (activeTowerSelected === null) {
	        return
	    };
	    var canvasContainer = this.getBoundingClientRect();
	    var offsetX = e.clientX - canvasContainer.left,
	        offsetY = e.clientY - canvasContainer.top;
	    // send to display to get rendered
	};
	
	// Two possible canvas click scenarios:
	// 1) Tower selection is active (place a tower)
	// 2) Tower selection is inactive (clicking to get information about a monster or tower on the map)
	function canvasClick(e) {
	    // Get click location relative to the canvas element
	    var canvasContainer = this.getBoundingClientRect(),
	    position = {};
	
	    position.x = e.clientX - canvasContainer.left;
	    position.y = e.clientY - canvasContainer.top;
	
	    if (activeTowerSelected !== null) { //
	        var towerName = activeTowerSelected; // NOTE CHANGE GET TOWER NAME FROM LIST
	
	        if (game.validateTowerPlacement(towerName, position)) {
	            console.log("towerPlaced");
	            game.addTower(towerName, position);
	        } else {
	            console.log("invalid tower placement");
	            // show error message somewhere for the user
	        }
	        removeClass(towerCards[getIndex(activeTowerSelected)], "active");
	        activeTowerSelected = null;
	
	    } else {
	        // check if the position overlaps with the bounding rectangle of monster or tower
	        var element = checkClickLocation(position);
	        console.log(element);
	        if (element.type === "monster") {
	            infoName.innerHTML = element.id;
	
	        } else if (element.type === "tower") {
	            console.log("show tower information")
	        } else {
	            infoName.innerHTML = "Awesome TD";
	            console.log("show default information")
	        }
	        // if it is, change the information container
	    }
	
	}
	
	function cancelTowerPlacement() {
	
	    removeClass(towerCards[getIndex(activeTowerSelected)], "active");
	    activeTowerSelected = null;
	}
	
	
	// Set up event listeners
	// Convert from nodelist to array
	towerCards = Array.prototype.slice.call(towerCards);
	
	// Tower card click event listeners
	towerCards.map(function(towerCard, i) {
	    towerCardList.push(towerCard.getAttribute("data-tower"));
	    towerCard.addEventListener("click", towerCardClick);
	});
	
	// Game container event listeners
	document.getElementById("dynamic").onmousemove = onTowerMouseMovement;
	document.getElementById("dynamic").addEventListener("click", canvasClick);
	
	// Tower placement cancelling event listeners
	document.onkeydown = function(e) {
	    if (e.keyCode === 27) {
	        cancelTowerPlacement();
	    }
	}


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var towerData = __webpack_require__(5);
	
	var Tower = function(position, id) {
	    this.id = id;
	    this.damage = towerData[id].damage;
	    this.speed = towerData[id].speed; // Attack speed
	    this.range = towerData[id].range; // Range of the tower
	    this.type = towerData[id].type; // Type of damage
	    this.effect = towerData[id].effect; // Special effect (e.g. slow, splash, etc)
	    this.position = position; // object with x and y coordinates - should not change
	}
	// Method the game object uses to run towers
	Tower.prototype.runCycle = function() {
	
	}
	// change this to reference a list or something where a name can be used to determine the properties
	// Takes in a monster's position and checks whether that is in range based on the range - returns true or false if in range which can be used to
	Tower.prototype.checkInRange = function(monsterPosition) {
	
	}
	
	module.exports = Tower;


/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = {
	    basic: {
	        damage: 10,
	        speed: 10,
	        range: 100,
	        type: "basic",
	        effect: "none"
	    }
	};


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	//  require Monster to gain access
	var Monster = __webpack_require__(7);
	
	var GameEngine = function() {
	    this.userGold = 10;
	    this.level = 1;
	    this.userLives = 30;
	    this.activeMonsters = []; // List of active monsters in the
	    this.towers = []; // object of tower objects
	    this.timer = 1;
	    // Goes through and disables towers that can't be used yet
	}
	
	GameEngine.prototype.addMonster = function(name) {
	    // add monster (specified by name) to game
	    var monster = new Monster("monster1");
	    this.activeMonsters.push(monster);
	}
	
	GameEngine.prototype.addTower = function(name, position) {
	    // add tower (specified by name) at location
	}
	
	// method to check gold before place tower or upgrade
	GameEngine.prototype.checkGold = function(goldCost) {
	    if (goldCost > this.userGold) {
	        return true;
	    } else {
	        return false;
	    }
	};
	
	GameEngine.prototype.gameOver = function() {
	
	}
	
	GameEngine.prototype.gameWon = function() {
	
	}
	
	// New level method
	GameEngine.prototype.nextLevel = function() {
	
	}
	
	GameEngine.prototype.render = function() {
	    // send state to the display object to render
	    dynamicContext.beginPath();
	    dynamicContext.clearRect(0, 0, dynamicCanvas.width, dynamicCanvas.height);
	
	    //  loop through list of active monsters and render them
	    //  TODO probably need to find a better way to rend them apart from random rectangle
	    for (var i = 0, j = this.activeMonsters.length; i < j; i ++) {
	        this.activeMonsters[i].draw();
	    }
	
	    // dynamicContext.
	};
	
	GameEngine.prototype.runCycle = function() {
	    //  beginning of cycle check if any monsters have died if so remove from active monsters
	    this.checkMonsterDeath();
	    // loop through active monsters and towers and run the cycle
	    // Each runCycle method returns information for the gameEngine to
	    // process (e.g. the monster died, tower changed)
	
	    //  timer to add monsters
	    this.timer--;
	    if (this.timer < 1) {
	        this.addMonster('blah');
	        this.timer = 10;
	    }
	    for (var i = 0, j = this.activeMonsters.length; i < j; i ++) {
	        this.activeMonsters[i].move();
	    }
	    // Send information to render
	}
	
	// method to upgrade tower
	
	GameEngine.prototype.validateTowerPlacement = function(name, position) {
	    // returns true or false whether tower placement is valid
	    return true;
	}
	
	GameEngine.prototype.checkMonsterDeath = function() {
	    for (var i = 0, j = this.activeMonsters.length; i < j; i ++) {
	        if (this.activeMonsters[i].checkDeath()) {
	            this.activeMonsters.splice(i, 1);
	            i--;
	            j--;
	        }
	    }
	}
	
	// redraw canvas
	
	module.exports = GameEngine;


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var monsterData = __webpack_require__(8);
	
	var Monster = function(id) {
	    this.id = id;
	    this.currentHp = monsterData[id].maxHp;
	    this.maxHp = monsterData[id].maxHp;
	    this.baseMs = monsterData[id].baseMs; // Movement speed - "units" per second
	    this.type = monsterData[id].type;
	    this.position = { // All monsters are created in the same position
	        x: 0,
	        y: 485
	    }
	};
	// Method the game object uses to move monsters
	Monster.prototype.runCycle = function() {
	
	}
	
	Monster.prototype.draw = function() {
	    dynamicContext.beginPath();
	    dynamicContext.rect(this.position.x, this.position.y, 30, 30);
	    dynamicContext.stroke();
	    dynamicContext.fillStyle = "red";
	    dynamicContext.fillRect(this.position.x,
	                            this.position.y + 30/3,
	                            30 * this.currentHp/this.maxHp,
	                            30/3);
	}
	
	Monster.prototype.destroy = function() {
	
	};
	
	Monster.prototype.checkDeath = function() {
	    return this.currentHp <= 0;
	};
	
	// Expects up, down, left or right
	Monster.prototype.move = function(direction) {
	    var speed = this.baseMs;
	
	    // some basic monster Movement
	    //  NOTE such a hassle to figure this out
	    //  TODO not finished, not even going to try and finish will figure out how this should work later
	    if (this.position.x <= 50 && this.position.y < 500) {
	        this.position.x += speed;
	    } else if (this.position.x >= 50 && this.position.y >= 90) {
	        this.position.y -= speed;
	    } else if (this.position.x <= 180 && this.position.y >= 80) {
	        this.position.x += speed;
	    }
	
	    //  may not be the best way to do this but ill keep it because not even sure how to do this movement part
	    // if (typeof direction !== "string") {
	    //     throw new TypeError("direction is not a string");
	    // }
	    // direction = direction.toLowerCase();
	    // switch (direction) {
	    //     case "up":
	    //     case "down":
	    //     case "left":
	    //     case "right":
	    //     default:
	    //         throw new Error("Invalid direction");
	    // }
	};
	
	// Can take in a positive or negative number
	Monster.prototype.updateHp = function(hpChange) {
	    this.currentHp += hpChange;
	
	    if (this.currentHp > this.maxHp) {
	        this.currentHp = this.maxHp;
	    }
	};
	
	module.exports = Monster;


/***/ },
/* 8 */
/***/ function(module, exports) {

	module.exports = {
	    monster1: {
	        maxHp: 30,
	        baseMs: 10,
	        type: 1 // Change this type later
	    }
	};


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNDk5MjM3MGZiYWE1MTdlYWM2NzIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2VudHJ5LmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9iYWNrZ3JvdW5kLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NsYXNzZXMvVG93ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2dhbWVEYXRhL3Rvd2VyZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY2xhc3Nlcy9HYW1lLmpzIiwid2VicGFjazovLy8uL3NyYy9qcy9jbGFzc2VzL01vbnN0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2dhbWVEYXRhL21vbnN0ZXJkYXRhLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3RDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUNKQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0Esb0NBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QUFFQTtBQUNBLG9EQUFtRCxPQUFPO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FDakdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQXlDO0FBQ3pDO0FBQ0Esc0JBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJtYWluLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9zcmMvanMvXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiB3ZWJwYWNrL2Jvb3RzdHJhcCA0OTkyMzcwZmJhYTUxN2VhYzY3MlxuICoqLyIsIi8vIENhbnZhc1xucmVxdWlyZShcIi4vYmFja2dyb3VuZC5qc1wiKTtcblxuLy8gVXNlciBpbnRlcmFjdGlvbiBlbGVtZW50c1xucmVxdWlyZShcIi4vaW50ZXJmYWNlLmpzXCIpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9qcy9lbnRyeS5qc1xuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIGJhY2tncm91bmQgY29udGFpbnMgdGhlIHN0YXRpYyBjYW52YXMgZWxlbWVudHNcbnZhciBiYWNrZ3JvdW5kID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdGF0aWNcIik7XG52YXIgYmFja2dyb3VuZENvbnRleHQgPSBiYWNrZ3JvdW5kLmdldENvbnRleHQoXCIyZFwiKTtcblxuLy8gU2V0dGluZ3MgZm9yIHRoZSBiYWNrZ3JvdW5kIC0gbW92ZSBvdXQgdG8gYSBzZXBhcmF0ZSBmaWxlXG52YXIgc2V0dGluZ3MgPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiBcIiM4Q0QxRTZcIixcbiAgICBwYXRoQ29sb3I6IFwiZ3JheVwiXG59XG5cbi8vIERyYXdpbmcgdGhlIGJhY2tncm91bmRcbmJhY2tncm91bmRDb250ZXh0LmZpbGxTdHlsZSA9IHNldHRpbmdzLmJhY2tncm91bmRDb2xvcjtcbmJhY2tncm91bmRDb250ZXh0LmZpbGxSZWN0KDAsIDAsIGJhY2tncm91bmQud2lkdGgsIGJhY2tncm91bmQuaGVpZ2h0KTtcblxuLyogTWFpbiBwYXRoIHdpbGwgZ28gZnJvbSBbMCwgNTAwXSwgWzc1LCA1MDBdLCBbNzUsIDEwMF0sIFsyMjUsIDEwMF0sIFsyMjUsIDUwMF0sIFszNzUsIDUwMF0sIFszNzUsIDEwMF0sIFs1MjUsIDEwMF0sIFs1MjUsIDUwMF0sIFs2NzUsIDUwMF0sIFs2NzUsIDEwMF0sIFs4MjUsIDEwMF0sIFs4MjUsIDUwMF0sIFs5MDAsIDUwMF0gKi9cblxuLy8gRHJhd2luZyB0aGUgcGF0aCAtIHdpZHRoIG9mIHRoZSBwYXRoIGlzIDUwcHhcbmJhY2tncm91bmRDb250ZXh0LmZpbGxTdHlsZSA9IHNldHRpbmdzLnBhdGhDb2xvcjtcblxuYmFja2dyb3VuZENvbnRleHQuYmVnaW5QYXRoKCk7XG5cbi8vIEZvciB0aGUgYm90dG9tIHBhcnQgb2YgdGhlIHBhdGhcbmJhY2tncm91bmRDb250ZXh0Lm1vdmVUbygwLCA1MjUpO1xuXG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oMTAwLCA1MjUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDEwMCwgMTI1KTsgLy8gVG9wXG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oMjAwLCAxMjUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDIwMCwgNTI1KTsgLy8gQm90dG9tXG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNDAwLCA1MjUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDQwMCwgMTI1KTsgLy8gVG9wXG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNTAwLCAxMjUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDUwMCwgNTI1KTsgLy8gQm90dG9tXG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNzAwLCA1MjUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDcwMCwgMTI1KTsgLy8gVG9wXG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oODAwLCAxMjUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDgwMCwgNTI1KTsgLy8gQm90dG9tXG5cbi8vTWlkZGxlIHNlY3Rpb24gdG8gdGhlIHNpZGVcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg5MDAsIDUyNSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oOTAwLCA0NzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDg1MCwgNDc1KTtcblxuLy8gRm9yIHRoZSB0b3AgcGFydCBvZiB0aGUgcGF0aFxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDg1MCwgNzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDY1MCwgNzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDY1MCwgNDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg1NTAsIDQ3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oNTUwLCA3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oMzUwLCA3NSk7XG5iYWNrZ3JvdW5kQ29udGV4dC5saW5lVG8oMzUwLCA0NzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDI1MCwgNDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbygyNTAsIDc1KTtcbmJhY2tncm91bmRDb250ZXh0LmxpbmVUbyg1MCwgNzUpO1xuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDUwLCA0NzUpO1xuXG4vLyBFbmQgc2VjdGlvblxuYmFja2dyb3VuZENvbnRleHQubGluZVRvKDAsIDQ3NSk7XG5cbmJhY2tncm91bmRDb250ZXh0LmZpbGwoKTtcbi8vIGJhY2tncm91bmRDb250ZXh0LmxpbmVUbygpO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9qcy9iYWNrZ3JvdW5kLmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gSW5pdGlhdGUgYWxsIHRoZSBjb21wb25lbnRzXG52YXIgVG93ZXIgPSByZXF1aXJlKFwiLi9jbGFzc2VzL1Rvd2VyLmpzXCIpLFxuICAgIEdhbWVFbmdpbmUgPSByZXF1aXJlKFwiLi9jbGFzc2VzL0dhbWUuanNcIilcblxuLy8gQ2FjaGUgcmV1c2VkIERPTSBlbGVtZW50c1xudmFyIGluZm9OYW1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJpbmZvLW5hbWVcIiksXG4gICAgaW5mb0JveDEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImluZm8tYm94LTFcIiksXG4gICAgaW5mb0JveDIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImluZm8tYm94LTJcIiksXG4gICAgaW5mb0JveDMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImluZm8tYm94LTNcIiksXG4gICAgaW5mb0JveDQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImluZm8tYm94LTRcIik7XG5cbi8vICBjcmVhdGVzIGdsb2JhbCB2YXJpYWJsZXNcbmdhbWUgPSBuZXcgR2FtZUVuZ2luZTtcbmR5bmFtaWNDYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZHluYW1pYycpO1xuZHluYW1pY0NvbnRleHQgPSBkeW5hbWljQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbnJ1bkN5Y2xlID0gZnVuY3Rpb24oKSB7XG4gICAgZ2FtZS5ydW5DeWNsZSgpO1xuICAgIHNldFRpbWVvdXQocnVuQ3ljbGUsIDEwMDApO1xufVxuXG5yZW5kZXJDeWNsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGdhbWUucmVuZGVyKCk7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlckN5Y2xlKTtcbn1cblxuLy8gSEVSRSBJUyBBTEwgVEhFIElOVEVSQUNUSU9OIEVWRU5UIExJU1RFTkVSU1xuXG4vKiA9PT09PT09PT09PT09PSBPbiBzdGFydCBjbGljayBoYW5kbGVycyA9PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbi8vIE9uIHN0YXJ0LCBjcmVhdGUgYSBnYW1lIGVsZW1lbnQgLSB0aGVzZSBldmVudCBsaXN0ZW5lcnMgd2lsbCBiZSBkZXN0cm95ZWQgd2hlbiB0aGUgY29udGFpbmVyIGlzIG92ZXJyaWRlblxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdGFydC1idG5cIikuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgIC8vIEhpZGVzIHRoZSBtb2RhbCBsaWdodGJveFxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJtb2RhbC1jb250ZW50XCIpWzBdLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwibW9kYWwtYmFja2dyb3VuZFwiKVswXS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cbiAgICAvLyBydW4gcmVwZWF0aW5nIGZ1bmN0aW9uIHRoYXQgcnVucyBnYW1lIGVuZ2luZSBydW4gY3ljbGUgYW5kIHJlbmRlcmluZ1xuICAgIHNldFRpbWVvdXQocnVuQ3ljbGUsIDEwMDApO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShyZW5kZXJDeWNsZSk7XG59KTtcblxuLy8gT24gY2xpY2tpbmcgdGhlIGluZm9ybWF0aW9uIGJ1dHRvbiwgc2hvdyB0aGUgaW5mb3JtYXRpb24gcGFuZWxcbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5mb3JtYXRpb24tYnRuXCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICBjb25zb2xlLmxvZyhcInNob3cgaW5mb3JtYXRpb24gY29udGFpbmVyIGhlcmVcIik7XG59KTtcblxuLyogPT09PT09PT0gSW5mb3JtYXRpb24gY29udGFpbmVyIGludGVyYWN0aW9ucyA9PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cblxuLyogPT09PT09PT09PT09PT09PT0gSW5mb3JtYXRpb24gQ2xpY2sgPT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLy8gU2hvd3MgaW5mb3JtYXRpb24gYWJvdXQgdG93ZXJzIG9yIG1vbnN0ZXJzIGlmIGhvdmVyZWQgb3ZlclxuLy8gb3IgYWN0aXZlXG52YXIgYWN0aXZlQ2FudmFzRWxlbWVudCA9IG51bGw7XG5cblxuZnVuY3Rpb24gY29tcGFyZVBvc2l0aW9ucyhjbGlja1Bvc2l0aW9uLCBlbGVtZW50UG9zaXRpb24sIHR5cGUpIHtcbiAgICB2YXIgc2lkZUxlbmd0aCA9IHR5cGUgPT09IFwibW9uc3RlclwiID8gMzAgOiA1MDsgLy8gd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgZWxlbWVudFxuICAgIGlmIChjbGlja1Bvc2l0aW9uLnggPj0gZWxlbWVudFBvc2l0aW9uLnhcbiAgICAmJiBjbGlja1Bvc2l0aW9uLnggPD0gZWxlbWVudFBvc2l0aW9uLnggKyBzaWRlTGVuZ3RoXG4gICAgJiYgY2xpY2tQb3NpdGlvbi55ID49IGVsZW1lbnRQb3NpdGlvbi55XG4gICAgJiYgY2xpY2tQb3NpdGlvbi55IDw9IGVsZW1lbnRQb3NpdGlvbi55ICsgc2lkZUxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vLyBUYWtlcyBpbiBhIHBvc2l0aW9uIG9iamVjdCAobG9jYXRpb24gb2YgdGhlIGNsaWNrKVxuLy8gcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGlzIGF0IHRoYXQgcG9zaXRpb25cbmZ1bmN0aW9uIGNoZWNrQ2xpY2tMb2NhdGlvbihwb3NpdGlvbikge1xuICAgIHZhciBlbGVtZW50ID0ge307XG4gICAgLy8gTG9vcHMgdGhyb3VnaCBhY3RpdmVNb25zdGVyc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2FtZS5hY3RpdmVNb25zdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoY29tcGFyZVBvc2l0aW9ucyhwb3NpdGlvbiwgZ2FtZS5hY3RpdmVNb25zdGVyc1tpXS5wb3NpdGlvbiwgXCJtb25zdGVyXCIpKSB7XG4gICAgICAgICAgICBlbGVtZW50LnR5cGUgPSBcIm1vbnN0ZXJcIjtcbiAgICAgICAgICAgIGVsZW1lbnQuaWQgPSBnYW1lLmFjdGl2ZU1vbnN0ZXJzW2ldLmlkO1xuICAgICAgICAgICAgZWxlbWVudC5pbmRleCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kLCBsb29wIHRocm91Z2ggdG93ZXJzXG4gICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2FtZS50b3dlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjb21wYXJlUG9zaXRpb25zKHBvc2l0aW9uLCBnYW1lLnRvd2Vyc1tpXS5wb3NpdGlvbiwgXCJ0b3dlclwiKSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQudHlwZSA9IFwidG93ZXJcIjtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmlkID0gZ2FtZS50b3dlcnNbaV0uaWQ7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBubyB0b3dlcnMgb3IgbW9uc3RlcnMgZm91bmQgcmV0dXJuIGEgdHlwZSBvZiBudWxsXG4gICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVsZW1lbnQudHlwZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbi8vIEdldCBpbmZvcm1hdGlvbiBmcm9tIHRvd2VyZGF0YS5qc1xuXG4vKiA9PT09PT09PT09IFRvd2VyIENhcmQgQ2xpY2sgYW5kIHBsYWNlbWVudHMgPT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vLyBDbGljayBhIHRvd2VyIGNhcmQgYW5kIG1ha2UgXCJhY3RpdmVcIiB3aGljaCBjYW4gYmUgcGxhY2VkIG9uIFVJIGVsZW1lbnRcbi8vIFdoaWxlIGl0IGlzIGFjdGl2ZSAtIHVzZSAjZHluYW1pYy5vbm1vdXNlbW92ZSA9IGZ1bmN0aW9uIC0+IHRvIFNlbmRcbi8vIGluZm9ybWF0aW9uIHRvIHRoZSBjYW52YXNcblxuLy8gc2V0IHVwIGV2ZW50IGxpc3RlbmVycyBhdCB0aGUgc3RhcnQgd2hpY2ggcmVmZXJlbmNlIGZ1bmN0aW9ucyAtIHRoZXNlIGZ1bmN0aW9ucyBkZXBlbmQgb24gdGhlIHN0YXRlIG9uIHRoZSBhcHBsaWNhdGlvbiB0byBjb250cm9sIHRoZWlyIGNvbnRyb2wgZmxvd1xudmFyIGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPSBudWxsO1xudmFyIHRvd2VyQ2FyZHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwidG93ZXItY2FyZFwiKTtcbnZhciB0b3dlckNhcmRMaXN0ID0gW107XG5cbmZ1bmN0aW9uIGFkZENsYXNzKGVsZW1lbnQsIGNzc0NsYXNzKSB7XG4gICAgaWYgKGVsZW1lbnQuY2xhc3NOYW1lID09PSBcIlwiKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gY3NzQ2xhc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgKz0gXCIgXCIgKyBjc3NDbGFzcztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNzc0NsYXNzKSB7XG4gICAgdmFyIGFycmF5T2ZDbGFzc2VzID0gZWxlbWVudC5jbGFzc05hbWUuc3BsaXQoXCIgXCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZkNsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFycmF5T2ZDbGFzc2VzW2ldID09PSBjc3NDbGFzcykge1xuICAgICAgICAgICAgYXJyYXlPZkNsYXNzZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gYXJyYXlPZkNsYXNzZXMuam9pbihcIiBcIik7XG59XG5cbmZ1bmN0aW9uIGdldEluZGV4KHRvd2VyTmFtZSkge1xuICAgIHJldHVybiB0b3dlckNhcmRMaXN0LmluZGV4T2YodG93ZXJOYW1lKTtcbn1cblxuZnVuY3Rpb24gdG93ZXJDYXJkQ2xpY2soKSB7XG5cbiAgICB2YXIgdG93ZXJOYW1lID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRvd2VyXCIpO1xuXG4gICAgaWYgKC9kaXNhYmxlZC9pLnRlc3QodGhpcy5jbGFzc05hbWUpKSB7IC8vIFRvd2VyIGlzIGRpc2FibGVkXG4gICAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPT09IG51bGwpIHsgLy8gVGhlcmUgaXMgbm8gYWN0aXZlIHRvd2VyIGJlaW5nIHBsYWNlZFxuICAgICAgICAvLyBzZXQgdGhlIGFjdGl2ZSB0b3dlciBzZWxlY3RlZCB0byBiZSB0aGUgdG93ZXIgbmFtZVxuICAgICAgICAvLyBTZXQgdXAgYWN0aXZlIGVsZW1lbnRzXG4gICAgICAgIGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPSB0b3dlck5hbWU7XG4gICAgICAgIGFkZENsYXNzKHRvd2VyQ2FyZHNbZ2V0SW5kZXgoYWN0aXZlVG93ZXJTZWxlY3RlZCldLCBcImFjdGl2ZVwiKTtcbiAgICB9IGVsc2UgaWYgKGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPT09IHRvd2VyTmFtZSkgeyAvLyBUaGUgdG93ZXIgY2FyZCBjbGlja2VkIGlzIHRoZSBzYW1lIGFzIHRoZSBhY3RpdmUgdG93ZXJcbiAgICAgICAgY2FuY2VsVG93ZXJQbGFjZW1lbnQoKTtcbiAgICB9IGVsc2UgeyAvLyBUaGVyZSBpcyBhbiBhY3RpdmUgdG93ZXIgd2hpY2ggaXMgbm90IHRoZSBzYW1lIGFzIHdoYXQgd2FzIGNsaWNrZWRcbiAgICAgICAgcmVtb3ZlQ2xhc3ModG93ZXJDYXJkc1tnZXRJbmRleChhY3RpdmVUb3dlclNlbGVjdGVkKV0sIFwiYWN0aXZlXCIpO1xuICAgICAgICBhY3RpdmVUb3dlclNlbGVjdGVkID0gdG93ZXJOYW1lO1xuICAgICAgICBhZGRDbGFzcyh0b3dlckNhcmRzW2dldEluZGV4KGFjdGl2ZVRvd2VyU2VsZWN0ZWQpXSwgXCJhY3RpdmVcIik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBvblRvd2VyTW91c2VNb3ZlbWVudChlKSB7XG4gICAgaWYgKGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgfTtcbiAgICB2YXIgY2FudmFzQ29udGFpbmVyID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgb2Zmc2V0WCA9IGUuY2xpZW50WCAtIGNhbnZhc0NvbnRhaW5lci5sZWZ0LFxuICAgICAgICBvZmZzZXRZID0gZS5jbGllbnRZIC0gY2FudmFzQ29udGFpbmVyLnRvcDtcbiAgICAvLyBzZW5kIHRvIGRpc3BsYXkgdG8gZ2V0IHJlbmRlcmVkXG59O1xuXG4vLyBUd28gcG9zc2libGUgY2FudmFzIGNsaWNrIHNjZW5hcmlvczpcbi8vIDEpIFRvd2VyIHNlbGVjdGlvbiBpcyBhY3RpdmUgKHBsYWNlIGEgdG93ZXIpXG4vLyAyKSBUb3dlciBzZWxlY3Rpb24gaXMgaW5hY3RpdmUgKGNsaWNraW5nIHRvIGdldCBpbmZvcm1hdGlvbiBhYm91dCBhIG1vbnN0ZXIgb3IgdG93ZXIgb24gdGhlIG1hcClcbmZ1bmN0aW9uIGNhbnZhc0NsaWNrKGUpIHtcbiAgICAvLyBHZXQgY2xpY2sgbG9jYXRpb24gcmVsYXRpdmUgdG8gdGhlIGNhbnZhcyBlbGVtZW50XG4gICAgdmFyIGNhbnZhc0NvbnRhaW5lciA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgcG9zaXRpb24gPSB7fTtcblxuICAgIHBvc2l0aW9uLnggPSBlLmNsaWVudFggLSBjYW52YXNDb250YWluZXIubGVmdDtcbiAgICBwb3NpdGlvbi55ID0gZS5jbGllbnRZIC0gY2FudmFzQ29udGFpbmVyLnRvcDtcblxuICAgIGlmIChhY3RpdmVUb3dlclNlbGVjdGVkICE9PSBudWxsKSB7IC8vXG4gICAgICAgIHZhciB0b3dlck5hbWUgPSBhY3RpdmVUb3dlclNlbGVjdGVkOyAvLyBOT1RFIENIQU5HRSBHRVQgVE9XRVIgTkFNRSBGUk9NIExJU1RcblxuICAgICAgICBpZiAoZ2FtZS52YWxpZGF0ZVRvd2VyUGxhY2VtZW50KHRvd2VyTmFtZSwgcG9zaXRpb24pKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInRvd2VyUGxhY2VkXCIpO1xuICAgICAgICAgICAgZ2FtZS5hZGRUb3dlcih0b3dlck5hbWUsIHBvc2l0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiaW52YWxpZCB0b3dlciBwbGFjZW1lbnRcIik7XG4gICAgICAgICAgICAvLyBzaG93IGVycm9yIG1lc3NhZ2Ugc29tZXdoZXJlIGZvciB0aGUgdXNlclxuICAgICAgICB9XG4gICAgICAgIHJlbW92ZUNsYXNzKHRvd2VyQ2FyZHNbZ2V0SW5kZXgoYWN0aXZlVG93ZXJTZWxlY3RlZCldLCBcImFjdGl2ZVwiKTtcbiAgICAgICAgYWN0aXZlVG93ZXJTZWxlY3RlZCA9IG51bGw7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjaGVjayBpZiB0aGUgcG9zaXRpb24gb3ZlcmxhcHMgd2l0aCB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIG9mIG1vbnN0ZXIgb3IgdG93ZXJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBjaGVja0NsaWNrTG9jYXRpb24ocG9zaXRpb24pO1xuICAgICAgICBjb25zb2xlLmxvZyhlbGVtZW50KTtcbiAgICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gXCJtb25zdGVyXCIpIHtcbiAgICAgICAgICAgIGluZm9OYW1lLmlubmVySFRNTCA9IGVsZW1lbnQuaWQ7XG5cbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnR5cGUgPT09IFwidG93ZXJcIikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJzaG93IHRvd2VyIGluZm9ybWF0aW9uXCIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmZvTmFtZS5pbm5lckhUTUwgPSBcIkF3ZXNvbWUgVERcIjtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic2hvdyBkZWZhdWx0IGluZm9ybWF0aW9uXCIpXG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgaXQgaXMsIGNoYW5nZSB0aGUgaW5mb3JtYXRpb24gY29udGFpbmVyXG4gICAgfVxuXG59XG5cbmZ1bmN0aW9uIGNhbmNlbFRvd2VyUGxhY2VtZW50KCkge1xuXG4gICAgcmVtb3ZlQ2xhc3ModG93ZXJDYXJkc1tnZXRJbmRleChhY3RpdmVUb3dlclNlbGVjdGVkKV0sIFwiYWN0aXZlXCIpO1xuICAgIGFjdGl2ZVRvd2VyU2VsZWN0ZWQgPSBudWxsO1xufVxuXG5cbi8vIFNldCB1cCBldmVudCBsaXN0ZW5lcnNcbi8vIENvbnZlcnQgZnJvbSBub2RlbGlzdCB0byBhcnJheVxudG93ZXJDYXJkcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRvd2VyQ2FyZHMpO1xuXG4vLyBUb3dlciBjYXJkIGNsaWNrIGV2ZW50IGxpc3RlbmVyc1xudG93ZXJDYXJkcy5tYXAoZnVuY3Rpb24odG93ZXJDYXJkLCBpKSB7XG4gICAgdG93ZXJDYXJkTGlzdC5wdXNoKHRvd2VyQ2FyZC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRvd2VyXCIpKTtcbiAgICB0b3dlckNhcmQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRvd2VyQ2FyZENsaWNrKTtcbn0pO1xuXG4vLyBHYW1lIGNvbnRhaW5lciBldmVudCBsaXN0ZW5lcnNcbmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZHluYW1pY1wiKS5vbm1vdXNlbW92ZSA9IG9uVG93ZXJNb3VzZU1vdmVtZW50O1xuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkeW5hbWljXCIpLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBjYW52YXNDbGljayk7XG5cbi8vIFRvd2VyIHBsYWNlbWVudCBjYW5jZWxsaW5nIGV2ZW50IGxpc3RlbmVyc1xuZG9jdW1lbnQub25rZXlkb3duID0gZnVuY3Rpb24oZSkge1xuICAgIGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgIGNhbmNlbFRvd2VyUGxhY2VtZW50KCk7XG4gICAgfVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9qcy9pbnRlcmZhY2UuanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgdG93ZXJEYXRhID0gcmVxdWlyZShcIi4uL2dhbWVEYXRhL3Rvd2VyZGF0YS5qc1wiKTtcblxudmFyIFRvd2VyID0gZnVuY3Rpb24ocG9zaXRpb24sIGlkKSB7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuZGFtYWdlID0gdG93ZXJEYXRhW2lkXS5kYW1hZ2U7XG4gICAgdGhpcy5zcGVlZCA9IHRvd2VyRGF0YVtpZF0uc3BlZWQ7IC8vIEF0dGFjayBzcGVlZFxuICAgIHRoaXMucmFuZ2UgPSB0b3dlckRhdGFbaWRdLnJhbmdlOyAvLyBSYW5nZSBvZiB0aGUgdG93ZXJcbiAgICB0aGlzLnR5cGUgPSB0b3dlckRhdGFbaWRdLnR5cGU7IC8vIFR5cGUgb2YgZGFtYWdlXG4gICAgdGhpcy5lZmZlY3QgPSB0b3dlckRhdGFbaWRdLmVmZmVjdDsgLy8gU3BlY2lhbCBlZmZlY3QgKGUuZy4gc2xvdywgc3BsYXNoLCBldGMpXG4gICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uOyAvLyBvYmplY3Qgd2l0aCB4IGFuZCB5IGNvb3JkaW5hdGVzIC0gc2hvdWxkIG5vdCBjaGFuZ2Vcbn1cbi8vIE1ldGhvZCB0aGUgZ2FtZSBvYmplY3QgdXNlcyB0byBydW4gdG93ZXJzXG5Ub3dlci5wcm90b3R5cGUucnVuQ3ljbGUgPSBmdW5jdGlvbigpIHtcblxufVxuLy8gY2hhbmdlIHRoaXMgdG8gcmVmZXJlbmNlIGEgbGlzdCBvciBzb21ldGhpbmcgd2hlcmUgYSBuYW1lIGNhbiBiZSB1c2VkIHRvIGRldGVybWluZSB0aGUgcHJvcGVydGllc1xuLy8gVGFrZXMgaW4gYSBtb25zdGVyJ3MgcG9zaXRpb24gYW5kIGNoZWNrcyB3aGV0aGVyIHRoYXQgaXMgaW4gcmFuZ2UgYmFzZWQgb24gdGhlIHJhbmdlIC0gcmV0dXJucyB0cnVlIG9yIGZhbHNlIGlmIGluIHJhbmdlIHdoaWNoIGNhbiBiZSB1c2VkIHRvXG5Ub3dlci5wcm90b3R5cGUuY2hlY2tJblJhbmdlID0gZnVuY3Rpb24obW9uc3RlclBvc2l0aW9uKSB7XG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUb3dlcjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvY2xhc3Nlcy9Ub3dlci5qc1xuICoqIG1vZHVsZSBpZCA9IDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGJhc2ljOiB7XG4gICAgICAgIGRhbWFnZTogMTAsXG4gICAgICAgIHNwZWVkOiAxMCxcbiAgICAgICAgcmFuZ2U6IDEwMCxcbiAgICAgICAgdHlwZTogXCJiYXNpY1wiLFxuICAgICAgICBlZmZlY3Q6IFwibm9uZVwiXG4gICAgfVxufTtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvZ2FtZURhdGEvdG93ZXJkYXRhLmpzXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gIHJlcXVpcmUgTW9uc3RlciB0byBnYWluIGFjY2Vzc1xudmFyIE1vbnN0ZXIgPSByZXF1aXJlKFwiLi9Nb25zdGVyLmpzXCIpO1xuXG52YXIgR2FtZUVuZ2luZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudXNlckdvbGQgPSAxMDtcbiAgICB0aGlzLmxldmVsID0gMTtcbiAgICB0aGlzLnVzZXJMaXZlcyA9IDMwO1xuICAgIHRoaXMuYWN0aXZlTW9uc3RlcnMgPSBbXTsgLy8gTGlzdCBvZiBhY3RpdmUgbW9uc3RlcnMgaW4gdGhlXG4gICAgdGhpcy50b3dlcnMgPSBbXTsgLy8gb2JqZWN0IG9mIHRvd2VyIG9iamVjdHNcbiAgICB0aGlzLnRpbWVyID0gMTtcbiAgICAvLyBHb2VzIHRocm91Z2ggYW5kIGRpc2FibGVzIHRvd2VycyB0aGF0IGNhbid0IGJlIHVzZWQgeWV0XG59XG5cbkdhbWVFbmdpbmUucHJvdG90eXBlLmFkZE1vbnN0ZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgLy8gYWRkIG1vbnN0ZXIgKHNwZWNpZmllZCBieSBuYW1lKSB0byBnYW1lXG4gICAgdmFyIG1vbnN0ZXIgPSBuZXcgTW9uc3RlcihcIm1vbnN0ZXIxXCIpO1xuICAgIHRoaXMuYWN0aXZlTW9uc3RlcnMucHVzaChtb25zdGVyKTtcbn1cblxuR2FtZUVuZ2luZS5wcm90b3R5cGUuYWRkVG93ZXIgPSBmdW5jdGlvbihuYW1lLCBwb3NpdGlvbikge1xuICAgIC8vIGFkZCB0b3dlciAoc3BlY2lmaWVkIGJ5IG5hbWUpIGF0IGxvY2F0aW9uXG59XG5cbi8vIG1ldGhvZCB0byBjaGVjayBnb2xkIGJlZm9yZSBwbGFjZSB0b3dlciBvciB1cGdyYWRlXG5HYW1lRW5naW5lLnByb3RvdHlwZS5jaGVja0dvbGQgPSBmdW5jdGlvbihnb2xkQ29zdCkge1xuICAgIGlmIChnb2xkQ29zdCA+IHRoaXMudXNlckdvbGQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cbkdhbWVFbmdpbmUucHJvdG90eXBlLmdhbWVPdmVyID0gZnVuY3Rpb24oKSB7XG5cbn1cblxuR2FtZUVuZ2luZS5wcm90b3R5cGUuZ2FtZVdvbiA9IGZ1bmN0aW9uKCkge1xuXG59XG5cbi8vIE5ldyBsZXZlbCBtZXRob2RcbkdhbWVFbmdpbmUucHJvdG90eXBlLm5leHRMZXZlbCA9IGZ1bmN0aW9uKCkge1xuXG59XG5cbkdhbWVFbmdpbmUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHNlbmQgc3RhdGUgdG8gdGhlIGRpc3BsYXkgb2JqZWN0IHRvIHJlbmRlclxuICAgIGR5bmFtaWNDb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGR5bmFtaWNDb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBkeW5hbWljQ2FudmFzLndpZHRoLCBkeW5hbWljQ2FudmFzLmhlaWdodCk7XG5cbiAgICAvLyAgbG9vcCB0aHJvdWdoIGxpc3Qgb2YgYWN0aXZlIG1vbnN0ZXJzIGFuZCByZW5kZXIgdGhlbVxuICAgIC8vICBUT0RPIHByb2JhYmx5IG5lZWQgdG8gZmluZCBhIGJldHRlciB3YXkgdG8gcmVuZCB0aGVtIGFwYXJ0IGZyb20gcmFuZG9tIHJlY3RhbmdsZVxuICAgIGZvciAodmFyIGkgPSAwLCBqID0gdGhpcy5hY3RpdmVNb25zdGVycy5sZW5ndGg7IGkgPCBqOyBpICsrKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlTW9uc3RlcnNbaV0uZHJhdygpO1xuICAgIH1cblxuICAgIC8vIGR5bmFtaWNDb250ZXh0LlxufTtcblxuR2FtZUVuZ2luZS5wcm90b3R5cGUucnVuQ3ljbGUgPSBmdW5jdGlvbigpIHtcbiAgICAvLyAgYmVnaW5uaW5nIG9mIGN5Y2xlIGNoZWNrIGlmIGFueSBtb25zdGVycyBoYXZlIGRpZWQgaWYgc28gcmVtb3ZlIGZyb20gYWN0aXZlIG1vbnN0ZXJzXG4gICAgdGhpcy5jaGVja01vbnN0ZXJEZWF0aCgpO1xuICAgIC8vIGxvb3AgdGhyb3VnaCBhY3RpdmUgbW9uc3RlcnMgYW5kIHRvd2VycyBhbmQgcnVuIHRoZSBjeWNsZVxuICAgIC8vIEVhY2ggcnVuQ3ljbGUgbWV0aG9kIHJldHVybnMgaW5mb3JtYXRpb24gZm9yIHRoZSBnYW1lRW5naW5lIHRvXG4gICAgLy8gcHJvY2VzcyAoZS5nLiB0aGUgbW9uc3RlciBkaWVkLCB0b3dlciBjaGFuZ2VkKVxuXG4gICAgLy8gIHRpbWVyIHRvIGFkZCBtb25zdGVyc1xuICAgIHRoaXMudGltZXItLTtcbiAgICBpZiAodGhpcy50aW1lciA8IDEpIHtcbiAgICAgICAgdGhpcy5hZGRNb25zdGVyKCdibGFoJyk7XG4gICAgICAgIHRoaXMudGltZXIgPSAxMDtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSB0aGlzLmFjdGl2ZU1vbnN0ZXJzLmxlbmd0aDsgaSA8IGo7IGkgKyspIHtcbiAgICAgICAgdGhpcy5hY3RpdmVNb25zdGVyc1tpXS5tb3ZlKCk7XG4gICAgfVxuICAgIC8vIFNlbmQgaW5mb3JtYXRpb24gdG8gcmVuZGVyXG59XG5cbi8vIG1ldGhvZCB0byB1cGdyYWRlIHRvd2VyXG5cbkdhbWVFbmdpbmUucHJvdG90eXBlLnZhbGlkYXRlVG93ZXJQbGFjZW1lbnQgPSBmdW5jdGlvbihuYW1lLCBwb3NpdGlvbikge1xuICAgIC8vIHJldHVybnMgdHJ1ZSBvciBmYWxzZSB3aGV0aGVyIHRvd2VyIHBsYWNlbWVudCBpcyB2YWxpZFxuICAgIHJldHVybiB0cnVlO1xufVxuXG5HYW1lRW5naW5lLnByb3RvdHlwZS5jaGVja01vbnN0ZXJEZWF0aCA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gdGhpcy5hY3RpdmVNb25zdGVycy5sZW5ndGg7IGkgPCBqOyBpICsrKSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZU1vbnN0ZXJzW2ldLmNoZWNrRGVhdGgoKSkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVNb25zdGVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBpLS07XG4gICAgICAgICAgICBqLS07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIHJlZHJhdyBjYW52YXNcblxubW9kdWxlLmV4cG9ydHMgPSBHYW1lRW5naW5lO1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9qcy9jbGFzc2VzL0dhbWUuanNcbiAqKiBtb2R1bGUgaWQgPSA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgbW9uc3RlckRhdGEgPSByZXF1aXJlKFwiLi4vZ2FtZURhdGEvbW9uc3RlcmRhdGEuanNcIik7XG5cbnZhciBNb25zdGVyID0gZnVuY3Rpb24oaWQpIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgdGhpcy5jdXJyZW50SHAgPSBtb25zdGVyRGF0YVtpZF0ubWF4SHA7XG4gICAgdGhpcy5tYXhIcCA9IG1vbnN0ZXJEYXRhW2lkXS5tYXhIcDtcbiAgICB0aGlzLmJhc2VNcyA9IG1vbnN0ZXJEYXRhW2lkXS5iYXNlTXM7IC8vIE1vdmVtZW50IHNwZWVkIC0gXCJ1bml0c1wiIHBlciBzZWNvbmRcbiAgICB0aGlzLnR5cGUgPSBtb25zdGVyRGF0YVtpZF0udHlwZTtcbiAgICB0aGlzLnBvc2l0aW9uID0geyAvLyBBbGwgbW9uc3RlcnMgYXJlIGNyZWF0ZWQgaW4gdGhlIHNhbWUgcG9zaXRpb25cbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogNDg1XG4gICAgfVxufTtcbi8vIE1ldGhvZCB0aGUgZ2FtZSBvYmplY3QgdXNlcyB0byBtb3ZlIG1vbnN0ZXJzXG5Nb25zdGVyLnByb3RvdHlwZS5ydW5DeWNsZSA9IGZ1bmN0aW9uKCkge1xuXG59XG5cbk1vbnN0ZXIucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbigpIHtcbiAgICBkeW5hbWljQ29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBkeW5hbWljQ29udGV4dC5yZWN0KHRoaXMucG9zaXRpb24ueCwgdGhpcy5wb3NpdGlvbi55LCAzMCwgMzApO1xuICAgIGR5bmFtaWNDb250ZXh0LnN0cm9rZSgpO1xuICAgIGR5bmFtaWNDb250ZXh0LmZpbGxTdHlsZSA9IFwicmVkXCI7XG4gICAgZHluYW1pY0NvbnRleHQuZmlsbFJlY3QodGhpcy5wb3NpdGlvbi54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24ueSArIDMwLzMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMzAgKiB0aGlzLmN1cnJlbnRIcC90aGlzLm1heEhwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDMwLzMpO1xufVxuXG5Nb25zdGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG5cbn07XG5cbk1vbnN0ZXIucHJvdG90eXBlLmNoZWNrRGVhdGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50SHAgPD0gMDtcbn07XG5cbi8vIEV4cGVjdHMgdXAsIGRvd24sIGxlZnQgb3IgcmlnaHRcbk1vbnN0ZXIucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbihkaXJlY3Rpb24pIHtcbiAgICB2YXIgc3BlZWQgPSB0aGlzLmJhc2VNcztcblxuICAgIC8vIHNvbWUgYmFzaWMgbW9uc3RlciBNb3ZlbWVudFxuICAgIC8vICBOT1RFIHN1Y2ggYSBoYXNzbGUgdG8gZmlndXJlIHRoaXMgb3V0XG4gICAgLy8gIFRPRE8gbm90IGZpbmlzaGVkLCBub3QgZXZlbiBnb2luZyB0byB0cnkgYW5kIGZpbmlzaCB3aWxsIGZpZ3VyZSBvdXQgaG93IHRoaXMgc2hvdWxkIHdvcmsgbGF0ZXJcbiAgICBpZiAodGhpcy5wb3NpdGlvbi54IDw9IDUwICYmIHRoaXMucG9zaXRpb24ueSA8IDUwMCkge1xuICAgICAgICB0aGlzLnBvc2l0aW9uLnggKz0gc3BlZWQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBvc2l0aW9uLnggPj0gNTAgJiYgdGhpcy5wb3NpdGlvbi55ID49IDkwKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24ueSAtPSBzcGVlZDtcbiAgICB9IGVsc2UgaWYgKHRoaXMucG9zaXRpb24ueCA8PSAxODAgJiYgdGhpcy5wb3NpdGlvbi55ID49IDgwKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb24ueCArPSBzcGVlZDtcbiAgICB9XG5cbiAgICAvLyAgbWF5IG5vdCBiZSB0aGUgYmVzdCB3YXkgdG8gZG8gdGhpcyBidXQgaWxsIGtlZXAgaXQgYmVjYXVzZSBub3QgZXZlbiBzdXJlIGhvdyB0byBkbyB0aGlzIG1vdmVtZW50IHBhcnRcbiAgICAvLyBpZiAodHlwZW9mIGRpcmVjdGlvbiAhPT0gXCJzdHJpbmdcIikge1xuICAgIC8vICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZGlyZWN0aW9uIGlzIG5vdCBhIHN0cmluZ1wiKTtcbiAgICAvLyB9XG4gICAgLy8gZGlyZWN0aW9uID0gZGlyZWN0aW9uLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAvLyAgICAgY2FzZSBcInVwXCI6XG4gICAgLy8gICAgIGNhc2UgXCJkb3duXCI6XG4gICAgLy8gICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgLy8gICAgIGNhc2UgXCJyaWdodFwiOlxuICAgIC8vICAgICBkZWZhdWx0OlxuICAgIC8vICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkaXJlY3Rpb25cIik7XG4gICAgLy8gfVxufTtcblxuLy8gQ2FuIHRha2UgaW4gYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBudW1iZXJcbk1vbnN0ZXIucHJvdG90eXBlLnVwZGF0ZUhwID0gZnVuY3Rpb24oaHBDaGFuZ2UpIHtcbiAgICB0aGlzLmN1cnJlbnRIcCArPSBocENoYW5nZTtcblxuICAgIGlmICh0aGlzLmN1cnJlbnRIcCA+IHRoaXMubWF4SHApIHtcbiAgICAgICAgdGhpcy5jdXJyZW50SHAgPSB0aGlzLm1heEhwO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTW9uc3RlcjtcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9zcmMvanMvY2xhc3Nlcy9Nb25zdGVyLmpzXG4gKiogbW9kdWxlIGlkID0gN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbW9uc3RlcjE6IHtcbiAgICAgICAgbWF4SHA6IDMwLFxuICAgICAgICBiYXNlTXM6IDEwLFxuICAgICAgICB0eXBlOiAxIC8vIENoYW5nZSB0aGlzIHR5cGUgbGF0ZXJcbiAgICB9XG59O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9qcy9nYW1lRGF0YS9tb25zdGVyZGF0YS5qc1xuICoqIG1vZHVsZSBpZCA9IDhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=